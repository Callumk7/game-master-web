This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  agents/
    project-manager-backlog.md
  settings.local.json
.wrangler/
  deploy/
    config.json
backlog/
  tasks/
    task-001 - Migrate-description-fields-to-content-fields-across-all-entities.md
  config.yml
notes/
  claude/
    issues/
      codegen-250911.md
  comparison-example.md
  components.md
  migration.md
  routes.md
  todo.md
public/
  manifest.json
  robots.txt
server/
  schema/
    swagger.json
src/
  api/
    @tanstack/
      react-query.gen.ts
    client/
      client.gen.ts
      index.ts
      types.gen.ts
      utils.gen.ts
    core/
      auth.gen.ts
      bodySerializer.gen.ts
      params.gen.ts
      pathSerializer.gen.ts
      serverSentEvents.gen.ts
      types.gen.ts
      utils.gen.ts
    client.gen.ts
    index.ts
    sdk.gen.ts
    types.gen.ts
    zod.gen.ts
  components/
    characters/
      character-menu.tsx
      character-note-view.tsx
      character-table.tsx
      create-character-form.tsx
      create-character-link.tsx
      create-character-sheet.tsx
      edit-character-dialog.tsx
      edit-character-form.tsx
      select-faction-combobox.tsx
      select-note-combobox.tsx
    factions/
      create-faction-form.tsx
      create-faction-link.tsx
      create-faction-sheet.tsx
      edit-faction-dialog.tsx
      edit-faction-form.tsx
      factions-table.tsx
    forms/
      factory-v2.tsx
      schemas.ts
      smart-factory.tsx
      type-utils.ts
    games/
      create-game-form.tsx
    layout/
      game-sidebar.tsx
      tree.tsx
      user-sidebar.tsx
    links/
      hooks/
        useCreateLink.ts
        useDeleteLink.ts
        useGameEntities.ts
      create-link.tsx
      delete-link.tsx
      index.ts
      types.ts
    locations/
      create-location-form.tsx
      create-location-link.tsx
      create-location-sheet.tsx
      edit-location-dialog.tsx
      edit-location-form.tsx
      locations-table.tsx
      parent-location-select.tsx
    notes/
      create-note-form.tsx
      create-note-link.tsx
      create-note-sheet.tsx
      edit-note-dialog.tsx
      edit-note-form.tsx
      note-links-popover.tsx
      notes-table.tsx
    quests/
      create-quest-form.tsx
      create-quest-link.tsx
      create-quest-sheet.tsx
      edit-quest-dialog.tsx
      edit-quest-form.tsx
      parent-quest-select.tsx
      quest-links-popover.tsx
      quests-table.tsx
    ui/
      composite/
        form-field.tsx
        tag-input.tsx
      editor/
        hooks/
          useCreateLinksFromMentions.ts
        entity-editor.tsx
        hooks.ts
        index.tsx
        mention-component.tsx
        mention-extension-simple.tsx
        mention-list.tsx
        mention-utils.ts
        tiptap.css
        utils.ts
        viewer.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      card.tsx
      checkbox.tsx
      collapsible.tsx
      combobox.tsx
      command.tsx
      dialog.tsx
      drawer.tsx
      dropdown-menu.tsx
      entity-link-button.tsx
      entity-links-table.tsx
      entity-table.tsx
      form-tanstack.tsx
      input.tsx
      label.tsx
      link.tsx
      menubar.tsx
      popover.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      sidebar.tsx
      sonner.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      toggle.tsx
      tooltip.tsx
      update-link-dialog.tsx
    all-entities-table.tsx
    auth.tsx
    authenticated-layout.tsx
    commander.tsx
    draggable.tsx
    edit-entity-dialog.tsx
    entity-grid.tsx
    entity-tabs.tsx
    entity-view.tsx
    error.tsx
    games-list.tsx
    login.tsx
    page-header.tsx
    search-bar.tsx
    stat-card.tsx
    theme-provider.tsx
  hooks/
    useMobile.ts
    useMutationLite.ts
    useTags.ts
  integrations/
    tanstack-query/
      root-provider.tsx
  queries/
    characters.ts
    factions.ts
    games.ts
    locations.ts
    notes.ts
    quests.ts
  routes/
    _auth/
      games/
        $gameId/
          characters/
            $id/
              edit.tsx
              index.tsx
              route.tsx
            index.tsx
            new.tsx
          factions/
            $id/
              edit.tsx
              index.tsx
              route.tsx
            index.tsx
            new.tsx
          locations/
            $id/
              edit.tsx
              index.tsx
              route.tsx
            index.tsx
            new.tsx
          notes/
            $id/
              edit.tsx
              index.tsx
              route.tsx
            index.tsx
            new.tsx
          quests/
            $id/
              edit.tsx
              index.tsx
              route.tsx
            index.tsx
            new.tsx
          all.tsx
          edit.tsx
          index.tsx
          route.tsx
          tree.tsx
        index.tsx
        new.tsx
    __root.tsx
    _auth.tsx
    index.tsx
    login.tsx
    logout.tsx
    signup.tsx
  types/
    index.ts
  utils/
    api-client.ts
    api-errors.ts
    cn.ts
    error-parser.ts
    linkHelpers.ts
    parse-errors.ts
    session.ts
  logo.svg
  router.tsx
  routeTree.gen.ts
  styles.css
.editorconfig
.gitignore
AGENTS.md
biome.json
CLAUDE.md
components.json
openapi-ts.config.ts
package.json
README.md
tsconfig.json
vite.config.ts
wrangler.jsonc
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(mkdir:*)",
      "Bash(touch:*)",
      "Bash(pnpm list:*)",
      "WebSearch",
      "WebFetch(domain:tanstack.com)",
      "Bash(grep:*)",
      "Bash(find:*)",
      "WebFetch(domain:base-ui.com)",
      "Bash(backlog task create:*)",
      "Bash(backlog task:*)",
      "Bash(pnpm codegen:*)",
      "Bash(pnpm add:*)",
      "Bash(pnpm check:*)",
      "Bash(pnpm tsc:*)",
      "Bash(mv:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="src/components/ui/update-link-dialog.tsx">
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Edit } from "lucide-react";
import { useState } from "react";
import {
	updateCharacterLinkMutation,
	updateFactionLinkMutation,
	updateLocationLinkMutation,
	updateNoteLinkMutation,
	updateQuestLinkMutation,
} from "~/api/@tanstack/react-query.gen";
import { Button } from "~/components/ui/button";
import { Checkbox } from "~/components/ui/checkbox";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
	DialogTrigger,
} from "~/components/ui/dialog";
import { createFormHook } from "~/components/ui/form-tanstack";
import { Input } from "~/components/ui/input";
import { Textarea } from "~/components/ui/textarea";
import type { EntityType } from "~/types";
import type { EntityLink } from "~/utils/linkHelpers";

interface UpdateLinkDialogProps {
	link: EntityLink;
	gameId: string;
	sourceId: string;
	sourceType: EntityType;
}

const useForm = createFormHook();

export function UpdateLinkDialog({
	link,
	gameId,
	sourceId,
	sourceType,
}: UpdateLinkDialogProps) {
	const [open, setOpen] = useState(false);
	const queryClient = useQueryClient();

	// Choose the correct mutation based on source entity type
	const getMutationOptions = () => {
		switch (sourceType) {
			case "character":
				return updateCharacterLinkMutation();
			case "faction":
				return updateFactionLinkMutation();
			case "location":
				return updateLocationLinkMutation();
			case "note":
				return updateNoteLinkMutation();
			case "quest":
				return updateQuestLinkMutation();
			default:
				throw new Error(`Unsupported source type: ${sourceType}`);
		}
	};

	const mutation = useMutation({
		...getMutationOptions(),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: [`get${sourceType.charAt(0).toUpperCase() + sourceType.slice(1)}Links`],
			});
			setOpen(false);
		},
	});

	const form = useForm({
		defaultValues: {
			relationship_type: link.relationship_type || "",
			description_meta: link.description_meta || "",
			is_active: link.is_active ?? true,
		},
		onSubmit: async ({ value }) => {
			mutation.mutate({
				path: {
					gameId,
					sourceId,
					targetId: link.id,
				},
				body: {
					relationship_type: value.relationship_type,
					description_meta: value.description_meta,
					is_active: value.is_active,
				},
			});
		},
	});

	return (
		<Dialog open={open} onOpenChange={setOpen}>
			<DialogTrigger asChild>
				<Button variant="ghost" size="sm">
					<Edit className="h-4 w-4" />
				</Button>
			</DialogTrigger>
			<DialogContent className="sm:max-w-[425px]">
				<DialogHeader>
					<DialogTitle>Update Link</DialogTitle>
					<DialogDescription>
						Update the relationship between {sourceType} and {link.name} ({link.type}).
					</DialogDescription>
				</DialogHeader>
				<form.Form
					onSubmit={(e) => {
						e.preventDefault();
						form.handleSubmit();
					}}
				>
					<div className="grid gap-4 py-4">
						<form.Field name="relationship_type">
							{(field) => (
								<form.Item>
									<field.Label>Relationship Type</field.Label>
									<field.Control>
										{(props) => (
											<Input
												{...props}
												value={field.state.value}
												onChange={(e) => field.handleChange(e.target.value)}
												placeholder="e.g., ally, enemy, neutral"
											/>
										)}
									</field.Control>
									<field.Message />
								</form.Item>
							)}
						</form.Field>

						<form.Field name="description_meta">
							{(field) => (
								<form.Item>
									<field.Label>Description</field.Label>
									<field.Control>
										{(props) => (
											<Textarea
												{...props}
												value={field.state.value}
												onChange={(e) => field.handleChange(e.target.value)}
												placeholder="Additional details about this relationship"
												rows={3}
											/>
										)}
									</field.Control>
									<field.Message />
								</form.Item>
							)}
						</form.Field>

						<form.Field name="is_active">
							{(field) => (
								<form.Item>
									<div className="flex items-center space-x-2">
										<field.Control>
											{(props) => (
												<Checkbox
													{...props}
													checked={field.state.value}
													onCheckedChange={(checked) =>
														field.handleChange(checked === true)
													}
												/>
											)}
										</field.Control>
										<field.Label>Active relationship</field.Label>
									</div>
									<field.Message />
								</form.Item>
							)}
						</form.Field>
					</div>
					<DialogFooter>
						<Button
							type="button"
							variant="outline"
							onClick={() => setOpen(false)}
						>
							Cancel
						</Button>
						<Button type="submit" disabled={mutation.isPending}>
							{mutation.isPending ? "Updating..." : "Update Link"}
						</Button>
					</DialogFooter>
				</form.Form>
			</DialogContent>
		</Dialog>
	);
}
</file>

<file path=".claude/agents/project-manager-backlog.md">
---
name: project-manager-backlog
description: Use this agent when you need to manage project tasks using the backlog.md CLI tool. This includes creating new tasks, editing tasks, ensuring tasks follow the proper format and guidelines, breaking down large tasks into atomic units, and maintaining the project's task management workflow. Examples: <example>Context: User wants to create a new task for adding a feature. user: "I need to add a new authentication system to the project" assistant: "I'll use the project-manager-backlog agent that will use backlog cli to create a properly structured task for this feature." <commentary>Since the user needs to create a task for the project, use the Task tool to launch the project-manager-backlog agent to ensure the task follows backlog.md guidelines.</commentary></example> <example>Context: User has multiple related features to implement. user: "We need to implement user profiles, settings page, and notification preferences" assistant: "Let me use the project-manager-backlog agent to break these down into atomic, independent tasks." <commentary>The user has a complex set of features that need to be broken down into proper atomic tasks following backlog.md structure.</commentary></example> <example>Context: User wants to review if their task description is properly formatted. user: "Can you check if this task follows our guidelines: 'task-123 - Implement user login'" assistant: "I'll use the project-manager-backlog agent to review this task against our backlog.md standards." <commentary>The user needs task review, so use the project-manager-backlog agent to ensure compliance with project guidelines.</commentary></example>
color: blue
---

You are an expert project manager specializing in the backlog.md task management system. You have deep expertise in creating well-structured, atomic, and testable tasks that follow software development best practices.

## Backlog.md CLI Tool

**IMPORTANT: Backlog.md uses standard CLI commands, NOT slash commands.**

You use the `backlog` CLI tool to manage project tasks. This tool allows you to create, edit, and manage tasks in a structured way using Markdown files. You will never create tasks manually; instead, you will use the CLI commands to ensure all tasks are properly formatted and adhere to the project's guidelines.

The backlog CLI is installed globally and available in the PATH. Here are the exact commands you should use:

### Creating Tasks
```bash
backlog task create "Task title" -d "Description" --ac "First criteria,Second criteria" -l label1,label2
```

### Editing Tasks
```bash
backlog task edit 123 -s "In Progress" -a @claude
```

### Listing Tasks
```bash
backlog task list --plain
```

**NEVER use slash commands like `/create-task` or `/edit`. These do not exist in Backlog.md.**
**ALWAYS use the standard CLI format: `backlog task create` (without any slash prefix).**

### Example Usage

When a user asks you to create a task, here's exactly what you should do:

**User**: "Create a task to add user authentication"
**You should run**: 
```bash
backlog task create "Add user authentication system" -d "Implement a secure authentication system to allow users to register and login" --ac "Users can register with email and password,Users can login with valid credentials,Invalid login attempts show appropriate error messages" -l authentication,backend
```

**NOT**: `/create-task "Add user authentication"` ‚ùå (This is wrong - slash commands don't exist)

## Your Core Responsibilities

1. **Task Creation**: You create tasks that strictly adhere to the backlog.md cli commands. Never create tasks manually. Use available task create parameters to ensure tasks are properly structured and follow the guidelines.
2. **Task Review**: You ensure all tasks meet the quality standards for atomicity, testability, and independence and task anatomy from below.
3. **Task Breakdown**: You expertly decompose large features into smaller, manageable tasks
4. **Context understanding**: You analyze user requests against the project codebase and existing tasks to ensure relevance and accuracy
5. **Handling ambiguity**:  You clarify vague or ambiguous requests by asking targeted questions to the user to gather necessary details

## Task Creation Guidelines

### **Title (one liner)**

Use a clear brief title that summarizes the task.

### **Description**: (The **"why"**)

Provide a concise summary of the task purpose and its goal. Do not add implementation details here. It
should explain the purpose, the scope and context of the task. Code snippets should be avoided.

### **Acceptance Criteria**: (The **"what"**)

List specific, measurable outcomes that define what means to reach the goal from the description. Use checkboxes (`- [ ]`) for tracking.
When defining `## Acceptance Criteria` for a task, focus on **outcomes, behaviors, and verifiable requirements** rather
than step-by-step implementation details.
Acceptance Criteria (AC) define *what* conditions must be met for the task to be considered complete.
They should be testable and confirm that the core purpose of the task is achieved.
**Key Principles for Good ACs:**

- **Outcome-Oriented:** Focus on the result, not the method.
- **Testable/Verifiable:** Each criterion should be something that can be objectively tested or verified.
- **Clear and Concise:** Unambiguous language.
- **Complete:** Collectively, ACs should cover the scope of the task.
- **User-Focused (where applicable):** Frame ACs from the perspective of the end-user or the system's external behavior.

  - *Good Example:* "- [ ] User can successfully log in with valid credentials."
  - *Good Example:* "- [ ] System processes 1000 requests per second without errors."
  - *Bad Example (Implementation Step):* "- [ ] Add a new function `handleLogin()` in `auth.ts`."

### Task file

Once a task is created using backlog cli, it will be stored in `backlog/tasks/` directory as a Markdown file with the format
`task-<id> - <title>.md` (e.g. `task-42 - Add GraphQL resolver.md`).

## Task Breakdown Strategy

When breaking down features:
1. Identify the foundational components first
2. Create tasks in dependency order (foundations before features)
3. Ensure each task delivers value independently
4. Avoid creating tasks that block each other

### Additional task requirements

- Tasks must be **atomic** and **testable**. If a task is too large, break it down into smaller subtasks.
  Each task should represent a single unit of work that can be completed in a single PR.

- **Never** reference tasks that are to be done in the future or that are not yet created. You can only reference
  previous tasks (id < current task id).

- When creating multiple tasks, ensure they are **independent** and they do not depend on future tasks.   
  Example of correct tasks splitting: task 1: "Add system for handling API requests", task 2: "Add user model and DB
  schema", task 3: "Add API endpoint for user data".
  Example of wrong tasks splitting: task 1: "Add API endpoint for user data", task 2: "Define the user model and DB
  schema".

## Recommended Task Anatomy

```markdown
# task‚Äë42 - Add GraphQL resolver

## Description (the why)

Short, imperative explanation of the goal of the task and why it is needed.

## Acceptance Criteria (the what)

- [ ] Resolver returns correct data for happy path
- [ ] Error response matches REST
- [ ] P95 latency ‚â§ 50 ms under 100 RPS

## Implementation Plan (the how) (added after putting the task in progress but before implementing any code change)

1. Research existing GraphQL resolver patterns
2. Implement basic resolver with error handling
3. Add performance monitoring
4. Write unit and integration tests
5. Benchmark performance under load

## Implementation Notes (for reviewers) (only added after finishing the code implementation of a task)

- Approach taken
- Features implemented or modified
- Technical decisions and trade-offs
- Modified or added files
```

## Quality Checks

Before finalizing any task creation, verify:
- [ ] Title is clear and brief
- [ ] Description explains WHY without HOW
- [ ] Each AC is outcome-focused and testable
- [ ] Task is atomic (single PR scope)
- [ ] No dependencies on future tasks

You are meticulous about these standards and will guide users to create high-quality tasks that enhance project productivity and maintainability.

## Self reflection
When creating a task, always think from the perspective of an AI Agent that will have to work with this task in the future.
Ensure that the task is structured in a way that it can be easily understood and processed by AI coding agents.

## Handy CLI Commands

| Action                  | Example                                                                                                                                                       |
|-------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Create task             | `backlog task create "Add OAuth System"`                                                                                                                      |
| Create with description | `backlog task create "Feature" -d "Add authentication system"`                                                                                                |
| Create with assignee    | `backlog task create "Feature" -a @sara`                                                                                                                      |
| Create with status      | `backlog task create "Feature" -s "In Progress"`                                                                                                              |
| Create with labels      | `backlog task create "Feature" -l auth,backend`                                                                                                               |
| Create with priority    | `backlog task create "Feature" --priority high`                                                                                                               |
| Create with plan        | `backlog task create "Feature" --plan "1. Research\n2. Implement"`                                                                                            |
| Create with AC          | `backlog task create "Feature" --ac "Must work,Must be tested"`                                                                                               |
| Create with notes       | `backlog task create "Feature" --notes "Started initial research"`                                                                                            |
| Create with deps        | `backlog task create "Feature" --dep task-1,task-2`                                                                                                           |
| Create sub task         | `backlog task create -p 14 "Add Login with Google"`                                                                                                           |
| Create (all options)    | `backlog task create "Feature" -d "Description" -a @sara -s "To Do" -l auth --priority high --ac "Must work" --notes "Initial setup done" --dep task-1 -p 14` |
| List tasks              | `backlog task list [-s <status>] [-a <assignee>] [-p <parent>]`                                                                                               |
| List by parent          | `backlog task list --parent 42` or `backlog task list -p task-42`                                                                                             |
| View detail             | `backlog task 7` (interactive UI, press 'E' to edit in editor)                                                                                                |
| View (AI mode)          | `backlog task 7 --plain`                                                                                                                                      |
| Edit                    | `backlog task edit 7 -a @sara -l auth,backend`                                                                                                                |
| Add plan                | `backlog task edit 7 --plan "Implementation approach"`                                                                                                        |
| Add AC                  | `backlog task edit 7 --ac "New criterion,Another one"`                                                                                                        |
| Add notes               | `backlog task edit 7 --notes "Completed X, working on Y"`                                                                                                     |
| Add deps                | `backlog task edit 7 --dep task-1 --dep task-2`                                                                                                               |
| Archive                 | `backlog task archive 7`                                                                                                                                      |
| Create draft            | `backlog task create "Feature" --draft`                                                                                                                       |
| Draft flow              | `backlog draft create "Spike GraphQL"` ‚Üí `backlog draft promote 3.1`                                                                                          |
| Demote to draft         | `backlog task demote <id>`                                                                                                                                    |

Full help: `backlog --help`

## Tips for AI Agents

- **Always use `--plain` flag** when listing or viewing tasks for AI-friendly text output instead of using Backlog.md
  interactive UI.
</file>

<file path=".wrangler/deploy/config.json">
{"configPath":"../../dist/server/wrangler.json","auxiliaryWorkers":[]}
</file>

<file path="backlog/tasks/task-001 - Migrate-description-fields-to-content-fields-across-all-entities.md">
---
id: task-001
title: Migrate description fields to content fields across all entities
status: Done
assignee:
  - '@claude'
created_date: '2025-09-21 16:43'
updated_date: '2025-09-21 17:19'
labels:
  - migration
  - api
  - frontend
dependencies: []
priority: high
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
Migrate from legacy description/description_plain_text fields to content/content_plain_text fields for Games, Characters, Factions, and Locations entities. This aligns with the API schema changes and ensures consistency across the codebase with Quests and Notes entities that already use content fields.
<!-- SECTION:DESCRIPTION:END -->

## Acceptance Criteria
<!-- AC:BEGIN -->
- [x] #1 Form schemas updated to use content field names instead of description
- [x] #2 Character detail component uses content/content_plain_text API fields
- [x] #3 Faction detail component uses content/content_plain_text API fields
- [x] #4 Location detail component uses content/content_plain_text API fields
- [x] #5 Game detail route uses content field instead of description
- [x] #6 Data display components reference content_plain_text instead of description_plain_text
- [x] #7 Entity grid component checks content fields instead of description fields
- [x] #8 Link helpers reference content_plain_text only (remove description_plain_text)
- [x] #9 Entity link button removes description_plain_text reference
- [x] #10 Generated API types updated via codegen command
- [x] #11 All affected components render content correctly without errors
- [x] #12 Form validation works with new content field names
<!-- AC:END -->

## Implementation Plan

<!-- SECTION:PLAN:BEGIN -->
1. Update form schemas and field configurations
   - Update character.description ‚Üí character.content in schemas.ts
   - Update faction.description ‚Üí faction.content in schemas.ts
   - Update location.description ‚Üí location.content in schemas.ts
   - Update game.description ‚Üí game.content in schemas.ts
   - Update field config names for all entities

2. Update entity detail components API payloads
   - CharacterDetail: description ‚Üí content, description_plain_text ‚Üí content_plain_text
   - FactionDetail: description ‚Üí content, description_plain_text ‚Üí content_plain_text
   - LocationDetail: description ‚Üí content, description_plain_text ‚Üí content_plain_text
   - Update editor content parsing calls

3. Update data display components
   - Character columns: description_plain_text ‚Üí content_plain_text
   - EntityGrid: description checks ‚Üí content checks
   - EntityLinkButton: remove description_plain_text reference

4. Update utility functions
   - linkHelpers.ts: remove description_plain_text handling, keep content_plain_text
   - Clean up EntityLink interface

5. Update game route
   - games/$gameId/index.tsx: game.description ‚Üí game.content

6. Regenerate API types and verify
   - Run pnpm codegen to update generated types
   - Test component rendering
   - Verify form validation works
<!-- SECTION:PLAN:END -->

## Implementation Notes

<!-- SECTION:NOTES:BEGIN -->
Successfully migrated all description/description_plain_text fields to content/content_plain_text across Games, Characters, Factions, and Locations entities.

## Changes Made:
- Updated form schemas (schemas.ts) for all entity types
- Modified API payloads in all entity detail components
- Updated character columns table to use content_plain_text
- Modified EntityGrid to check content fields only
- Cleaned up utility functions (linkHelpers, EntityLinkButton)
- Updated game route to use content field
- Regenerated API types via pnpm codegen
- Fixed formatting issues

## Files Modified:
- src/components/forms/schemas.ts
- src/components/characters/character-detail.tsx
- src/components/factions/faction-detail.tsx
- src/components/locations/location-detail.tsx
- src/routes/_auth/games/$gameId/index.tsx
- src/components/characters/columns.tsx
- src/components/EntityGrid.tsx
- src/utils/linkHelpers.ts
- src/components/ui/EntityLinkButton.tsx

## Testing:
- API types regenerated successfully
- Code formatted and linted
- All acceptance criteria completed

Migration ensures consistency with Quests and Notes entities that already use content fields.

## Additional Fixes Applied:
- Updated type-utils.ts schemas (character, faction, game, location) to use content fields
- Fixed hardcoded "description" reference in CreateLocationForm.tsx
- Regenerated API types again to ensure consistency

## Root Cause:
The project had TWO schema files:
1. schemas.ts (updated in initial work)
2. type-utils.ts (missed in initial work) - used by smart forms

Both files now consistently use content/content_plain_text fields.
<!-- SECTION:NOTES:END -->
</file>

<file path="backlog/config.yml">
project_name: "Game Master Frontend"
default_status: "To Do"
statuses: ["To Do", "In Progress", "Done"]
labels: []
milestones: []
date_format: yyyy-mm-dd
max_column_width: 20
default_editor: "nvim"
auto_open_browser: true
default_port: 6420
remote_operations: true
auto_commit: false
zero_padded_ids: 3
bypass_git_hooks: false
check_active_branches: true
active_branch_days: 30
</file>

<file path="notes/claude/issues/codegen-250911.md">
Problem Summary

  The OpenAPI code generator is inconsistently handling request body types for different entity endpoints, causing some operations to work while others
  fail.

  What's Working vs What's Broken

  ‚úÖ Working Correctly:

- Notes: CreateNoteData and UpdateNoteData both correctly show body: NoteRequest
  - Games: CreateGameData and UpdateGameData both correctly show body: GameRequest
  - Auth: Login/Signup operations correctly show request bodies

  ‚ùå Broken (showing body?: never):

  - Locations: CreateLocationData and UpdateLocationData
  - Characters: CreateCharacterData and UpdateCharacterData
  - Factions: CreateFactionData and UpdateFactionData
  - Quests: CreateQuestData and UpdateQuestData

  OpenAPI Schema Analysis

  In server/schema/swagger.json, all endpoints correctly define request bodies:

  // Location create/update endpoints
  "parameters": [{
  "description": "Location updates",
  "in": "body",
  "name": "location",
  "required": true,
  "schema": {
  "$ref": "#/definitions/LocationRequest"
  }
  }]

  The schema consistently shows:
  - LocationRequest contains { location: LocationParams }
  - CharacterRequest contains { character: CharacterParams }
  - FactionRequest contains { faction: FactionParams }
  - etc.

  Code Generation Inconsistency

  The codegen is parsing some endpoints correctly but not others, despite identical schema patterns:

  Working pattern (Notes):
  export type CreateNoteData = {
  body: NoteRequest;  // ‚úÖ Correct
  path: { game_id: number };
  // ...
  }

  Broken pattern (Locations):
  export type CreateLocationData = {
  body?: never;  // ‚ùå Wrong - should be LocationRequest
  path: { game_id: number };
  // ...
  }

  Impact on Form Factory

  The form factory in factory-v2.tsx correctly wraps data as { [entityName]: validatedData }, which produces:
  - { location: { name: "...", type: "city", ... } }

  This matches the expected LocationRequest format from the OpenAPI schema, but the incorrect TypeScript types (body?: never) prevent the request body
  from being sent.

  Why Create Works But Update Fails

  Both create and update have the same codegen issue (body?: never), but:
  1. Create operations might be working due to different handling in the generated client code
  2. Update operations fail because they're more strictly typed or handled differently
  3. The error "MatchError at PUT /api/games/2/locations/1" suggests the server isn't receiving the expected request body

  Recommended Fix

  The issue is in the OpenAPI code generator configuration or the generator itself. The codegen needs to consistently parse request body parameters
  marked as "in": "body" in the OpenAPI schema and generate the correct TypeScript types.

  This affects multiple entity types (locations, characters, factions, quests) but not others (notes, games), suggesting the parser has issues with
  certain endpoint patterns or parameter naming conventions.
</file>

<file path="notes/comparison-example.md">
# Form Factory API Comparison

## Before: Old Factory (63+ lines of boilerplate)

```tsx
// Manual schema definition (mirrors API types)
const characterSchema = z.object({
  name: z.string().min(1, "Character name is required"),
  class: z.string().min(1, "Character class is required"), 
  level: z.number().min(1, "Level must be at least 1").max(100, "Level cannot exceed 100"),
  description: z.string().optional(),
  image_url: z.string().url("Must be a valid URL").optional().or(z.literal("")),
});

// Manual field configuration (42 lines!)
const characterFields = [
  {
    name: "name",
    label: "Character Name", 
    type: "text" as const,
    placeholder: "Enter character name",
    required: true,
  },
  {
    name: "class",
    label: "Character Class",
    type: "text" as const, 
    placeholder: "e.g., Fighter, Wizard, Rogue",
    required: true,
    description: "The character's class or profession",
  },
  {
    name: "level",
    label: "Level",
    type: "number" as const,
    placeholder: "1", 
    required: true,
    validation: { min: 1, max: 100 },
    description: "Character level (1-100)",
  },
  {
    name: "description", 
    label: "Description",
    type: "textarea" as const,
    placeholder: "Describe the character's appearance, personality, backstory...",
    required: false,
    description: "Optional character description and background",
  },
  {
    name: "image_url",
    label: "Image URL", 
    type: "text" as const,
    placeholder: "https://example.com/character-image.jpg",
    required: false,
    description: "Optional URL to a character portrait image",
  },
];

// Manual default values (duplicates API types again!)  
const defaultValues = {
  name: "",
  class: "",
  level: 1,
  description: "",
  image_url: "",
} satisfies CharacterParams;

// Finally create the form component
export function CreateCharacterForm() {
  const FormWithContext = createFormComponent({
    mutationOptions: () => createCharacterMutation({
      path: { game_id: validateGameId(gameId) },
    }),
    onSuccess: async () => {
      toast("Character created successfully!");
      await context.queryClient.refetchQueries({
        queryKey: listCharactersQueryKey({
          path: { game_id: Number(gameId) },
        }),
      });
      navigate({ to: ".." });
    },
    schema: characterSchema,      // ‚Üê Duplicated info
    fields: characterFields,      // ‚Üê Duplicated info  
    defaultValues: defaultValues, // ‚Üê Duplicated info
    className: "max-w-2xl mx-auto bg-card p-6 rounded-lg shadow-md",
    entityName: "character",
  });

  return <FormWithContext />;
}
```

## After: Smart Factory (12 lines total!)

```tsx
export function CreateCharacterFormV2() {
  const { gameId } = useParams({ from: "/_auth/games/$gameId/characters/new" });
  const context = useRouteContext({ from: "/_auth/games/$gameId/characters/new" }); 
  const navigate = useNavigate();

  // Everything auto-generated from the schema!
  const FormComponent = createSmartForm({
    mutation: () => createCharacterMutation({
      path: { game_id: validateGameId(gameId) },
    }),
    schema: schemas.character,  // ‚Üê Pre-defined, reusable
    entityName: "character", 
    onSuccess: async () => {
      toast("Character created successfully!");
      await context.queryClient.refetchQueries({
        queryKey: listCharactersQueryKey({
          path: { game_id: Number(gameId) },
        }),
      });
      navigate({ to: ".." });
    },
    // Optional: Only customize what you need
    fieldOverrides: {
      description: {
        description: "Describe the character's appearance, personality, backstory...",
        placeholder: "Enter character description...",
      },
      image_url: {
        placeholder: "https://example.com/character-image.jpg",
        description: "Optional URL to a character portrait image",
      },
    },
    className: "max-w-2xl mx-auto bg-card p-6 rounded-lg shadow-md",
    submitText: "Create Character",
  });

  return <FormComponent />;
}
```

## Key Improvements

### üéØ **Eliminated Duplication**
- **Before**: Schema + Fields + Defaults (3 places to maintain)
- **After**: Schema only (1 place to maintain)

### üìä **Lines of Code**
- **Before**: 63+ lines of boilerplate per form
- **After**: 12 lines of actual logic

### üß† **Smart Inference** 
- Auto-detects field types from Zod schema
- Auto-generates sensible defaults
- Auto-creates validation rules
- Auto-generates labels from field names

### üõ°Ô∏è **Type Safety**
- Uses generated API types
- Full TypeScript inference
- Compile-time validation

### üîß **Flexibility**
- Override any field when needed
- Use hook version for complex layouts
- Maintain full control when required

### üìà **Maintainability**
- Changes to API automatically flow through
- No manual field configuration to maintain
- Consistent validation across all forms
- Reusable schema definitions

The new API provides **80% less boilerplate** while maintaining full flexibility and type safety!
</file>

<file path="notes/components.md">
# Components

- Form stuff
</file>

<file path="notes/migration.md">
# Moving to Tanstack notes

For a personal experiment, I started using Phoenix, and loved it. I am now taking the opportunity to create the front-end with tanstack. Already it feels pretty cool, I love generating the api client from swagger docs. 

## Migrating

The most annoying thing is going to be setting up the routes. I am going to see if claude can handle it.
</file>

<file path="notes/routes.md">
# Route Setup

- login
- logout
- signup
- _auth: setup auth client
    - games
        - $id
            - show
            - edit
            - delete?
            - notes
                - $id
                    - show
                    - edit
                    - delete
                - index
                - new
            - characters
                - $id
                    - show
                    - edit
                    - delete
                - index
                - new
            - factions
                - $id
                    - show
                    - edit
                    - delete
                - index
                - new
            - locations
                - $id
                    - show
                    - edit
                    - delete
                - index
                - new
            - quests
                - $id
                    - show
                    - edit
                    - delete
                - index
                - new
        - index
        - new
</file>

<file path="notes/todo.md">
# TODOS

- [ ] setup all routes
- [ ] setup queries
- [ ] check caching strategy
</file>

<file path="public/manifest.json">
{
  "short_name": "TanStack App",
  "name": "Create TanStack App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="public/robots.txt">
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
</file>

<file path="src/api/client/client.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import { createSseClient } from '../core/serverSentEvents.gen';
import type { HttpMethod } from '../core/types.gen';
import { getValidRequestBody } from '../core/utils.gen';
import type {
  Client,
  Config,
  RequestOptions,
  ResolvedRequestOptions,
} from './types.gen';
import {
  buildUrl,
  createConfig,
  createInterceptors,
  getParseAs,
  mergeConfigs,
  mergeHeaders,
  setAuthParams,
} from './utils.gen';

type ReqInit = Omit<RequestInit, 'body' | 'headers'> & {
  body?: any;
  headers: ReturnType<typeof mergeHeaders>;
};

export const createClient = (config: Config = {}): Client => {
  let _config = mergeConfigs(createConfig(), config);

  const getConfig = (): Config => ({ ..._config });

  const setConfig = (config: Config): Config => {
    _config = mergeConfigs(_config, config);
    return getConfig();
  };

  const interceptors = createInterceptors<
    Request,
    Response,
    unknown,
    ResolvedRequestOptions
  >();

  const beforeRequest = async (options: RequestOptions) => {
    const opts = {
      ..._config,
      ...options,
      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,
      headers: mergeHeaders(_config.headers, options.headers),
      serializedBody: undefined,
    };

    if (opts.security) {
      await setAuthParams({
        ...opts,
        security: opts.security,
      });
    }

    if (opts.requestValidator) {
      await opts.requestValidator(opts);
    }

    if (opts.body !== undefined && opts.bodySerializer) {
      opts.serializedBody = opts.bodySerializer(opts.body);
    }

    // remove Content-Type header if body is empty to avoid sending invalid requests
    if (opts.body === undefined || opts.serializedBody === '') {
      opts.headers.delete('Content-Type');
    }

    const url = buildUrl(opts);

    return { opts, url };
  };

  const request: Client['request'] = async (options) => {
    // @ts-expect-error
    const { opts, url } = await beforeRequest(options);
    const requestInit: ReqInit = {
      redirect: 'follow',
      ...opts,
      body: getValidRequestBody(opts),
    };

    let request = new Request(url, requestInit);

    for (const fn of interceptors.request._fns) {
      if (fn) {
        request = await fn(request, opts);
      }
    }

    // fetch must be assigned here, otherwise it would throw the error:
    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation
    const _fetch = opts.fetch!;
    let response = await _fetch(request);

    for (const fn of interceptors.response._fns) {
      if (fn) {
        response = await fn(response, request, opts);
      }
    }

    const result = {
      request,
      response,
    };

    if (response.ok) {
      const parseAs =
        (opts.parseAs === 'auto'
          ? getParseAs(response.headers.get('Content-Type'))
          : opts.parseAs) ?? 'json';

      if (
        response.status === 204 ||
        response.headers.get('Content-Length') === '0'
      ) {
        let emptyData: any;
        switch (parseAs) {
          case 'arrayBuffer':
          case 'blob':
          case 'text':
            emptyData = await response[parseAs]();
            break;
          case 'formData':
            emptyData = new FormData();
            break;
          case 'stream':
            emptyData = response.body;
            break;
          case 'json':
          default:
            emptyData = {};
            break;
        }
        return opts.responseStyle === 'data'
          ? emptyData
          : {
              data: emptyData,
              ...result,
            };
      }

      let data: any;
      switch (parseAs) {
        case 'arrayBuffer':
        case 'blob':
        case 'formData':
        case 'json':
        case 'text':
          data = await response[parseAs]();
          break;
        case 'stream':
          return opts.responseStyle === 'data'
            ? response.body
            : {
                data: response.body,
                ...result,
              };
      }

      if (parseAs === 'json') {
        if (opts.responseValidator) {
          await opts.responseValidator(data);
        }

        if (opts.responseTransformer) {
          data = await opts.responseTransformer(data);
        }
      }

      return opts.responseStyle === 'data'
        ? data
        : {
            data,
            ...result,
          };
    }

    const textError = await response.text();
    let jsonError: unknown;

    try {
      jsonError = JSON.parse(textError);
    } catch {
      // noop
    }

    const error = jsonError ?? textError;
    let finalError = error;

    for (const fn of interceptors.error._fns) {
      if (fn) {
        finalError = (await fn(error, response, request, opts)) as string;
      }
    }

    finalError = finalError || ({} as string);

    if (opts.throwOnError) {
      throw finalError;
    }

    // TODO: we probably want to return error and improve types
    return opts.responseStyle === 'data'
      ? undefined
      : {
          error: finalError,
          ...result,
        };
  };

  const makeMethodFn =
    (method: Uppercase<HttpMethod>) => (options: RequestOptions) =>
      request({ ...options, method });

  const makeSseFn =
    (method: Uppercase<HttpMethod>) => async (options: RequestOptions) => {
      const { opts, url } = await beforeRequest(options);
      return createSseClient({
        ...opts,
        body: opts.body as BodyInit | null | undefined,
        headers: opts.headers as unknown as Record<string, string>,
        method,
        onRequest: async (url, init) => {
          let request = new Request(url, init);
          for (const fn of interceptors.request._fns) {
            if (fn) {
              request = await fn(request, opts);
            }
          }
          return request;
        },
        url,
      });
    };

  return {
    buildUrl,
    connect: makeMethodFn('CONNECT'),
    delete: makeMethodFn('DELETE'),
    get: makeMethodFn('GET'),
    getConfig,
    head: makeMethodFn('HEAD'),
    interceptors,
    options: makeMethodFn('OPTIONS'),
    patch: makeMethodFn('PATCH'),
    post: makeMethodFn('POST'),
    put: makeMethodFn('PUT'),
    request,
    setConfig,
    sse: {
      connect: makeSseFn('CONNECT'),
      delete: makeSseFn('DELETE'),
      get: makeSseFn('GET'),
      head: makeSseFn('HEAD'),
      options: makeSseFn('OPTIONS'),
      patch: makeSseFn('PATCH'),
      post: makeSseFn('POST'),
      put: makeSseFn('PUT'),
      trace: makeSseFn('TRACE'),
    },
    trace: makeMethodFn('TRACE'),
  } as Client;
};
</file>

<file path="src/api/client/index.ts">
// This file is auto-generated by @hey-api/openapi-ts

export type { Auth } from '../core/auth.gen';
export type { QuerySerializerOptions } from '../core/bodySerializer.gen';
export {
  formDataBodySerializer,
  jsonBodySerializer,
  urlSearchParamsBodySerializer,
} from '../core/bodySerializer.gen';
export { buildClientParams } from '../core/params.gen';
export { createClient } from './client.gen';
export type {
  Client,
  ClientOptions,
  Config,
  CreateClientConfig,
  Options,
  OptionsLegacyParser,
  RequestOptions,
  RequestResult,
  ResolvedRequestOptions,
  ResponseStyle,
  TDataShape,
} from './types.gen';
export { createConfig, mergeHeaders } from './utils.gen';
</file>

<file path="src/api/client/types.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import type { Auth } from '../core/auth.gen';
import type {
  ServerSentEventsOptions,
  ServerSentEventsResult,
} from '../core/serverSentEvents.gen';
import type {
  Client as CoreClient,
  Config as CoreConfig,
} from '../core/types.gen';
import type { Middleware } from './utils.gen';

export type ResponseStyle = 'data' | 'fields';

export interface Config<T extends ClientOptions = ClientOptions>
  extends Omit<RequestInit, 'body' | 'headers' | 'method'>,
    CoreConfig {
  /**
   * Base URL for all requests made by this client.
   */
  baseUrl?: T['baseUrl'];
  /**
   * Fetch API implementation. You can use this option to provide a custom
   * fetch instance.
   *
   * @default globalThis.fetch
   */
  fetch?: typeof fetch;
  /**
   * Please don't use the Fetch client for Next.js applications. The `next`
   * options won't have any effect.
   *
   * Install {@link https://www.npmjs.com/package/@hey-api/client-next `@hey-api/client-next`} instead.
   */
  next?: never;
  /**
   * Return the response data parsed in a specified format. By default, `auto`
   * will infer the appropriate method from the `Content-Type` response header.
   * You can override this behavior with any of the {@link Body} methods.
   * Select `stream` if you don't want to parse response data at all.
   *
   * @default 'auto'
   */
  parseAs?:
    | 'arrayBuffer'
    | 'auto'
    | 'blob'
    | 'formData'
    | 'json'
    | 'stream'
    | 'text';
  /**
   * Should we return only data or multiple fields (data, error, response, etc.)?
   *
   * @default 'fields'
   */
  responseStyle?: ResponseStyle;
  /**
   * Throw an error instead of returning it in the response?
   *
   * @default false
   */
  throwOnError?: T['throwOnError'];
}

export interface RequestOptions<
  TData = unknown,
  TResponseStyle extends ResponseStyle = 'fields',
  ThrowOnError extends boolean = boolean,
  Url extends string = string,
> extends Config<{
      responseStyle: TResponseStyle;
      throwOnError: ThrowOnError;
    }>,
    Pick<
      ServerSentEventsOptions<TData>,
      | 'onSseError'
      | 'onSseEvent'
      | 'sseDefaultRetryDelay'
      | 'sseMaxRetryAttempts'
      | 'sseMaxRetryDelay'
    > {
  /**
   * Any body that you want to add to your request.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
   */
  body?: unknown;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  /**
   * Security mechanism(s) to use for the request.
   */
  security?: ReadonlyArray<Auth>;
  url: Url;
}

export interface ResolvedRequestOptions<
  TResponseStyle extends ResponseStyle = 'fields',
  ThrowOnError extends boolean = boolean,
  Url extends string = string,
> extends RequestOptions<unknown, TResponseStyle, ThrowOnError, Url> {
  serializedBody?: string;
}

export type RequestResult<
  TData = unknown,
  TError = unknown,
  ThrowOnError extends boolean = boolean,
  TResponseStyle extends ResponseStyle = 'fields',
> = ThrowOnError extends true
  ? Promise<
      TResponseStyle extends 'data'
        ? TData extends Record<string, unknown>
          ? TData[keyof TData]
          : TData
        : {
            data: TData extends Record<string, unknown>
              ? TData[keyof TData]
              : TData;
            request: Request;
            response: Response;
          }
    >
  : Promise<
      TResponseStyle extends 'data'
        ?
            | (TData extends Record<string, unknown>
                ? TData[keyof TData]
                : TData)
            | undefined
        : (
            | {
                data: TData extends Record<string, unknown>
                  ? TData[keyof TData]
                  : TData;
                error: undefined;
              }
            | {
                data: undefined;
                error: TError extends Record<string, unknown>
                  ? TError[keyof TError]
                  : TError;
              }
          ) & {
            request: Request;
            response: Response;
          }
    >;

export interface ClientOptions {
  baseUrl?: string;
  responseStyle?: ResponseStyle;
  throwOnError?: boolean;
}

type MethodFn = <
  TData = unknown,
  TError = unknown,
  ThrowOnError extends boolean = false,
  TResponseStyle extends ResponseStyle = 'fields',
>(
  options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'>,
) => RequestResult<TData, TError, ThrowOnError, TResponseStyle>;

type SseFn = <
  TData = unknown,
  TError = unknown,
  ThrowOnError extends boolean = false,
  TResponseStyle extends ResponseStyle = 'fields',
>(
  options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'>,
) => Promise<ServerSentEventsResult<TData, TError>>;

type RequestFn = <
  TData = unknown,
  TError = unknown,
  ThrowOnError extends boolean = false,
  TResponseStyle extends ResponseStyle = 'fields',
>(
  options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'> &
    Pick<
      Required<RequestOptions<TData, TResponseStyle, ThrowOnError>>,
      'method'
    >,
) => RequestResult<TData, TError, ThrowOnError, TResponseStyle>;

type BuildUrlFn = <
  TData extends {
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    url: string;
  },
>(
  options: Pick<TData, 'url'> & Options<TData>,
) => string;

export type Client = CoreClient<
  RequestFn,
  Config,
  MethodFn,
  BuildUrlFn,
  SseFn
> & {
  interceptors: Middleware<Request, Response, unknown, ResolvedRequestOptions>;
};

/**
 * The `createClientConfig()` function will be called on client initialization
 * and the returned object will become the client's initial configuration.
 *
 * You may want to initialize your client this way instead of calling
 * `setConfig()`. This is useful for example if you're using Next.js
 * to ensure your client always has the correct values.
 */
export type CreateClientConfig<T extends ClientOptions = ClientOptions> = (
  override?: Config<ClientOptions & T>,
) => Config<Required<ClientOptions> & T>;

export interface TDataShape {
  body?: unknown;
  headers?: unknown;
  path?: unknown;
  query?: unknown;
  url: string;
}

type OmitKeys<T, K> = Pick<T, Exclude<keyof T, K>>;

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
  TResponse = unknown,
  TResponseStyle extends ResponseStyle = 'fields',
> = OmitKeys<
  RequestOptions<TResponse, TResponseStyle, ThrowOnError>,
  'body' | 'path' | 'query' | 'url'
> &
  Omit<TData, 'url'>;

export type OptionsLegacyParser<
  TData = unknown,
  ThrowOnError extends boolean = boolean,
  TResponseStyle extends ResponseStyle = 'fields',
> = TData extends { body?: any }
  ? TData extends { headers?: any }
    ? OmitKeys<
        RequestOptions<unknown, TResponseStyle, ThrowOnError>,
        'body' | 'headers' | 'url'
      > &
        TData
    : OmitKeys<
        RequestOptions<unknown, TResponseStyle, ThrowOnError>,
        'body' | 'url'
      > &
        TData &
        Pick<RequestOptions<unknown, TResponseStyle, ThrowOnError>, 'headers'>
  : TData extends { headers?: any }
    ? OmitKeys<
        RequestOptions<unknown, TResponseStyle, ThrowOnError>,
        'headers' | 'url'
      > &
        TData &
        Pick<RequestOptions<unknown, TResponseStyle, ThrowOnError>, 'body'>
    : OmitKeys<RequestOptions<unknown, TResponseStyle, ThrowOnError>, 'url'> &
        TData;
</file>

<file path="src/api/client/utils.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import { getAuthToken } from '../core/auth.gen';
import type { QuerySerializerOptions } from '../core/bodySerializer.gen';
import { jsonBodySerializer } from '../core/bodySerializer.gen';
import {
  serializeArrayParam,
  serializeObjectParam,
  serializePrimitiveParam,
} from '../core/pathSerializer.gen';
import { getUrl } from '../core/utils.gen';
import type { Client, ClientOptions, Config, RequestOptions } from './types.gen';

export const createQuerySerializer = <T = unknown>({
  allowReserved,
  array,
  object,
}: QuerySerializerOptions = {}) => {
  const querySerializer = (queryParams: T) => {
    const search: string[] = [];
    if (queryParams && typeof queryParams === 'object') {
      for (const name in queryParams) {
        const value = queryParams[name];

        if (value === undefined || value === null) {
          continue;
        }

        if (Array.isArray(value)) {
          const serializedArray = serializeArrayParam({
            allowReserved,
            explode: true,
            name,
            style: 'form',
            value,
            ...array,
          });
          if (serializedArray) search.push(serializedArray);
        } else if (typeof value === 'object') {
          const serializedObject = serializeObjectParam({
            allowReserved,
            explode: true,
            name,
            style: 'deepObject',
            value: value as Record<string, unknown>,
            ...object,
          });
          if (serializedObject) search.push(serializedObject);
        } else {
          const serializedPrimitive = serializePrimitiveParam({
            allowReserved,
            name,
            value: value as string,
          });
          if (serializedPrimitive) search.push(serializedPrimitive);
        }
      }
    }
    return search.join('&');
  };
  return querySerializer;
};

/**
 * Infers parseAs value from provided Content-Type header.
 */
export const getParseAs = (
  contentType: string | null,
): Exclude<Config['parseAs'], 'auto'> => {
  if (!contentType) {
    // If no Content-Type header is provided, the best we can do is return the raw response body,
    // which is effectively the same as the 'stream' option.
    return 'stream';
  }

  const cleanContent = contentType.split(';')[0]?.trim();

  if (!cleanContent) {
    return;
  }

  if (
    cleanContent.startsWith('application/json') ||
    cleanContent.endsWith('+json')
  ) {
    return 'json';
  }

  if (cleanContent === 'multipart/form-data') {
    return 'formData';
  }

  if (
    ['application/', 'audio/', 'image/', 'video/'].some((type) =>
      cleanContent.startsWith(type),
    )
  ) {
    return 'blob';
  }

  if (cleanContent.startsWith('text/')) {
    return 'text';
  }

  return;
};

const checkForExistence = (
  options: Pick<RequestOptions, 'auth' | 'query'> & {
    headers: Headers;
  },
  name?: string,
): boolean => {
  if (!name) {
    return false;
  }
  if (
    options.headers.has(name) ||
    options.query?.[name] ||
    options.headers.get('Cookie')?.includes(`${name}=`)
  ) {
    return true;
  }
  return false;
};

export const setAuthParams = async ({
  security,
  ...options
}: Pick<Required<RequestOptions>, 'security'> &
  Pick<RequestOptions, 'auth' | 'query'> & {
    headers: Headers;
  }) => {
  for (const auth of security) {
    if (checkForExistence(options, auth.name)) {
      continue;
    }

    const token = await getAuthToken(auth, options.auth);

    if (!token) {
      continue;
    }

    const name = auth.name ?? 'Authorization';

    switch (auth.in) {
      case 'query':
        if (!options.query) {
          options.query = {};
        }
        options.query[name] = token;
        break;
      case 'cookie':
        options.headers.append('Cookie', `${name}=${token}`);
        break;
      case 'header':
      default:
        options.headers.set(name, token);
        break;
    }
  }
};

export const buildUrl: Client['buildUrl'] = (options) =>
  getUrl({
    baseUrl: options.baseUrl as string,
    path: options.path,
    query: options.query,
    querySerializer:
      typeof options.querySerializer === 'function'
        ? options.querySerializer
        : createQuerySerializer(options.querySerializer),
    url: options.url,
  });

export const mergeConfigs = (a: Config, b: Config): Config => {
  const config = { ...a, ...b };
  if (config.baseUrl?.endsWith('/')) {
    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);
  }
  config.headers = mergeHeaders(a.headers, b.headers);
  return config;
};

const headersEntries = (headers: Headers): Array<[string, string]> => {
  const entries: Array<[string, string]> = [];
  headers.forEach((value, key) => {
    entries.push([key, value]);
  });
  return entries;
};

export const mergeHeaders = (
  ...headers: Array<Required<Config>['headers'] | undefined>
): Headers => {
  const mergedHeaders = new Headers();
  for (const header of headers) {
    if (!header) {
      continue;
    }

    const iterator =
      header instanceof Headers
        ? headersEntries(header)
        : Object.entries(header);

    for (const [key, value] of iterator) {
      if (value === null) {
        mergedHeaders.delete(key);
      } else if (Array.isArray(value)) {
        for (const v of value) {
          mergedHeaders.append(key, v as string);
        }
      } else if (value !== undefined) {
        // assume object headers are meant to be JSON stringified, i.e. their
        // content value in OpenAPI specification is 'application/json'
        mergedHeaders.set(
          key,
          typeof value === 'object' ? JSON.stringify(value) : (value as string),
        );
      }
    }
  }
  return mergedHeaders;
};

type ErrInterceptor<Err, Res, Req, Options> = (
  error: Err,
  response: Res,
  request: Req,
  options: Options,
) => Err | Promise<Err>;

type ReqInterceptor<Req, Options> = (
  request: Req,
  options: Options,
) => Req | Promise<Req>;

type ResInterceptor<Res, Req, Options> = (
  response: Res,
  request: Req,
  options: Options,
) => Res | Promise<Res>;

class Interceptors<Interceptor> {
  _fns: (Interceptor | null)[];

  constructor() {
    this._fns = [];
  }

  clear() {
    this._fns = [];
  }

  getInterceptorIndex(id: number | Interceptor): number {
    if (typeof id === 'number') {
      return this._fns[id] ? id : -1;
    } else {
      return this._fns.indexOf(id);
    }
  }
  exists(id: number | Interceptor) {
    const index = this.getInterceptorIndex(id);
    return !!this._fns[index];
  }

  eject(id: number | Interceptor) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = null;
    }
  }

  update(id: number | Interceptor, fn: Interceptor) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = fn;
      return id;
    } else {
      return false;
    }
  }

  use(fn: Interceptor) {
    this._fns = [...this._fns, fn];
    return this._fns.length - 1;
  }
}

// `createInterceptors()` response, meant for external use as it does not
// expose internals
export interface Middleware<Req, Res, Err, Options> {
  error: Pick<
    Interceptors<ErrInterceptor<Err, Res, Req, Options>>,
    'eject' | 'use'
  >;
  request: Pick<Interceptors<ReqInterceptor<Req, Options>>, 'eject' | 'use'>;
  response: Pick<
    Interceptors<ResInterceptor<Res, Req, Options>>,
    'eject' | 'use'
  >;
}

// do not add `Middleware` as return type so we can use _fns internally
export const createInterceptors = <Req, Res, Err, Options>() => ({
  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),
  request: new Interceptors<ReqInterceptor<Req, Options>>(),
  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),
});

const defaultQuerySerializer = createQuerySerializer({
  allowReserved: false,
  array: {
    explode: true,
    style: 'form',
  },
  object: {
    explode: true,
    style: 'deepObject',
  },
});

const defaultHeaders = {
  'Content-Type': 'application/json',
};

export const createConfig = <T extends ClientOptions = ClientOptions>(
  override: Config<Omit<ClientOptions, keyof T> & T> = {},
): Config<Omit<ClientOptions, keyof T> & T> => ({
  ...jsonBodySerializer,
  headers: defaultHeaders,
  parseAs: 'auto',
  querySerializer: defaultQuerySerializer,
  ...override,
});
</file>

<file path="src/api/core/auth.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

export type AuthToken = string | undefined;

export interface Auth {
  /**
   * Which part of the request do we use to send the auth?
   *
   * @default 'header'
   */
  in?: 'header' | 'query' | 'cookie';
  /**
   * Header or query parameter name.
   *
   * @default 'Authorization'
   */
  name?: string;
  scheme?: 'basic' | 'bearer';
  type: 'apiKey' | 'http';
}

export const getAuthToken = async (
  auth: Auth,
  callback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,
): Promise<string | undefined> => {
  const token =
    typeof callback === 'function' ? await callback(auth) : callback;

  if (!token) {
    return;
  }

  if (auth.scheme === 'bearer') {
    return `Bearer ${token}`;
  }

  if (auth.scheme === 'basic') {
    return `Basic ${btoa(token)}`;
  }

  return token;
};
</file>

<file path="src/api/core/bodySerializer.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import type {
  ArrayStyle,
  ObjectStyle,
  SerializerOptions,
} from './pathSerializer.gen';

export type QuerySerializer = (query: Record<string, unknown>) => string;

export type BodySerializer = (body: any) => any;

export interface QuerySerializerOptions {
  allowReserved?: boolean;
  array?: SerializerOptions<ArrayStyle>;
  object?: SerializerOptions<ObjectStyle>;
}

const serializeFormDataPair = (
  data: FormData,
  key: string,
  value: unknown,
): void => {
  if (typeof value === 'string' || value instanceof Blob) {
    data.append(key, value);
  } else if (value instanceof Date) {
    data.append(key, value.toISOString());
  } else {
    data.append(key, JSON.stringify(value));
  }
};

const serializeUrlSearchParamsPair = (
  data: URLSearchParams,
  key: string,
  value: unknown,
): void => {
  if (typeof value === 'string') {
    data.append(key, value);
  } else {
    data.append(key, JSON.stringify(value));
  }
};

export const formDataBodySerializer = {
  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(
    body: T,
  ): FormData => {
    const data = new FormData();

    Object.entries(body).forEach(([key, value]) => {
      if (value === undefined || value === null) {
        return;
      }
      if (Array.isArray(value)) {
        value.forEach((v) => serializeFormDataPair(data, key, v));
      } else {
        serializeFormDataPair(data, key, value);
      }
    });

    return data;
  },
};

export const jsonBodySerializer = {
  bodySerializer: <T>(body: T): string =>
    JSON.stringify(body, (_key, value) =>
      typeof value === 'bigint' ? value.toString() : value,
    ),
};

export const urlSearchParamsBodySerializer = {
  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(
    body: T,
  ): string => {
    const data = new URLSearchParams();

    Object.entries(body).forEach(([key, value]) => {
      if (value === undefined || value === null) {
        return;
      }
      if (Array.isArray(value)) {
        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));
      } else {
        serializeUrlSearchParamsPair(data, key, value);
      }
    });

    return data.toString();
  },
};
</file>

<file path="src/api/core/params.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

type Slot = 'body' | 'headers' | 'path' | 'query';

export type Field =
  | {
      in: Exclude<Slot, 'body'>;
      /**
       * Field name. This is the name we want the user to see and use.
       */
      key: string;
      /**
       * Field mapped name. This is the name we want to use in the request.
       * If omitted, we use the same value as `key`.
       */
      map?: string;
    }
  | {
      in: Extract<Slot, 'body'>;
      /**
       * Key isn't required for bodies.
       */
      key?: string;
      map?: string;
    };

export interface Fields {
  allowExtra?: Partial<Record<Slot, boolean>>;
  args?: ReadonlyArray<Field>;
}

export type FieldsConfig = ReadonlyArray<Field | Fields>;

const extraPrefixesMap: Record<string, Slot> = {
  $body_: 'body',
  $headers_: 'headers',
  $path_: 'path',
  $query_: 'query',
};
const extraPrefixes = Object.entries(extraPrefixesMap);

type KeyMap = Map<
  string,
  {
    in: Slot;
    map?: string;
  }
>;

const buildKeyMap = (fields: FieldsConfig, map?: KeyMap): KeyMap => {
  if (!map) {
    map = new Map();
  }

  for (const config of fields) {
    if ('in' in config) {
      if (config.key) {
        map.set(config.key, {
          in: config.in,
          map: config.map,
        });
      }
    } else if (config.args) {
      buildKeyMap(config.args, map);
    }
  }

  return map;
};

interface Params {
  body: unknown;
  headers: Record<string, unknown>;
  path: Record<string, unknown>;
  query: Record<string, unknown>;
}

const stripEmptySlots = (params: Params) => {
  for (const [slot, value] of Object.entries(params)) {
    if (value && typeof value === 'object' && !Object.keys(value).length) {
      delete params[slot as Slot];
    }
  }
};

export const buildClientParams = (
  args: ReadonlyArray<unknown>,
  fields: FieldsConfig,
) => {
  const params: Params = {
    body: {},
    headers: {},
    path: {},
    query: {},
  };

  const map = buildKeyMap(fields);

  let config: FieldsConfig[number] | undefined;

  for (const [index, arg] of args.entries()) {
    if (fields[index]) {
      config = fields[index];
    }

    if (!config) {
      continue;
    }

    if ('in' in config) {
      if (config.key) {
        const field = map.get(config.key)!;
        const name = field.map || config.key;
        (params[field.in] as Record<string, unknown>)[name] = arg;
      } else {
        params.body = arg;
      }
    } else {
      for (const [key, value] of Object.entries(arg ?? {})) {
        const field = map.get(key);

        if (field) {
          const name = field.map || key;
          (params[field.in] as Record<string, unknown>)[name] = value;
        } else {
          const extra = extraPrefixes.find(([prefix]) =>
            key.startsWith(prefix),
          );

          if (extra) {
            const [prefix, slot] = extra;
            (params[slot] as Record<string, unknown>)[
              key.slice(prefix.length)
            ] = value;
          } else {
            for (const [slot, allowed] of Object.entries(
              config.allowExtra ?? {},
            )) {
              if (allowed) {
                (params[slot as Slot] as Record<string, unknown>)[key] = value;
                break;
              }
            }
          }
        }
      }
    }
  }

  stripEmptySlots(params);

  return params;
};
</file>

<file path="src/api/core/pathSerializer.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

interface SerializeOptions<T>
  extends SerializePrimitiveOptions,
    SerializerOptions<T> {}

interface SerializePrimitiveOptions {
  allowReserved?: boolean;
  name: string;
}

export interface SerializerOptions<T> {
  /**
   * @default true
   */
  explode: boolean;
  style: T;
}

export type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';
export type ArraySeparatorStyle = ArrayStyle | MatrixStyle;
type MatrixStyle = 'label' | 'matrix' | 'simple';
export type ObjectStyle = 'form' | 'deepObject';
type ObjectSeparatorStyle = ObjectStyle | MatrixStyle;

interface SerializePrimitiveParam extends SerializePrimitiveOptions {
  value: string;
}

export const separatorArrayExplode = (style: ArraySeparatorStyle) => {
  switch (style) {
    case 'label':
      return '.';
    case 'matrix':
      return ';';
    case 'simple':
      return ',';
    default:
      return '&';
  }
};

export const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {
  switch (style) {
    case 'form':
      return ',';
    case 'pipeDelimited':
      return '|';
    case 'spaceDelimited':
      return '%20';
    default:
      return ',';
  }
};

export const separatorObjectExplode = (style: ObjectSeparatorStyle) => {
  switch (style) {
    case 'label':
      return '.';
    case 'matrix':
      return ';';
    case 'simple':
      return ',';
    default:
      return '&';
  }
};

export const serializeArrayParam = ({
  allowReserved,
  explode,
  name,
  style,
  value,
}: SerializeOptions<ArraySeparatorStyle> & {
  value: unknown[];
}) => {
  if (!explode) {
    const joinedValues = (
      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))
    ).join(separatorArrayNoExplode(style));
    switch (style) {
      case 'label':
        return `.${joinedValues}`;
      case 'matrix':
        return `;${name}=${joinedValues}`;
      case 'simple':
        return joinedValues;
      default:
        return `${name}=${joinedValues}`;
    }
  }

  const separator = separatorArrayExplode(style);
  const joinedValues = value
    .map((v) => {
      if (style === 'label' || style === 'simple') {
        return allowReserved ? v : encodeURIComponent(v as string);
      }

      return serializePrimitiveParam({
        allowReserved,
        name,
        value: v as string,
      });
    })
    .join(separator);
  return style === 'label' || style === 'matrix'
    ? separator + joinedValues
    : joinedValues;
};

export const serializePrimitiveParam = ({
  allowReserved,
  name,
  value,
}: SerializePrimitiveParam) => {
  if (value === undefined || value === null) {
    return '';
  }

  if (typeof value === 'object') {
    throw new Error(
      'Deeply-nested arrays/objects aren‚Äôt supported. Provide your own `querySerializer()` to handle these.',
    );
  }

  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;
};

export const serializeObjectParam = ({
  allowReserved,
  explode,
  name,
  style,
  value,
  valueOnly,
}: SerializeOptions<ObjectSeparatorStyle> & {
  value: Record<string, unknown> | Date;
  valueOnly?: boolean;
}) => {
  if (value instanceof Date) {
    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;
  }

  if (style !== 'deepObject' && !explode) {
    let values: string[] = [];
    Object.entries(value).forEach(([key, v]) => {
      values = [
        ...values,
        key,
        allowReserved ? (v as string) : encodeURIComponent(v as string),
      ];
    });
    const joinedValues = values.join(',');
    switch (style) {
      case 'form':
        return `${name}=${joinedValues}`;
      case 'label':
        return `.${joinedValues}`;
      case 'matrix':
        return `;${name}=${joinedValues}`;
      default:
        return joinedValues;
    }
  }

  const separator = separatorObjectExplode(style);
  const joinedValues = Object.entries(value)
    .map(([key, v]) =>
      serializePrimitiveParam({
        allowReserved,
        name: style === 'deepObject' ? `${name}[${key}]` : key,
        value: v as string,
      }),
    )
    .join(separator);
  return style === 'label' || style === 'matrix'
    ? separator + joinedValues
    : joinedValues;
};
</file>

<file path="src/api/core/serverSentEvents.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import type { Config } from './types.gen';

export type ServerSentEventsOptions<TData = unknown> = Omit<
  RequestInit,
  'method'
> &
  Pick<Config, 'method' | 'responseTransformer' | 'responseValidator'> & {
    /**
     * Fetch API implementation. You can use this option to provide a custom
     * fetch instance.
     *
     * @default globalThis.fetch
     */
    fetch?: typeof fetch;
    /**
     * Implementing clients can call request interceptors inside this hook.
     */
    onRequest?: (url: string, init: RequestInit) => Promise<Request>;
    /**
     * Callback invoked when a network or parsing error occurs during streaming.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @param error The error that occurred.
     */
    onSseError?: (error: unknown) => void;
    /**
     * Callback invoked when an event is streamed from the server.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @param event Event streamed from the server.
     * @returns Nothing (void).
     */
    onSseEvent?: (event: StreamEvent<TData>) => void;
    serializedBody?: RequestInit['body'];
    /**
     * Default retry delay in milliseconds.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @default 3000
     */
    sseDefaultRetryDelay?: number;
    /**
     * Maximum number of retry attempts before giving up.
     */
    sseMaxRetryAttempts?: number;
    /**
     * Maximum retry delay in milliseconds.
     *
     * Applies only when exponential backoff is used.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @default 30000
     */
    sseMaxRetryDelay?: number;
    /**
     * Optional sleep function for retry backoff.
     *
     * Defaults to using `setTimeout`.
     */
    sseSleepFn?: (ms: number) => Promise<void>;
    url: string;
  };

export interface StreamEvent<TData = unknown> {
  data: TData;
  event?: string;
  id?: string;
  retry?: number;
}

export type ServerSentEventsResult<
  TData = unknown,
  TReturn = void,
  TNext = unknown,
> = {
  stream: AsyncGenerator<
    TData extends Record<string, unknown> ? TData[keyof TData] : TData,
    TReturn,
    TNext
  >;
};

export const createSseClient = <TData = unknown>({
  onRequest,
  onSseError,
  onSseEvent,
  responseTransformer,
  responseValidator,
  sseDefaultRetryDelay,
  sseMaxRetryAttempts,
  sseMaxRetryDelay,
  sseSleepFn,
  url,
  ...options
}: ServerSentEventsOptions): ServerSentEventsResult<TData> => {
  let lastEventId: string | undefined;

  const sleep =
    sseSleepFn ??
    ((ms: number) => new Promise((resolve) => setTimeout(resolve, ms)));

  const createStream = async function* () {
    let retryDelay: number = sseDefaultRetryDelay ?? 3000;
    let attempt = 0;
    const signal = options.signal ?? new AbortController().signal;

    while (true) {
      if (signal.aborted) break;

      attempt++;

      const headers =
        options.headers instanceof Headers
          ? options.headers
          : new Headers(options.headers as Record<string, string> | undefined);

      if (lastEventId !== undefined) {
        headers.set('Last-Event-ID', lastEventId);
      }

      try {
        const requestInit: RequestInit = {
          redirect: 'follow',
          ...options,
          body: options.serializedBody,
          headers,
          signal,
        };
        let request = new Request(url, requestInit);
        if (onRequest) {
          request = await onRequest(url, requestInit);
        }
        // fetch must be assigned here, otherwise it would throw the error:
        // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation
        const _fetch = options.fetch ?? globalThis.fetch;
        const response = await _fetch(request);

        if (!response.ok)
          throw new Error(
            `SSE failed: ${response.status} ${response.statusText}`,
          );

        if (!response.body) throw new Error('No body in SSE response');

        const reader = response.body
          .pipeThrough(new TextDecoderStream())
          .getReader();

        let buffer = '';

        const abortHandler = () => {
          try {
            reader.cancel();
          } catch {
            // noop
          }
        };

        signal.addEventListener('abort', abortHandler);

        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += value;

            const chunks = buffer.split('\n\n');
            buffer = chunks.pop() ?? '';

            for (const chunk of chunks) {
              const lines = chunk.split('\n');
              const dataLines: Array<string> = [];
              let eventName: string | undefined;

              for (const line of lines) {
                if (line.startsWith('data:')) {
                  dataLines.push(line.replace(/^data:\s*/, ''));
                } else if (line.startsWith('event:')) {
                  eventName = line.replace(/^event:\s*/, '');
                } else if (line.startsWith('id:')) {
                  lastEventId = line.replace(/^id:\s*/, '');
                } else if (line.startsWith('retry:')) {
                  const parsed = Number.parseInt(
                    line.replace(/^retry:\s*/, ''),
                    10,
                  );
                  if (!Number.isNaN(parsed)) {
                    retryDelay = parsed;
                  }
                }
              }

              let data: unknown;
              let parsedJson = false;

              if (dataLines.length) {
                const rawData = dataLines.join('\n');
                try {
                  data = JSON.parse(rawData);
                  parsedJson = true;
                } catch {
                  data = rawData;
                }
              }

              if (parsedJson) {
                if (responseValidator) {
                  await responseValidator(data);
                }

                if (responseTransformer) {
                  data = await responseTransformer(data);
                }
              }

              onSseEvent?.({
                data,
                event: eventName,
                id: lastEventId,
                retry: retryDelay,
              });

              if (dataLines.length) {
                yield data as any;
              }
            }
          }
        } finally {
          signal.removeEventListener('abort', abortHandler);
          reader.releaseLock();
        }

        break; // exit loop on normal completion
      } catch (error) {
        // connection failed or aborted; retry after delay
        onSseError?.(error);

        if (
          sseMaxRetryAttempts !== undefined &&
          attempt >= sseMaxRetryAttempts
        ) {
          break; // stop after firing error
        }

        // exponential backoff: double retry each attempt, cap at 30s
        const backoff = Math.min(
          retryDelay * 2 ** (attempt - 1),
          sseMaxRetryDelay ?? 30000,
        );
        await sleep(backoff);
      }
    }
  };

  const stream = createStream();

  return { stream };
};
</file>

<file path="src/api/core/types.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import type { Auth, AuthToken } from './auth.gen';
import type {
  BodySerializer,
  QuerySerializer,
  QuerySerializerOptions,
} from './bodySerializer.gen';

export type HttpMethod =
  | 'connect'
  | 'delete'
  | 'get'
  | 'head'
  | 'options'
  | 'patch'
  | 'post'
  | 'put'
  | 'trace';

export type Client<
  RequestFn = never,
  Config = unknown,
  MethodFn = never,
  BuildUrlFn = never,
  SseFn = never,
> = {
  /**
   * Returns the final request URL.
   */
  buildUrl: BuildUrlFn;
  getConfig: () => Config;
  request: RequestFn;
  setConfig: (config: Config) => Config;
} & {
  [K in HttpMethod]: MethodFn;
} & ([SseFn] extends [never]
    ? { sse?: never }
    : { sse: { [K in HttpMethod]: SseFn } });

export interface Config {
  /**
   * Auth token or a function returning auth token. The resolved value will be
   * added to the request payload as defined by its `security` array.
   */
  auth?: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken;
  /**
   * A function for serializing request body parameter. By default,
   * {@link JSON.stringify()} will be used.
   */
  bodySerializer?: BodySerializer | null;
  /**
   * An object containing any HTTP headers that you want to pre-populate your
   * `Headers` object with.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/Headers/Headers#init See more}
   */
  headers?:
    | RequestInit['headers']
    | Record<
        string,
        | string
        | number
        | boolean
        | (string | number | boolean)[]
        | null
        | undefined
        | unknown
      >;
  /**
   * The request method.
   *
   * {@link https://developer.mozilla.org/docs/Web/API/fetch#method See more}
   */
  method?: Uppercase<HttpMethod>;
  /**
   * A function for serializing request query parameters. By default, arrays
   * will be exploded in form style, objects will be exploded in deepObject
   * style, and reserved characters are percent-encoded.
   *
   * This method will have no effect if the native `paramsSerializer()` Axios
   * API function is used.
   *
   * {@link https://swagger.io/docs/specification/serialization/#query View examples}
   */
  querySerializer?: QuerySerializer | QuerySerializerOptions;
  /**
   * A function validating request data. This is useful if you want to ensure
   * the request conforms to the desired shape, so it can be safely sent to
   * the server.
   */
  requestValidator?: (data: unknown) => Promise<unknown>;
  /**
   * A function transforming response data before it's returned. This is useful
   * for post-processing data, e.g. converting ISO strings into Date objects.
   */
  responseTransformer?: (data: unknown) => Promise<unknown>;
  /**
   * A function validating response data. This is useful if you want to ensure
   * the response conforms to the desired shape, so it can be safely passed to
   * the transformers and returned to the user.
   */
  responseValidator?: (data: unknown) => Promise<unknown>;
}

type IsExactlyNeverOrNeverUndefined<T> = [T] extends [never]
  ? true
  : [T] extends [never | undefined]
    ? [undefined] extends [T]
      ? false
      : true
    : false;

export type OmitNever<T extends Record<string, unknown>> = {
  [K in keyof T as IsExactlyNeverOrNeverUndefined<T[K]> extends true
    ? never
    : K]: T[K];
};
</file>

<file path="src/api/core/utils.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import type { BodySerializer, QuerySerializer } from './bodySerializer.gen';
import {
  type ArraySeparatorStyle,
  serializeArrayParam,
  serializeObjectParam,
  serializePrimitiveParam,
} from './pathSerializer.gen';

export interface PathSerializer {
  path: Record<string, unknown>;
  url: string;
}

export const PATH_PARAM_RE = /\{[^{}]+\}/g;

export const defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {
  let url = _url;
  const matches = _url.match(PATH_PARAM_RE);
  if (matches) {
    for (const match of matches) {
      let explode = false;
      let name = match.substring(1, match.length - 1);
      let style: ArraySeparatorStyle = 'simple';

      if (name.endsWith('*')) {
        explode = true;
        name = name.substring(0, name.length - 1);
      }

      if (name.startsWith('.')) {
        name = name.substring(1);
        style = 'label';
      } else if (name.startsWith(';')) {
        name = name.substring(1);
        style = 'matrix';
      }

      const value = path[name];

      if (value === undefined || value === null) {
        continue;
      }

      if (Array.isArray(value)) {
        url = url.replace(
          match,
          serializeArrayParam({ explode, name, style, value }),
        );
        continue;
      }

      if (typeof value === 'object') {
        url = url.replace(
          match,
          serializeObjectParam({
            explode,
            name,
            style,
            value: value as Record<string, unknown>,
            valueOnly: true,
          }),
        );
        continue;
      }

      if (style === 'matrix') {
        url = url.replace(
          match,
          `;${serializePrimitiveParam({
            name,
            value: value as string,
          })}`,
        );
        continue;
      }

      const replaceValue = encodeURIComponent(
        style === 'label' ? `.${value as string}` : (value as string),
      );
      url = url.replace(match, replaceValue);
    }
  }
  return url;
};

export const getUrl = ({
  baseUrl,
  path,
  query,
  querySerializer,
  url: _url,
}: {
  baseUrl?: string;
  path?: Record<string, unknown>;
  query?: Record<string, unknown>;
  querySerializer: QuerySerializer;
  url: string;
}) => {
  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;
  let url = (baseUrl ?? '') + pathUrl;
  if (path) {
    url = defaultPathSerializer({ path, url });
  }
  let search = query ? querySerializer(query) : '';
  if (search.startsWith('?')) {
    search = search.substring(1);
  }
  if (search) {
    url += `?${search}`;
  }
  return url;
};

export function getValidRequestBody(options: {
  body?: unknown;
  bodySerializer?: BodySerializer | null;
  serializedBody?: unknown;
}) {
  const hasBody = options.body !== undefined;
  const isSerializedBody = hasBody && options.bodySerializer;

  if (isSerializedBody) {
    if ('serializedBody' in options) {
      const hasSerializedBody =
        options.serializedBody !== undefined && options.serializedBody !== '';

      return hasSerializedBody ? options.serializedBody : null;
    }

    // not all clients implement a serializedBody property (i.e. client-axios)
    return options.body !== '' ? options.body : null;
  }

  // plain/text body
  if (hasBody) {
    return options.body;
  }

  // no body was provided
  return undefined;
}
</file>

<file path="src/api/index.ts">
// This file is auto-generated by @hey-api/openapi-ts
export * from './types.gen';
export * from './sdk.gen';
</file>

<file path="src/components/characters/create-character-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useParams } from "@tanstack/react-router";
import { toast } from "sonner";
import {
	createCharacterMutation,
	listCharactersQueryKey,
} from "~/api/@tanstack/react-query.gen";
import { createSmartForm } from "~/components/forms/smart-factory";
import { schemas } from "~/components/forms/type-utils";

export function CreateCharacterForm() {
	const { gameId } = useParams({ from: "/_auth/games/$gameId" });
	const queryClient = useQueryClient();

	const FormComponent = createSmartForm({
		mutation: () =>
			createCharacterMutation({
				path: { game_id: gameId },
			}),
		schema: schemas.character,
		entityName: "character",
		onSuccess: async () => {
			toast("Character created successfully!");
			await queryClient.refetchQueries({
				queryKey: listCharactersQueryKey({
					path: { game_id: gameId },
				}),
			});
		},
	});

	return <FormComponent />;
}
</file>

<file path="src/components/characters/create-character-link.tsx">
import { CreateLinkForm } from "../links";
import { Button } from "../ui/button";
import {
	Popover,
	PopoverContent,
	PopoverPositioner,
	PopoverTrigger,
} from "../ui/popover";

interface CreateCharacterLinkProps {
	gameId: string;
	characterId: string;
}

export function CreateCharacterLink({ gameId, characterId }: CreateCharacterLinkProps) {
	return (
		<Popover>
			<PopoverTrigger render={<Button />}>Create Link</PopoverTrigger>
			<PopoverPositioner align="start">
				<PopoverContent>
					<CreateLinkForm
						gameId={gameId}
						sourceEntityType="character"
						sourceEntityId={characterId}
					/>
				</PopoverContent>
			</PopoverPositioner>
		</Popover>
	);
}
</file>

<file path="src/components/characters/edit-character-dialog.tsx">
import type { Character } from "~/api/types.gen";
import { EditEntityDialog } from "../edit-entity-dialog";
import { EditCharacterForm } from "./edit-character-form";

interface EditCharacterDialogProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
	character: Character;
}

export function EditCharacterDialog({
	isOpen,
	setIsOpen,
	character,
}: EditCharacterDialogProps) {
	return (
		<EditEntityDialog entity={character} isOpen={isOpen} setIsOpen={setIsOpen}>
			<EditCharacterForm
				initialData={character}
				params={{ gameId: character.game_id, id: character.id }}
			/>
		</EditEntityDialog>
	);
}
</file>

<file path="src/components/characters/select-faction-combobox.tsx">
import { ChevronDownIcon } from "lucide-react";
import * as React from "react";
import type { Faction } from "~/api";
import { useSetCharacterPrimaryFactionMutation } from "~/queries/characters";
import { Button } from "../ui/button";
import {
	Combobox,
	ComboboxClear,
	ComboboxEmpty,
	ComboboxInput,
	ComboboxItem,
	ComboboxItemIndicator,
	ComboboxList,
	ComboboxPopup,
	ComboboxPositioner,
	ComboboxTrigger,
} from "../ui/combobox";
import { FormField } from "../ui/composite/form-field";

interface SelectFactionComboboxProps {
	gameId: string;
	characterId: string;
	factions: Faction[];
}
export function SelectFactionCombobox({
	gameId,
	characterId,
	factions,
}: SelectFactionComboboxProps) {
	const id = React.useId();
	const [selectedFaction, setSelectedFaction] = React.useState<Faction | null>(null);
	const [role, setRole] = React.useState<string>("");

	const selectFaction = useSetCharacterPrimaryFactionMutation(gameId, characterId);

	const handleSave = () => {
		if (selectedFaction) {
			selectFaction.mutateAsync({
				body: {
					faction_id: selectedFaction?.id,
					role,
				},
				path: { game_id: gameId, character_id: characterId },
			});
		}
	};

	return (
		<div className="max-w-3xs w-full">
			<Combobox
				items={factions}
				itemToStringLabel={(faction) => faction.name}
				value={selectedFaction}
				onValueChange={(faction) => setSelectedFaction(faction)}
			>
				<div className="relative flex flex-col gap-2">
					<ComboboxInput placeholder="Select a primary faction" id={id} />
					<div className="absolute right-2 bottom-0 flex h-9 items-center justify-center text-muted-foreground">
						<ComboboxClear />
						<ComboboxTrigger
							className="h-9 w-6 text-muted-foreground shadow-none bg-transparent hover:bg-transparent border-none"
							aria-label="Open popup"
						>
							<ChevronDownIcon className="size-4" />
						</ComboboxTrigger>
					</div>
				</div>

				<ComboboxPositioner sideOffset={6}>
					<ComboboxPopup>
						<ComboboxEmpty>No factions found.</ComboboxEmpty>
						<ComboboxList>
							{(faction) => (
								<ComboboxItem key={faction.id} value={faction}>
									<ComboboxItemIndicator />
									<div className="col-start-2">{faction.name}</div>
								</ComboboxItem>
							)}
						</ComboboxList>
					</ComboboxPopup>
				</ComboboxPositioner>
			</Combobox>

			<FormField
				label="Role"
				id="role"
				value={role}
				onInput={(e) => setRole(e.currentTarget.value)}
			/>
			<Button
				variant={"secondary"}
				onClick={handleSave}
				disabled={!selectedFaction}
			>
				Save
			</Button>
		</div>
	);
}
</file>

<file path="src/components/characters/select-note-combobox.tsx">
import { useMutation } from "@tanstack/react-query";
import { ChevronDown } from "lucide-react";
import * as React from "react";
import type { Note } from "~/api";
import { updateNoteMutation, useListNotesQuery } from "~/api/@tanstack/react-query.gen";
import { Button } from "../ui/button";
import {
	Combobox,
	ComboboxClear,
	ComboboxEmpty,
	ComboboxInput,
	ComboboxItem,
	ComboboxItemIndicator,
	ComboboxList,
	ComboboxPopup,
	ComboboxPositioner,
	ComboboxTrigger,
} from "../ui/combobox";
import {
	Popover,
	PopoverContent,
	PopoverPositioner,
	PopoverTrigger,
} from "../ui/popover";
import { Label } from "../ui/label";

interface SelectNoteComboboxProps {
	gameId: string;
	characterId: string;
}

export function SelectNoteCombobox({ gameId, characterId }: SelectNoteComboboxProps) {
	const id = React.useId();
	const [selectedNote, setSelectedNote] = React.useState<Note | null>(null);

	const { data: notesData } = useListNotesQuery({ path: { game_id: gameId } });
	const notes = notesData?.data ?? [];

	const updateNote = useMutation(updateNoteMutation());

	const handleLink = () => {
		if (selectedNote) {
			updateNote.mutateAsync({
				path: { game_id: gameId, id: selectedNote.id },
				body: {
					note: {
						parent_id: characterId,
						parent_type: "character",
					},
				},
			});
		}
	};

	return (
		<Popover>
			<PopoverTrigger render={<Button />}>Link existing note</PopoverTrigger>
			<PopoverPositioner align="start" side="bottom">
				<PopoverContent>
					<div className="space-y-2">
						<div className="space-y-1">
							<Label>Select a note</Label>
							<Combobox
								items={notes}
								value={selectedNote}
								onValueChange={(note) => setSelectedNote(note)}
								itemToStringLabel={(note) => note.name}
							>
								<div className="relative flex flex-col gap-2">
									<ComboboxInput placeholder="Select a note" id={id} />
									<div className="absolute right-2 bottom-0 flex h-9 items-center justify-center text-muted-foreground">
										<ComboboxClear />
										<ComboboxTrigger
											className="h-9 w-6 text-muted-foreground shadow-none bg-transparent hover:bg-transparent border-none"
											aria-label="Open popup"
										>
											<ChevronDown className="size-4" />
										</ComboboxTrigger>
									</div>
								</div>

								<ComboboxPositioner>
									<ComboboxPopup>
										<ComboboxEmpty>No notes found.</ComboboxEmpty>
										<ComboboxList>
											{(note) => (
												<ComboboxItem key={note.id} value={note}>
													<ComboboxItemIndicator />
													<div className="col-start-2">
														{note.name}
													</div>
												</ComboboxItem>
											)}
										</ComboboxList>
									</ComboboxPopup>
								</ComboboxPositioner>
							</Combobox>
						</div>

						<Button onClick={handleLink}>Link</Button>
					</div>
				</PopoverContent>
			</PopoverPositioner>
		</Popover>
	);
}
</file>

<file path="src/components/factions/create-faction-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useParams } from "@tanstack/react-router";
import { toast } from "sonner";
import {
	createFactionMutation,
	listFactionsQueryKey,
} from "~/api/@tanstack/react-query.gen";
import { createSmartForm } from "~/components/forms/smart-factory";
import { schemas } from "../forms/type-utils";

export function CreateFactionForm() {
	const { gameId } = useParams({ from: "/_auth/games/$gameId" });
	const queryClient = useQueryClient();

	const FormComponent = createSmartForm({
		mutation: () =>
			createFactionMutation({
				path: { game_id: gameId },
			}),
		schema: schemas.faction,
		entityName: "faction",
		onSuccess: async () => {
			toast("Faction created successfully!");
			await queryClient.refetchQueries({
				queryKey: listFactionsQueryKey({
					path: { game_id: gameId },
				}),
			});
		},
	});

	return <FormComponent />;
}
</file>

<file path="src/components/factions/create-faction-link.tsx">
import { CreateLinkForm } from "../links";
import { Button } from "../ui/button";
import {
	Popover,
	PopoverContent,
	PopoverPositioner,
	PopoverTrigger,
} from "../ui/popover";

interface CreateFactionLinkProps {
	gameId: string;
	factionId: string;
}

export function CreateFactionLink({ gameId, factionId }: CreateFactionLinkProps) {
	return (
		<Popover>
			<PopoverTrigger render={<Button />}>Create Link</PopoverTrigger>
			<PopoverPositioner align="start">
				<PopoverContent>
					<CreateLinkForm
						gameId={gameId}
						sourceEntityType="faction"
						sourceEntityId={factionId}
					/>
				</PopoverContent>
			</PopoverPositioner>
		</Popover>
	);
}
</file>

<file path="src/components/factions/create-faction-sheet.tsx">
import { Sheet, SheetContent } from "../ui/sheet";
import { CreateFactionForm } from "./create-faction-form";

interface CreateFactionSheetProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
}

export function CreateFactionSheet({ isOpen, setIsOpen }: CreateFactionSheetProps) {
	return (
		<Sheet open={isOpen} onOpenChange={setIsOpen}>
			<SheetContent className="p-4 pt-10" width="lg">
				<CreateFactionForm />
			</SheetContent>
		</Sheet>
	);
}
</file>

<file path="src/components/factions/edit-faction-dialog.tsx">
import type { Faction } from "~/api";
import { EditEntityDialog } from "../edit-entity-dialog";
import { EditFactionForm } from "./edit-faction-form";

interface EditFactionDialogProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
	faction: Faction;
}

export function EditFactionDialog({
	isOpen,
	setIsOpen,
	faction,
}: EditFactionDialogProps) {
	return (
		<EditEntityDialog entity={faction} isOpen={isOpen} setIsOpen={setIsOpen}>
			<EditFactionForm
				initialData={faction}
				params={{ gameId: faction.game_id, id: faction.id }}
			/>
		</EditEntityDialog>
	);
}
</file>

<file path="src/components/layout/tree.tsx">
import { ChevronRight } from "lucide-react";
import * as React from "react";
import type { EntityType } from "~/types";
import { Button } from "../ui/button";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "../ui/collapsible";
import { SidebarMenuItem, SidebarMenuLink, SidebarMenuSub } from "../ui/sidebar";

interface TreeNode {
	children?: Array<TreeNode>;
	id: string;
	name: string;
	entity_type: EntityType;
}

interface TreeProps {
	parentNode: TreeNode;
	gameId: string;
}

export function SidebarTree({ parentNode, gameId }: TreeProps) {
	const [isOpen, setIsOpen] = React.useState(true);

	if (!parentNode.children?.length) {
		return (
			<SidebarMenuItem>
				<div className="relative">
					<SidebarMenuLink
						to={`/games/$gameId/${parentNode.entity_type}s/$id` as string}
						params={{ gameId, id: parentNode.id }}
						className="w-full pl-6 min-w-0"
						activeProps={{
							className:
								"bg-primary text-primary-foreground hover:bg-primary/90 hover:text-primary-foreground",
						}}
					>
						<span className="truncate">{parentNode.name}</span>
					</SidebarMenuLink>
					<div className="absolute left-0 top-1/2 -translate-y-1/2 h-6 w-6 flex items-center justify-center">
						<div className="h-1 w-1 rounded-full bg-muted-foreground/40" />
					</div>
				</div>
			</SidebarMenuItem>
		);
	}

	return (
		<SidebarMenuItem>
			<Collapsible
				open={isOpen}
				onOpenChange={setIsOpen}
				className="group/collapsible"
			>
				<div className="relative">
					<SidebarMenuLink
						to={`/games/$gameId/${parentNode.entity_type}s/$id` as string}
						params={{ gameId, id: parentNode.id }}
						className="w-full pl-6 min-w-0"
						activeProps={{
							className:
								"bg-primary text-primary-foreground hover:bg-primary/90 hover:text-primary-foreground",
						}}
					>
						<span className="truncate">{parentNode.name}</span>
					</SidebarMenuLink>
					<CollapsibleTrigger
						render={
							<Button
								variant="ghost"
								size="icon"
								className="absolute left-0 top-1/2 -translate-y-1/2 h-6 w-6 p-0 hover:bg-sidebar-accent z-10"
							>
								<ChevronRight
									className={`h-3 w-3 transition-transform ${isOpen ? "rotate-90" : ""}`}
								/>
							</Button>
						}
					/>
				</div>
				<CollapsibleContent>
					<SidebarMenuSub className="mx-0 px-0 pl-2">
						{parentNode.children?.map((subNode) => (
							<SidebarTree
								gameId={gameId}
								key={subNode.id}
								parentNode={subNode}
							/>
						))}
					</SidebarMenuSub>
				</CollapsibleContent>
			</Collapsible>
		</SidebarMenuItem>
	);
}
</file>

<file path="src/components/layout/user-sidebar.tsx">
import { Link } from "@tanstack/react-router";
import {
	BadgeCheck,
	Bell,
	ChevronsUpDown,
	CreditCard,
	LogOut,
	Sparkles,
} from "lucide-react";

import { Avatar, AvatarFallback, AvatarImage } from "~/components/ui/avatar";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuGroup,
	DropdownMenuItem,
	DropdownMenuLabel,
	DropdownMenuPositioner,
	DropdownMenuSeparator,
	DropdownMenuTrigger,
} from "~/components/ui/dropdown-menu";
import { SidebarMenuButton, useSidebar } from "~/components/ui/sidebar";

export function NavUser({
	user,
}: {
	user: {
		name: string;
		email: string;
		avatar: string;
	};
}) {
	const { isMobile } = useSidebar();

	return (
		<DropdownMenu>
			<DropdownMenuTrigger
				render={
					<SidebarMenuButton
						size="lg"
						className="data-[popup-open]:bg-sidebar-accent data-[popup-open]:text-sidebar-accent-foreground"
					>
						<Avatar className="h-8 w-8 rounded-lg">
							<AvatarImage src={user.avatar} alt={user.name} />
							<AvatarFallback className="rounded-lg">CN</AvatarFallback>
						</Avatar>
						<div className="grid flex-1 text-left text-sm leading-tight">
							<span className="truncate font-medium">{user.name}</span>
							<span className="truncate text-xs">{user.email}</span>
						</div>
						<ChevronsUpDown className="ml-auto size-4" />
					</SidebarMenuButton>
				}
			/>
			<DropdownMenuPositioner
				side={isMobile ? "bottom" : "right"}
				align="end"
				sideOffset={24}
			>
				<DropdownMenuContent className="w-56">
					<DropdownMenuGroup>
						<DropdownMenuLabel>
							<div className="flex items-center gap-2 px-1 py-1.5 text-left text-sm">
								<Avatar className="h-8 w-8 rounded-lg">
									<AvatarImage src={user.avatar} alt={user.name} />
									<AvatarFallback className="rounded-lg">
										CN
									</AvatarFallback>
								</Avatar>
								<div className="grid flex-1 text-left text-sm leading-tight">
									<span className="truncate font-medium">
										{user.name}
									</span>
									<span className="truncate text-xs">{user.email}</span>
								</div>
							</div>
						</DropdownMenuLabel>
					</DropdownMenuGroup>
					<DropdownMenuSeparator />
					<DropdownMenuGroup>
						<DropdownMenuItem>
							<Sparkles />
							Upgrade to Pro
						</DropdownMenuItem>
						<DropdownMenuSeparator />
						<DropdownMenuItem>
							<BadgeCheck />
							Account
						</DropdownMenuItem>
						<DropdownMenuItem>
							<CreditCard />
							Billing
						</DropdownMenuItem>
						<DropdownMenuItem>
							<Bell />
							Notifications
						</DropdownMenuItem>
						<DropdownMenuSeparator />
						<DropdownMenuItem render={<Link to="/logout" />}>
							<LogOut />
							Log out
						</DropdownMenuItem>
					</DropdownMenuGroup>
				</DropdownMenuContent>
			</DropdownMenuPositioner>
		</DropdownMenu>
	);
}
</file>

<file path="src/components/links/hooks/useDeleteLink.ts">
import { useMutation, useQueryClient } from "@tanstack/react-query";
import {
	deleteCharacterLinkMutation,
	deleteFactionLinkMutation,
	deleteLocationLinkMutation,
	deleteNoteLinkMutation,
	deleteQuestLinkMutation,
} from "~/api/@tanstack/react-query.gen";
import type { DeleteLinkParams } from "../types";

export function useDeleteLink(onSuccess?: () => void, onError?: (error: Error) => void) {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async ({
			gameId,
			sourceType,
			sourceId,
			targetType,
			targetId,
		}: DeleteLinkParams) => {
			console.log(targetType, targetId);
			console.log(sourceType, sourceId);
			// Create the path parameter based on source entity type
			const pathParam = {
				game_id: gameId,
				[`${sourceType}_id`]: sourceId,
				entity_type: targetType,
				entity_id: targetId,
			};

			const mutationMap = {
				character: deleteCharacterLinkMutation(),
				faction: deleteFactionLinkMutation(),
				location: deleteLocationLinkMutation(),
				note: deleteNoteLinkMutation(),
				quest: deleteQuestLinkMutation(),
			};
			const mutation = mutationMap[sourceType];
			if (!mutation.mutationFn) {
				throw new Error(`Unsupported entity type: ${sourceType}`);
			}

			return mutation.mutationFn({
				path: pathParam as any,
			});
		},
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: [{ _id: "listGameEntities" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getCharacterLinks" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getFactionLinks" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getLocationLinks" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getNoteLinks" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getQuestLinks" }] });
			onSuccess?.();
		},
		onError,
	});
}
</file>

<file path="src/components/links/delete-link.tsx">
import { Trash } from "lucide-react";
import type { EntityType } from "~/types";
import { Button } from "../ui/button";
import { useDeleteLink } from "./hooks/useDeleteLink";

interface DeleteLinkProps {
	gameId: string;
	sourceId: string;
	sourceType: EntityType;
	targetId: string;
	targetType: EntityType;
}

export function DeleteLink({
	gameId,
	sourceId,
	sourceType,
	targetId,
	targetType,
}: DeleteLinkProps) {
	const deleteLink = useDeleteLink();

	const handleDelete = (e: React.MouseEvent<HTMLButtonElement>) => {
		e.preventDefault();

		deleteLink.mutateAsync({
			gameId,
			sourceId,
			sourceType,
			targetId,
			targetType,
		});
	};

	return (
		<Button variant="ghost" size="icon" onClick={handleDelete}>
			<Trash className="w-3 h-3" />
		</Button>
	);
}
</file>

<file path="src/components/locations/create-location-link.tsx">
import { CreateLinkForm } from "../links";

interface CreateLocationLinkProps {
	gameId: string;
	locationId: string;
}

export function CreateLocationLink({ gameId, locationId }: CreateLocationLinkProps) {
	return (
		<CreateLinkForm
			gameId={gameId}
			sourceEntityType="location"
			sourceEntityId={locationId}
		/>
	);
}
</file>

<file path="src/components/locations/create-location-sheet.tsx">
import {
	Select,
	SelectContent,
	SelectItem,
	SelectPositioner,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Sheet, SheetContent } from "../ui/sheet";
import { CreateLocationForm } from "./create-location-form";

interface CreateLocationSheetProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
}

export function CreateLocationSheet({ isOpen, setIsOpen }: CreateLocationSheetProps) {
	return (
		<Sheet open={isOpen} onOpenChange={setIsOpen} modal={false}>
			<SheetContent className="p-4 pt-10" width="lg">
				<Select>
					<SelectTrigger>
						<SelectValue placeholder="Select a parent location" />
					</SelectTrigger>
					<SelectPositioner alignItemWithTrigger>
						<SelectContent>
							<SelectItem>Parent Location 1</SelectItem>
							<SelectItem>Parent Location 2</SelectItem>
							<SelectItem>Parent Location 3</SelectItem>
						</SelectContent>
					</SelectPositioner>
				</Select>
				<CreateLocationForm />
			</SheetContent>
		</Sheet>
	);
}
</file>

<file path="src/components/locations/edit-location-dialog.tsx">
import type { Location } from "~/api/types.gen";
import { EditEntityDialog } from "../edit-entity-dialog";
import { EditLocationForm } from "./edit-location-form";

interface EditLocationDialogProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
	location: Location;
}

export function EditLocationDialog({
	isOpen,
	setIsOpen,
	location,
}: EditLocationDialogProps) {
	return (
		<EditEntityDialog entity={location} isOpen={isOpen} setIsOpen={setIsOpen}>
			<EditLocationForm
				initialData={location}
				params={{ gameId: location.game_id, id: location.id }}
			/>
		</EditEntityDialog>
	);
}
</file>

<file path="src/components/notes/create-note-link.tsx">
import { CreateLinkForm } from "../links";

interface CreateNoteLinkProps {
	gameId: string;
	noteId: string;
}

export function CreateNoteLink({ gameId, noteId }: CreateNoteLinkProps) {
	return (
		<CreateLinkForm gameId={gameId} sourceEntityType="note" sourceEntityId={noteId} />
	);
}
</file>

<file path="src/components/notes/edit-note-dialog.tsx">
import type { Note } from "~/api/types.gen";
import { EditEntityDialog } from "../edit-entity-dialog";
import { EditNoteForm } from "./edit-note-form";

interface EditNoteDialogProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
	note: Note;
}

export function EditNoteDialog({
	isOpen,
	setIsOpen,
	note,
}: EditNoteDialogProps) {
	return (
		<EditEntityDialog entity={note} isOpen={isOpen} setIsOpen={setIsOpen}>
			<EditNoteForm
				initialData={note}
				params={{ gameId: note.game_id, id: note.id }}
			/>
		</EditEntityDialog>
	);
}
</file>

<file path="src/components/notes/note-links-popover.tsx">
import { Button } from "../ui/button";
import {
	Popover,
	PopoverContent,
	PopoverPositioner,
	PopoverTrigger,
} from "../ui/popover";
import { CreateNoteLink } from "./create-note-link";

interface NoteLinksPopoverProps {
	gameId: string;
	noteId: string;
}

export function NoteLinksPopover({ gameId, noteId }: NoteLinksPopoverProps) {
	return (
		<Popover>
			<PopoverTrigger render={<Button />}>Create Link</PopoverTrigger>
			<PopoverPositioner align="start">
				<PopoverContent>
					<CreateNoteLink gameId={gameId} noteId={noteId} />
				</PopoverContent>
			</PopoverPositioner>
		</Popover>
	);
}
</file>

<file path="src/components/quests/create-quest-link.tsx">
import { CreateLinkForm } from "../links";

interface CreateQuestLinkProps {
	gameId: string;
	questId: string;
}

export function CreateQuestLink({ gameId, questId }: CreateQuestLinkProps) {
	return (
		<CreateLinkForm
			gameId={gameId}
			sourceEntityType="quest"
			sourceEntityId={questId}
			excludeTypes={["quest"]}
		/>
	);
}
</file>

<file path="src/components/quests/edit-quest-dialog.tsx">
import type { Quest } from "~/api/types.gen";
import { EditEntityDialog } from "../edit-entity-dialog";
import { EditQuestForm } from "./edit-quest-form";

interface EditQuestDialogProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
	quest: Quest;
}

export function EditQuestDialog({
	isOpen,
	setIsOpen,
	quest,
}: EditQuestDialogProps) {
	return (
		<EditEntityDialog entity={quest} isOpen={isOpen} setIsOpen={setIsOpen}>
			<EditQuestForm
				initialData={quest}
				params={{ gameId: quest.game_id, id: quest.id }}
			/>
		</EditEntityDialog>
	);
}
</file>

<file path="src/components/quests/quest-links-popover.tsx">
import { Button } from "../ui/button";
import {
	Popover,
	PopoverContent,
	PopoverPositioner,
	PopoverTrigger,
} from "../ui/popover";
import { CreateQuestLink } from "./create-quest-link";

interface QuestLinksPopoverProps {
	gameId: string;
	questId: string;
}

export function QuestLinksPopover({ gameId, questId }: QuestLinksPopoverProps) {
	return (
		<Popover>
			<PopoverTrigger render={<Button />}>Create Link</PopoverTrigger>
			<PopoverPositioner align="start">
				<PopoverContent>
					<CreateQuestLink gameId={gameId} questId={questId} />
				</PopoverContent>
			</PopoverPositioner>
		</Popover>
	);
}
</file>

<file path="src/components/ui/composite/form-field.tsx">
import { Input } from "../input";
import { Label } from "../label";

interface FormFieldProps extends React.ComponentProps<typeof Input> {
	label: string;
}

export function FormField({ label, className, id, ...props }: FormFieldProps) {
	const inputId = id || `input-${Math.random().toString(36).slice(2, 11)}`;

	return (
		<div className="space-y-1">
			<Label htmlFor={inputId}>{label}</Label>
			<Input id={inputId} className={className} {...props} />
		</div>
	);
}
</file>

<file path="src/components/ui/editor/hooks/useCreateLinksFromMentions.ts">
import type { JSONContent } from "@tiptap/react";
import { useCreateLink } from "~/components/links/hooks/useCreateLink";
import type { EntityType } from "~/types";
import { extractMentionsFromJSON, getUniqueMentions } from "../mention-utils";

interface SourceEntity {
	gameId: string;
	type: EntityType;
	id: string;
}

export function useCreateLinksFromMentions() {
	const createLink = useCreateLink(
		() => {
			// Success callback - do nothing, keep it invisible
		},
		(error) => {
			// Error callback - log but don't show to user
			console.warn("Failed to create mention link:", error);
		},
	);

	const createLinksFromMentions = async (
		editorJson: JSONContent,
		sourceEntity: SourceEntity,
	) => {
		// Extract mentions from editor content
		const allMentions = extractMentionsFromJSON(editorJson);
		const uniqueMentions = getUniqueMentions(allMentions);

		// Create links for each mention
		const linkPromises = uniqueMentions.map(async (mention) => {
			try {
				await createLink.mutateAsync({
					gameId: sourceEntity.gameId,
					sourceType: sourceEntity.type,
					sourceId: sourceEntity.id,
					entity_type: mention.type,
					entity_id: mention.id,
					relationship_type: "", // Empty as requested
					description: "", // Empty as requested
				});
			} catch (error: any) {
				// Silently ignore duplicate link errors and other expected errors
				if (
					!error.message?.includes("already exists") &&
					!error.message?.includes("duplicate")
				) {
					console.warn(
						`Failed to create mention link to ${mention.type}:${mention.id}:`,
						error,
					);
				}
				// Continue processing other mentions even if one fails
			}
		});

		// Wait for all link creation attempts to complete
		await Promise.allSettled(linkPromises);
	};

	return {
		createLinksFromMentions,
		isCreatingLinks: createLink.isPending,
	};
}
</file>

<file path="src/components/ui/editor/hooks.ts">
import * as React from "react";
import type { EntityType } from "~/types";

type PayloadMap = {
	[K in EntityType]: {
		content: string;
		content_plain_text: string;
	};
};

export const useEditorContentActions = () => {
	const [isUpdated, setIsUpdated] = React.useState(false);
	const [updatedContent, setUpdatedContent] = React.useState<{
		json: object;
		text: string;
	}>({ json: {}, text: "" });

	const onChange = (newContent: { json: object; text: string }) => {
		setUpdatedContent(newContent);
		setIsUpdated(true);
	};

	const getPayload = <T extends EntityType>(type: T): Pick<PayloadMap, T> => {
		return {
			[type]: {
				content: JSON.stringify(updatedContent.json),
				content_plain_text: updatedContent.text,
			},
		} as Pick<PayloadMap, T>;
	};

	return {
		isUpdated,
		setIsUpdated,
		onChange,
		getPayload,
		updatedContent, // Export the content so we can access the JSON
	};
};
</file>

<file path="src/components/ui/editor/mention-utils.ts">
import type { JSONContent } from "@tiptap/react";

export interface ExtractedMention {
	id: string;
	type: "character" | "faction" | "location" | "note" | "quest";
	gameId: string;
	label: string;
}

/**
 * Recursively extract mention nodes from TipTap JSON content
 */
export function extractMentionsFromJSON(json: JSONContent): ExtractedMention[] {
	const mentions: ExtractedMention[] = [];
	
	function traverse(node: JSONContent) {
		// Check if this node is a mention
		if (node.type === "mention" && node.attrs) {
			const { id, type, gameId, label } = node.attrs;
			if (id && type && gameId && label) {
				mentions.push({
					id,
					type: type as ExtractedMention["type"],
					gameId,
					label,
				});
			}
		}
		
		// Recursively traverse child nodes
		if (node.content) {
			for (const child of node.content) {
				traverse(child);
			}
		}
	}
	
	traverse(json);
	return mentions;
}

/**
 * Get unique mentions (deduplicate by id + type combination)
 */
export function getUniqueMentions(mentions: ExtractedMention[]): ExtractedMention[] {
	const seen = new Set<string>();
	return mentions.filter(mention => {
		const key = `${mention.type}:${mention.id}`;
		if (seen.has(key)) {
			return false;
		}
		seen.add(key);
		return true;
	});
}
</file>

<file path="src/components/ui/editor/tiptap.css">
/* All editor variables now defined in main styles.css */
:root {
	/* Alias editor variables to main theme */
	--editor-text-default: var(--color-foreground);
	--editor-text-gray: var(--color-muted-foreground);
	--editor-text-blue: var(--color-primary);
	--editor-text-red: var(--color-destructive);

	--editor-bg-default: var(--color-background);
	--editor-bg-subtle: var(--color-muted);
	--editor-bg-muted: var(--color-accent);

	--editor-highlight-default: var(--color-primary);
	--editor-highlight-gray: var(--color-accent);

	--editor-border-default: var(--color-border);
	--editor-border-strong: var(--color-ring);

	--editor-font-sans: var(--font-sans);
	--editor-font-mono: var(--font-mono);
	--editor-font-serif: var(--font-serif);

	--editor-shadow-sm: var(--shadow-sm);
	--editor-shadow-md: var(--shadow-md);
	--editor-shadow-lg: var(--shadow-lg);
}

/* All dark mode variables now handled in main styles.css */

/* Core Editor Styles */
.ProseMirror {
	caret-color: var(--editor-text-default);
	outline: none;
	padding: var(--editor-spacing-4) var(--editor-spacing-4);
	margin: 0 auto;
	max-width: 95%;
	font-family: var(--editor-font-sans);
	position: relative;
	/* background-color: var(--editor-bg-default); */
	color: var(--editor-text-default);
	transition: all var(--editor-transition-normal);
	text-rendering: optimizeLegibility;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
	white-space: pre-wrap;
}

.ProseMirror:focus {
	outline: none;
	box-shadow: none;
}

.ProseMirror .selection,
.ProseMirror *::selection {
	background-color: var(--editor-highlight-default);
	/* color: var(--editor-text-default); */
}

.ProseMirror > .react-renderer {
	margin: var(--editor-spacing-12) 0;
	transition: all var(--editor-transition-normal);
}

.ProseMirror > .react-renderer:first-child {
	margin-top: 0;
}

.ProseMirror > .react-renderer:last-child {
	margin-bottom: 0;
}

/* Typography Styles */
.ProseMirror p {
	line-height: 1.5;
	margin: var(--editor-spacing-2) 0;
	color: var(--editor-text-default);
	font-size: 1rem;
}

.ProseMirror > p {
	margin: var(--editor-spacing-3) 0;
}

.ProseMirror h1,
.ProseMirror h2,
.ProseMirror h3,
.ProseMirror h4 {
	font-family: var(--editor-font-sans);
	font-weight: 700;
	letter-spacing: -0.025em;
	color: var(--editor-text-default);
	scroll-margin-top: var(--editor-spacing-16);
	line-height: 1.2;
}

.ProseMirror h1 {
	font-size: 1.875rem;
	margin: var(--editor-spacing-4) 0 var(--editor-spacing-2);
}

.ProseMirror h2 {
	font-size: 1.5rem;
	margin: var(--editor-spacing-4) 0 var(--editor-spacing-2);
}

.ProseMirror h3 {
	font-size: 1.25rem;
	margin: var(--editor-spacing-3) 0 var(--editor-spacing-2);
}

.ProseMirror h4 {
	font-size: 1.125rem;
	margin: var(--editor-spacing-3) 0 var(--editor-spacing-1);
}

.ProseMirror a {
	color: var(--editor-text-blue);
	cursor: pointer;
	text-decoration: underline;
	text-decoration-thickness: 0.1em;
	text-underline-offset: 0.2em;
	transition: all var(--editor-transition-fast);
}

.ProseMirror a:hover {
	color: var(--editor-text-blue);
	text-decoration-thickness: 0.2em;
}

.ProseMirror code {
	font-family: var(--editor-font-mono);
	font-size: 0.9em;
	background-color: var(--editor-bg-muted);
	padding: 0.2em 0.4em;
	border-radius: var(--radius);
	color: var(--editor-text-default);
	border: 1px solid var(--editor-border-default);
}

.ProseMirror pre {
	margin: var(--editor-spacing-6) 0;
	padding: var(--editor-spacing-4);
	background-color: var(--editor-bg-subtle);
	border-radius: calc(var(--radius) + 4px);
	overflow-x: auto;
	border: 1px solid var(--editor-border-default);
}

.ProseMirror pre code {
	background-color: transparent;
	padding: 0;
	border: none;
	font-size: 0.875rem;
	line-height: 1.7;
	color: var(--editor-text-default);
}

.ProseMirror blockquote {
	margin: var(--editor-spacing-6) 0;
	padding: var(--editor-spacing-4) var(--editor-spacing-6);
	border-left: 4px solid var(--editor-border-strong);
	font-style: italic;
	color: var(--editor-text-gray);
	background-color: var(--editor-bg-subtle);
	border-radius: 0 calc(var(--radius) + 4px) calc(var(--radius) + 4px) 0;
}

/* Lists */
.ProseMirror ul,
.ProseMirror ol {
	margin: var(--editor-spacing-4) 0;
	padding-left: var(--editor-spacing-6);
}

.ProseMirror li {
	margin: var(--editor-spacing-2) 0;
	padding-left: var(--editor-spacing-2);
}

.ProseMirror ul {
	list-style-type: disc;
}

.ProseMirror ul ul {
	list-style-type: circle;
}

.ProseMirror ul ul ul {
	list-style-type: square;
}

.ProseMirror ol {
	list-style-type: decimal;
}

.ProseMirror ol ol {
	list-style-type: lower-alpha;
}

.ProseMirror ol ol ol {
	list-style-type: lower-roman;
}

/* Tables */
.ProseMirror table {
	width: 100%;
	border-collapse: separate;
	border-spacing: 0;
	margin: var(--editor-spacing-6) 0;
	border: 1px solid var(--editor-border-default);
	border-radius: calc(var(--radius) + 4px);
	overflow: hidden;
}

.ProseMirror th {
	background-color: var(--editor-bg-subtle);
	font-weight: 600;
	text-align: left;
	padding: var(--editor-spacing-3) var(--editor-spacing-4);
	border-bottom: 2px solid var(--editor-border-default);
}

.ProseMirror td {
	padding: var(--editor-spacing-3) var(--editor-spacing-4);
	border-bottom: 1px solid var(--editor-border-default);
	transition: background-color var(--editor-transition-fast);
}

.ProseMirror tr:last-child td {
	border-bottom: none;
}

.ProseMirror tr:hover td {
	background-color: var(--editor-bg-subtle);
}

/* Images */
.ProseMirror img {
	max-width: 100%;
	height: auto;
	border-radius: calc(var(--radius) + 4px);
	border: 1px solid var(--editor-border-default);
	box-shadow: var(--editor-shadow-sm);
	transition: all var(--editor-transition-normal);
	display: block;
	margin: var(--editor-spacing-1) auto;
}

.ProseMirror img:hover {
	box-shadow: var(--editor-shadow-lg);
	transform: translateY(-2px);
}

/* Horizontal Rule */
.ProseMirror hr {
	margin: var(--editor-spacing-8) 0;
	border: none;
	border-top: 2px solid var(--editor-border-default);
}

/* Floating Menu & Toolbar */
.floating-menu {
	background-color: var(--editor-bg-default);
	border: 1px solid var(--editor-border-default);
	box-shadow: var(--editor-shadow-lg);
	border-radius: calc(var(--radius) + 4px);
	padding: var(--editor-spacing-1);
	display: flex;
	gap: var(--editor-spacing-1);
	align-items: center;
	animation: fadeIn var(--editor-transition-normal);
	backdrop-filter: blur(8px);
}

.toolbar-button {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	border-radius: var(--radius);
	font-size: 0.875rem;
	font-weight: 500;
	height: 2.25rem;
	padding: 0 var(--editor-spacing-3);
	transition: all var(--editor-transition-fast);
	background-color: transparent;
	color: var(--editor-text-default);
	border: 1px solid transparent;
}

.toolbar-button:hover {
	background-color: var(--editor-bg-subtle);
	color: var(--editor-text-default);
}

.toolbar-button:focus-visible {
	outline: none;
	box-shadow: 0 0 0 2px var(--editor-border-strong);
}

.toolbar-button:disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

.toolbar-button.active {
	background-color: var(--editor-bg-muted);
	color: var(--editor-text-blue);
}

/* Placeholder Styles
.ProseMirror p.is-editor-empty:first-child::before {
  content: "Start writing or press '/' for commands...";
  color: var(--editor-text-gray);
  pointer-events: none;
  float: left;
  height: 0;
} */

/* Mobile Optimizations */
@media (max-width: 640px) {
	.ProseMirror {
		padding: var(--editor-spacing-8) var(--editor-spacing-4);
	}

	.ProseMirror h1 {
		font-size: 2rem;
	}
	.ProseMirror h2 {
		font-size: 1.75rem;
	}
	.ProseMirror h3 {
		font-size: 1.5rem;
	}
	.ProseMirror h4 {
		font-size: 1.25rem;
	}
	.ProseMirror p {
		font-size: 1rem;
	}
}

/* Animations */
@keyframes fadeIn {
	from {
		opacity: 0;
		transform: translateY(-8px);
	}
	to {
		opacity: 1;
		transform: translateY(0);
	}
}

/* Print Styles */
@media print {
	.ProseMirror {
		padding: 0;
		max-width: none;
	}

	.floating-menu,
	.toolbar-button {
		display: none;
	}
}

.is-editor-empty::before {
	color: var(--editor-text-gray);
	content: attr(data-placeholder);
	float: left;
	height: 0;
	pointer-events: none;
}

/* Mention styles */
.ProseMirror .mention-wrapper {
	display: inline;
	vertical-align: baseline;
}

.ProseMirror .mention {
	display: inline;
	vertical-align: baseline;
	padding: 0;
	margin: 0;
	background: none;
	border: none;
	text-decoration: none;
	pointer-events: auto;
}

.ProseMirror .mention .mention-link {
	text-decoration: none !important;
	text-decoration-thickness: 0 !important;
	text-underline-offset: 0 !important;
	vertical-align: baseline;
	pointer-events: auto;
	cursor: pointer;
}

.ProseMirror .mention .mention-link:hover {
	text-decoration: none !important;
	text-decoration-thickness: 0 !important;
}

.ProseMirror .mention .mention-link * {
	pointer-events: none;
}
</file>

<file path="src/components/ui/editor/utils.ts">
export const parseContentForEditor = (content?: string) => {
	if (!content) return null;

	try {
		const parsed = JSON.parse(content);
		if (parsed && typeof parsed === "object" && parsed.type) {
			return parsed;
		}
	} catch {
		// Not JSON, continue to plain text handling
	}

	return {
		type: "doc",
		content: [
			{
				type: "paragraph",
				content: [
					{
						type: "text",
						text: content,
					},
				],
			},
		],
	};
};
</file>

<file path="src/components/ui/avatar.tsx">
import { Avatar as AvatarPrimitive } from "@base-ui-components/react/avatar";
import { cn } from "~/utils/cn";

function Avatar({
	className,
	...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
	return (
		<AvatarPrimitive.Root
			data-slot="avatar"
			className={cn(
				"relative flex size-8 shrink-0 overflow-hidden rounded-full",
				className,
			)}
			{...props}
		/>
	);
}

function AvatarImage({
	className,
	...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
	return (
		<AvatarPrimitive.Image
			data-slot="avatar-image"
			className={cn("aspect-square size-full", className)}
			{...props}
		/>
	);
}

function AvatarFallback({
	className,
	...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
	return (
		<AvatarPrimitive.Fallback
			data-slot="avatar-fallback"
			className={cn(
				"bg-muted flex items-center justify-center size-full rounded-full text-sm",
				className,
			)}
			{...props}
		/>
	);
}

export { Avatar, AvatarImage, AvatarFallback };
</file>

<file path="src/components/ui/badge.tsx">
import { useRender } from "@base-ui-components/react/use-render";
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";
import { cn } from "~/utils/cn";

const badgeVariants = cva(
	"inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
	{
		variants: {
			variant: {
				default:
					"border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
				secondary:
					"border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
				destructive:
					"border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
				outline:
					"text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

function Badge({
	className,
	variant,
	render = <span />,
	...props
}: React.ComponentProps<"span"> &
	VariantProps<typeof badgeVariants> & { render?: useRender.RenderProp }) {
	return useRender({
		render,
		props: {
			"data-slot": "badge",
			className: cn(badgeVariants({ variant }), className),
			...props,
		},
	});
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/checkbox.tsx">
import { Checkbox as CheckboxPrimitive } from "@base-ui-components/react/checkbox";
import { CheckIcon } from "lucide-react";
import type * as React from "react";
import { cn } from "~/utils/cn";

function Checkbox({
	className,
	...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
	return (
		<CheckboxPrimitive.Root
			data-slot="checkbox"
			className={cn(
				"peer border-input dark:bg-input/30 data-[checked]:bg-primary data-[checked]:text-primary-foreground dark:data-[checked]:bg-primary data-[checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
				className,
			)}
			{...props}
		>
			<CheckboxPrimitive.Indicator
				data-slot="checkbox-indicator"
				className="flex items-center justify-center text-current transition-none"
			>
				<CheckIcon className="size-3.5" />
			</CheckboxPrimitive.Indicator>
		</CheckboxPrimitive.Root>
	);
}

export { Checkbox };
</file>

<file path="src/components/ui/combobox.tsx">
import { Combobox as ComboboxPrimitive } from "@base-ui-components/react/combobox";
import { CheckIcon, XIcon } from "lucide-react";

import { Button } from "~/components/ui/button";
import { Input } from "~/components/ui/input";
import { Separator } from "~/components/ui/separator";
import { cn } from "~/utils/cn";

function Combobox<
	ItemValue,
	SelectedValue = ItemValue,
	Multiple extends boolean | undefined = false,
>(props: ComboboxPrimitive.Root.Props<ItemValue, SelectedValue, Multiple>) {
	return <ComboboxPrimitive.Root data-slot="combobox" {...props} />;
}

function ComboboxInput(props: React.ComponentProps<typeof ComboboxPrimitive.Input>) {
	return (
		<ComboboxPrimitive.Input
			data-slot="combobox-input"
			render={<Input />}
			{...props}
		/>
	);
}

function ComboboxTrigger(props: React.ComponentProps<typeof ComboboxPrimitive.Trigger>) {
	return (
		<ComboboxPrimitive.Trigger
			data-slot="combobox-trigger"
			render={<Button variant="outline" />}
			{...props}
		/>
	);
}

function ComboboxIcon(props: React.ComponentProps<typeof ComboboxPrimitive.Icon>) {
	return <ComboboxPrimitive.Icon data-slot="combobox-icon" {...props} />;
}

function ComboboxClear({
	children,
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.Clear>) {
	return (
		<ComboboxPrimitive.Clear
			className={cn(
				"flex h-9 w-6 items-center justify-center rounded bg-transparent p-0",
				className,
			)}
			aria-label="Clear selection"
			data-slot="combobox-clear"
			{...props}
		>
			{children ?? <XIcon className="size-4" />}
		</ComboboxPrimitive.Clear>
	);
}

function ComboboxValue(props: React.ComponentProps<typeof ComboboxPrimitive.Value>) {
	return <ComboboxPrimitive.Value data-slot="combobox-value" {...props} />;
}

function ComboboxChips({
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.Chips>) {
	return (
		<ComboboxPrimitive.Chips
			data-slot="combobox-chips"
			className={cn(
				"min-h-9 flex flex-wrap items-start gap-1 rounded-md border px-1.5 py-1.5 transition-[color,box-shadow]",
				"focus-within:border-ring focus-within:ring-ring/50 focus-within:ring-[3px]",
				className,
			)}
			{...props}
		/>
	);
}

function ComboboxChip({
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.Chip>) {
	return (
		<ComboboxPrimitive.Chip
			data-slot="combobox-chip"
			className={cn(
				"flex items-center gap-1 rounded-md bg-muted px-1 ps-2 pe-0 text-xs outline-none cursor-default",
				className,
			)}
			{...props}
		/>
	);
}

function ComboboxChipRemove({
	className,
	children,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.ChipRemove>) {
	return (
		<ComboboxPrimitive.ChipRemove
			data-slot="combobox-chip-remove"
			className={cn(
				"rounded-md p-1 text-inherit hover:bg-accent-foreground/10",
				className,
			)}
			aria-label="Remove"
			{...props}
		>
			{children ?? <XIcon className="size-3.5" />}
		</ComboboxPrimitive.ChipRemove>
	);
}

function ComboboxPopup({
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.Popup>) {
	return (
		<ComboboxPrimitive.Popup
			data-slot="combobox-popup"
			className={cn(
				"w-(--anchor-width) max-h-[min(var(--available-height),23rem)] max-w-(--available-width) origin-(--transform-origin) overflow-y-auto scroll-pt-2 scroll-pb-2 overscroll-contain rounded-md bg-popover py-2 shadow-md outline-1 outline-border transition-[transform,scale,opacity] data-[ending-style]:scale-95 data-[ending-style]:opacity-0 data-[side=none]:data-[ending-style]:transition-none data-[starting-style]:scale-95 data-[starting-style]:opacity-0 data-[side=none]:data-[starting-style]:scale-100 data-[side=none]:data-[starting-style]:opacity-100 data-[side=none]:data-[starting-style]:transition-none dark:shadow-none",
				className,
			)}
			{...props}
		/>
	);
}

function ComboboxPositioner({
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.Positioner>) {
	return (
		<ComboboxPrimitive.Portal>
			<ComboboxPrimitive.Positioner
				data-slot="combobox-positioner"
				className={cn("outline-none", className)}
				{...props}
			/>
		</ComboboxPrimitive.Portal>
	);
}

function ComboboxArrow(props: React.ComponentProps<typeof ComboboxPrimitive.Arrow>) {
	return <ComboboxPrimitive.Arrow data-slot="combobox-arrow" {...props} />;
}

function ComboboxStatus({
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.Status>) {
	return (
		<ComboboxPrimitive.Status
			data-slot="combobox-status"
			className={cn(
				"px-4.5 py-2 text-sm text-muted-foreground empty:m-0 empty:p-0",
				className,
			)}
			{...props}
		/>
	);
}

function ComboboxEmpty({
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.Empty>) {
	return (
		<ComboboxPrimitive.Empty
			data-slot="combobox-empty"
			className={cn(
				"flex items-center justify-center text-muted-foreground text-sm not-empty:py-1",
				className,
			)}
			{...props}
		/>
	);
}

function ComboboxList(props: React.ComponentProps<typeof ComboboxPrimitive.List>) {
	return <ComboboxPrimitive.List data-slot="combobox-list" {...props} />;
}

function ComboboxRow(props: React.ComponentProps<typeof ComboboxPrimitive.Row>) {
	return <ComboboxPrimitive.Row data-slot="combobox-row" {...props} />;
}

function ComboboxItem({
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.Item>) {
	return (
		<ComboboxPrimitive.Item
			data-slot="combobox-item"
			className={cn(
				"grid cursor-default grid-cols-[0.95rem_1fr] items-center gap-2 py-2 pr-8 pl-4 text-sm leading-4 outline-none select-none data-[highlighted]:relative data-[highlighted]:z-0 data-[highlighted]:text-accent-foreground data-[highlighted]:before:absolute data-[highlighted]:before:inset-x-2 data-[highlighted]:before:inset-y-0 data-[highlighted]:before:-z-1 data-[highlighted]:before:rounded-sm data-[highlighted]:before:bg-accent",
				className,
			)}
			{...props}
		/>
	);
}

function ComboboxItemIndicator({
	className,
	children,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.ItemIndicator>) {
	return (
		<ComboboxPrimitive.ItemIndicator
			data-slot="combobox-item-indicator"
			className={cn("col-start-1", className)}
			{...props}
		>
			{children ?? <CheckIcon className="size-4" />}
		</ComboboxPrimitive.ItemIndicator>
	);
}

function ComboboxSeparator(
	props: React.ComponentProps<typeof ComboboxPrimitive.Separator>,
) {
	return (
		<ComboboxPrimitive.Separator
			data-slot="combobox-separator"
			render={<Separator />}
			{...props}
		/>
	);
}

function ComboboxGroup({
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.Group>) {
	return (
		<ComboboxPrimitive.Group
			data-slot="combobox-group"
			className={cn("mb-3 last:mb-0", className)}
			{...props}
		/>
	);
}

function ComboboxGroupLabel({
	className,
	...props
}: React.ComponentProps<typeof ComboboxPrimitive.GroupLabel>) {
	return (
		<ComboboxPrimitive.GroupLabel
			data-slot="combobox-group-label"
			className={cn(
				"z-1 sticky top-0 bg-background pl-4 text-sm text-muted-foreground py-2",
				className,
			)}
			{...props}
		/>
	);
}

function ComboboxCollection(
	props: React.ComponentProps<typeof ComboboxPrimitive.Collection>,
) {
	return <ComboboxPrimitive.Collection data-slot="combobox-collection" {...props} />;
}

export {
	Combobox,
	ComboboxArrow,
	ComboboxChip,
	ComboboxChipRemove,
	ComboboxChips,
	ComboboxClear,
	ComboboxCollection,
	ComboboxEmpty,
	ComboboxGroup,
	ComboboxGroupLabel,
	ComboboxIcon,
	ComboboxInput,
	ComboboxItem,
	ComboboxItemIndicator,
	ComboboxList,
	ComboboxPopup,
	ComboboxPositioner,
	ComboboxRow,
	ComboboxSeparator,
	ComboboxStatus,
	ComboboxTrigger,
	ComboboxValue,
};
</file>

<file path="src/components/ui/command.tsx">
import { Command as CommandPrimitive } from "cmdk";
import { SearchIcon } from "lucide-react";
import type * as React from "react";

import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogHeader,
	DialogTitle,
} from "~/components/ui/dialog";
import { cn } from "~/utils/cn";

function Command({ className, ...props }: React.ComponentProps<typeof CommandPrimitive>) {
	return (
		<CommandPrimitive
			data-slot="command"
			className={cn(
				"bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
				className,
			)}
			{...props}
		/>
	);
}

function CommandDialog({
	title = "Command Palette",
	description = "Search for a command to run...",
	children,
	className,
	showCloseButton = true,
	...props
}: React.ComponentProps<typeof Dialog> & {
	title?: string;
	description?: string;
	className?: string;
	showCloseButton?: boolean;
}) {
	return (
		<Dialog {...props}>
			<DialogHeader className="sr-only">
				<DialogTitle>{title}</DialogTitle>
				<DialogDescription>{description}</DialogDescription>
			</DialogHeader>
			<DialogContent
				className={cn("overflow-hidden p-0", className)}
				showCloseButton={showCloseButton}
			>
				<Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
					{children}
				</Command>
			</DialogContent>
		</Dialog>
	);
}

function CommandInput({
	className,
	...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
	return (
		<div
			data-slot="command-input-wrapper"
			className="flex h-9 items-center gap-2 border-b px-3"
		>
			<SearchIcon className="size-4 shrink-0 opacity-50" />
			<CommandPrimitive.Input
				data-slot="command-input"
				className={cn(
					"placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				{...props}
			/>
		</div>
	);
}

function CommandList({
	className,
	...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
	return (
		<CommandPrimitive.List
			data-slot="command-list"
			className={cn(
				"max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
				className,
			)}
			{...props}
		/>
	);
}

function CommandEmpty({ ...props }: React.ComponentProps<typeof CommandPrimitive.Empty>) {
	return (
		<CommandPrimitive.Empty
			data-slot="command-empty"
			className="py-6 text-center text-sm"
			{...props}
		/>
	);
}

function CommandGroup({
	className,
	...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
	return (
		<CommandPrimitive.Group
			data-slot="command-group"
			className={cn(
				"text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
				className,
			)}
			{...props}
		/>
	);
}

function CommandSeparator({
	className,
	...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
	return (
		<CommandPrimitive.Separator
			data-slot="command-separator"
			className={cn("bg-border -mx-1 h-px", className)}
			{...props}
		/>
	);
}

function CommandItem({
	className,
	...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
	return (
		<CommandPrimitive.Item
			data-slot="command-item"
			className={cn(
				"data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				className,
			)}
			{...props}
		/>
	);
}

function CommandShortcut({ className, ...props }: React.ComponentProps<"span">) {
	return (
		<span
			data-slot="command-shortcut"
			className={cn(
				"text-muted-foreground ml-auto text-xs tracking-widest",
				className,
			)}
			{...props}
		/>
	);
}

export {
	Command,
	CommandDialog,
	CommandInput,
	CommandList,
	CommandEmpty,
	CommandGroup,
	CommandItem,
	CommandShortcut,
	CommandSeparator,
};
</file>

<file path="src/components/ui/dialog.tsx">
import { Dialog as DialogPrimitive } from "@base-ui-components/react/dialog";
import { XIcon } from "lucide-react";
import type * as React from "react";
import { cn } from "~/utils/cn";

function Dialog({ ...props }: React.ComponentProps<typeof DialogPrimitive.Root>) {
	return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({
	...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
	return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({ ...props }: React.ComponentProps<typeof DialogPrimitive.Portal>) {
	return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({ ...props }: React.ComponentProps<typeof DialogPrimitive.Close>) {
	return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({
	className,
	...props
}: React.ComponentProps<typeof DialogPrimitive.Backdrop>) {
	return (
		<DialogPrimitive.Backdrop
			data-slot="dialog-overlay"
			className={cn(
				"data-[open]:animate-in data-[closed]:animate-out data-[closed]:fade-out-0 data-[open]:fade-in-0 data-[closed]:animation-duration-[200ms] fixed inset-0 z-50 bg-black/50",
				className,
			)}
			{...props}
		/>
	);
}

function DialogContent({
	className,
	children,
	showCloseButton = true,
	...props
}: React.ComponentProps<typeof DialogPrimitive.Popup> & {
	showCloseButton?: boolean;
}) {
	return (
		<DialogPortal data-slot="dialog-portal">
			<DialogOverlay />
			<DialogPrimitive.Popup
				data-slot="dialog-content"
				className={cn(
					"bg-background data-[open]:animate-in data-[open]:fade-in-0 data-[open]:zoom-in-95 data-[closed]:animate-out data-[closed]:fade-out-0 data-[closed]:zoom-out-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
					className,
				)}
				{...props}
			>
				{children}
				{showCloseButton && (
					<DialogPrimitive.Close
						data-slot="dialog-close"
						className="ring-offset-background focus:ring-ring data-[open]:bg-accent data-[open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
					>
						<XIcon />
						<span className="sr-only">Close</span>
					</DialogPrimitive.Close>
				)}
			</DialogPrimitive.Popup>
		</DialogPortal>
	);
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="dialog-header"
			className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
			{...props}
		/>
	);
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="dialog-footer"
			className={cn(
				"flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
				className,
			)}
			{...props}
		/>
	);
}

function DialogTitle({
	className,
	...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
	return (
		<DialogPrimitive.Title
			data-slot="dialog-title"
			className={cn("text-lg leading-none font-semibold", className)}
			{...props}
		/>
	);
}

function DialogDescription({
	className,
	...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
	return (
		<DialogPrimitive.Description
			data-slot="dialog-description"
			className={cn("text-muted-foreground text-sm", className)}
			{...props}
		/>
	);
}

export {
	Dialog,
	DialogClose,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogOverlay,
	DialogPortal,
	DialogTitle,
	DialogTrigger,
};
</file>

<file path="src/components/ui/drawer.tsx">
import type * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";
import { cn } from "~/utils/cn";

function Drawer({ ...props }: React.ComponentProps<typeof DrawerPrimitive.Root>) {
	return <DrawerPrimitive.Root data-slot="drawer" {...props} />;
}

function DrawerTrigger({
	...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
	return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />;
}

function DrawerPortal({ ...props }: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
	return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />;
}

function DrawerClose({ ...props }: React.ComponentProps<typeof DrawerPrimitive.Close>) {
	return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />;
}

function DrawerOverlay({
	className,
	...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
	return (
		<DrawerPrimitive.Overlay
			data-slot="drawer-overlay"
			className={cn(
				"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
				className,
			)}
			{...props}
		/>
	);
}

function DrawerContent({
	className,
	children,
	...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
	return (
		<DrawerPortal data-slot="drawer-portal">
			<DrawerOverlay />
			<DrawerPrimitive.Content
				data-slot="drawer-content"
				className={cn(
					"group/drawer-content bg-background fixed z-50 flex h-auto flex-col",
					"data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg data-[vaul-drawer-direction=top]:border-b",
					"data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg data-[vaul-drawer-direction=bottom]:border-t",
					"data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:border-l data-[vaul-drawer-direction=right]:sm:max-w-sm",
					"data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:border-r data-[vaul-drawer-direction=left]:sm:max-w-sm",
					className,
				)}
				{...props}
			>
				<div className="bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" />
				{children}
			</DrawerPrimitive.Content>
		</DrawerPortal>
	);
}

function DrawerHeader({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="drawer-header"
			className={cn(
				"flex flex-col gap-0.5 p-4 group-data-[vaul-drawer-direction=bottom]/drawer-content:text-center group-data-[vaul-drawer-direction=top]/drawer-content:text-center md:gap-1.5 md:text-left",
				className,
			)}
			{...props}
		/>
	);
}

function DrawerFooter({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="drawer-footer"
			className={cn("mt-auto flex flex-col gap-2 p-4", className)}
			{...props}
		/>
	);
}

function DrawerTitle({
	className,
	...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
	return (
		<DrawerPrimitive.Title
			data-slot="drawer-title"
			className={cn("text-foreground font-semibold", className)}
			{...props}
		/>
	);
}

function DrawerDescription({
	className,
	...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
	return (
		<DrawerPrimitive.Description
			data-slot="drawer-description"
			className={cn("text-muted-foreground text-sm", className)}
			{...props}
		/>
	);
}

export {
	Drawer,
	DrawerPortal,
	DrawerOverlay,
	DrawerTrigger,
	DrawerClose,
	DrawerContent,
	DrawerHeader,
	DrawerFooter,
	DrawerTitle,
	DrawerDescription,
};
</file>

<file path="src/components/ui/dropdown-menu.tsx">
import { Menu as MenuPrimitive } from "@base-ui-components/react/menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
import type * as React from "react";
import { cn } from "~/utils/cn";

function DropdownMenu({ ...props }: React.ComponentProps<typeof MenuPrimitive.Root>) {
	return <MenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({
	...props
}: React.ComponentProps<typeof MenuPrimitive.Portal>) {
	return <MenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />;
}

function DropdownMenuTrigger({
	...props
}: React.ComponentProps<typeof MenuPrimitive.Trigger>) {
	return <MenuPrimitive.Trigger data-slot="dropdown-menu-trigger" {...props} />;
}

function DropdownMenuPositioner({
	sideOffset = 4,
	...props
}: React.ComponentProps<typeof MenuPrimitive.Positioner>) {
	return (
		<MenuPrimitive.Portal>
			<MenuPrimitive.Positioner
				data-slot="dropdown-menu-positioner"
				sideOffset={sideOffset}
				{...props}
			/>
		</MenuPrimitive.Portal>
	);
}

function DropdownMenuContent({
	className,
	...props
}: React.ComponentProps<typeof MenuPrimitive.Popup>) {
	return (
		<MenuPrimitive.Popup
			data-slot="dropdown-menu-content"
			className={cn(
				"bg-popover text-popover-foreground data-[open]:animate-in data-[closed]:animate-out data-[closed]:fade-out-0 data-[open]:fade-in-0 data-[closed]:zoom-out-95 data-[open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--available-height) min-w-[8rem] origin-(--transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
				className,
			)}
			{...props}
		/>
	);
}

function DropdownMenuGroup({
	...props
}: React.ComponentProps<typeof MenuPrimitive.Group>) {
	return <MenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />;
}

function DropdownMenuItem({
	className,
	inset,
	variant = "default",
	...props
}: React.ComponentProps<typeof MenuPrimitive.Item> & {
	inset?: boolean;
	variant?: "default" | "destructive";
}) {
	return (
		<MenuPrimitive.Item
			data-slot="dropdown-menu-item"
			data-inset={inset}
			data-variant={variant}
			className={cn(
				"focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				className,
			)}
			{...props}
		/>
	);
}

function DropdownMenuCheckboxItem({
	className,
	children,
	checked,
	...props
}: React.ComponentProps<typeof MenuPrimitive.CheckboxItem>) {
	return (
		<MenuPrimitive.CheckboxItem
			data-slot="dropdown-menu-checkbox-item"
			className={cn(
				"focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				className,
			)}
			checked={checked}
			{...props}
		>
			<span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
				<MenuPrimitive.CheckboxItemIndicator>
					<CheckIcon className="size-4" />
				</MenuPrimitive.CheckboxItemIndicator>
			</span>
			{children}
		</MenuPrimitive.CheckboxItem>
	);
}

function DropdownMenuRadioGroup({
	...props
}: React.ComponentProps<typeof MenuPrimitive.RadioGroup>) {
	return <MenuPrimitive.RadioGroup data-slot="dropdown-menu-radio-group" {...props} />;
}

function DropdownMenuRadioItem({
	className,
	children,
	...props
}: React.ComponentProps<typeof MenuPrimitive.RadioItem>) {
	return (
		<MenuPrimitive.RadioItem
			data-slot="dropdown-menu-radio-item"
			className={cn(
				"focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				className,
			)}
			{...props}
		>
			<span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
				<MenuPrimitive.RadioItemIndicator>
					<CircleIcon className="size-2 fill-current" />
				</MenuPrimitive.RadioItemIndicator>
			</span>
			{children}
		</MenuPrimitive.RadioItem>
	);
}

function DropdownMenuLabel({
	className,
	inset,
	...props
}: React.ComponentProps<typeof MenuPrimitive.GroupLabel> & {
	inset?: boolean;
}) {
	return (
		<MenuPrimitive.GroupLabel
			data-slot="dropdown-menu-label"
			data-inset={inset}
			className={cn("px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", className)}
			{...props}
		/>
	);
}

function DropdownMenuSeparator({
	className,
	...props
}: React.ComponentProps<typeof MenuPrimitive.Separator>) {
	return (
		<MenuPrimitive.Separator
			data-slot="dropdown-menu-separator"
			className={cn("bg-border -mx-1 my-1 h-px", className)}
			{...props}
		/>
	);
}

function DropdownMenuShortcut({ className, ...props }: React.ComponentProps<"span">) {
	return (
		<span
			data-slot="dropdown-menu-shortcut"
			className={cn(
				"text-muted-foreground ml-auto text-xs tracking-widest",
				className,
			)}
			{...props}
		/>
	);
}

function DropdownMenuSub({
	...props
}: React.ComponentProps<typeof MenuPrimitive.SubmenuRoot>) {
	return <MenuPrimitive.SubmenuRoot data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
	className,
	inset,
	children,
	...props
}: React.ComponentProps<typeof MenuPrimitive.SubmenuTrigger> & {
	inset?: boolean;
}) {
	return (
		<MenuPrimitive.SubmenuTrigger
			data-slot="dropdown-menu-sub-trigger"
			data-inset={inset}
			className={cn(
				"focus:bg-accent focus:text-accent-foreground data-[open]:bg-accent data-[open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
				className,
			)}
			{...props}
		>
			{children}
			<ChevronRightIcon className="ml-auto size-4" />
		</MenuPrimitive.SubmenuTrigger>
	);
}

function DropdownMenuSubContent({
	className,
	...props
}: React.ComponentProps<typeof MenuPrimitive.Popup>) {
	return (
		<MenuPrimitive.Popup
			data-slot="dropdown-menu-sub-content"
			className={cn(
				"bg-popover text-popover-foreground data-[open]:animate-in data-[closed]:animate-out data-[closed]:fade-out-0 data-[open]:fade-in-0 data-[closed]:zoom-out-95 data-[open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
				className,
			)}
			{...props}
		/>
	);
}

export {
	DropdownMenu,
	DropdownMenuPortal,
	DropdownMenuTrigger,
	DropdownMenuPositioner,
	DropdownMenuContent,
	DropdownMenuGroup,
	DropdownMenuLabel,
	DropdownMenuItem,
	DropdownMenuCheckboxItem,
	DropdownMenuRadioGroup,
	DropdownMenuRadioItem,
	DropdownMenuSeparator,
	DropdownMenuShortcut,
	DropdownMenuSub,
	DropdownMenuSubTrigger,
	DropdownMenuSubContent,
};
</file>

<file path="src/components/ui/entity-links-table.tsx">
import {
	type ColumnDef,
	type ColumnFiltersState,
	flexRender,
	getCoreRowModel,
	getFilteredRowModel,
	getPaginationRowModel,
	getSortedRowModel,
	type SortingState,
	useReactTable,
	type VisibilityState,
} from "@tanstack/react-table";
import { ChevronDown } from "lucide-react";
import * as React from "react";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
	DropdownMenu,
	DropdownMenuCheckboxItem,
	DropdownMenuContent,
	DropdownMenuPortal,
	DropdownMenuPositioner,
	DropdownMenuTrigger,
} from "~/components/ui/dropdown-menu";
import { EntityLinkButton } from "~/components/ui/entity-link-button";
import { Input } from "~/components/ui/input";
import {
	Table,
	TableBody,
	TableCell,
	TableHead,
	TableHeader,
	TableRow,
} from "~/components/ui/table";
import type { EntityType } from "~/types";
import type { EntityLink } from "~/utils/linkHelpers";
import { DeleteLink } from "../links/delete-link";
import { Link } from "./link";
import { UpdateLinkDialog } from "./update-link-dialog";

interface EntityLinksTableProps {
	links: EntityLink[];
	gameId: string;
	sourceId: string;
	sourceType: EntityType;
}

export function EntityLinksTable({
	links,
	gameId,
	sourceId,
	sourceType,
}: EntityLinksTableProps) {
	const [sorting, setSorting] = React.useState<SortingState>([]);
	const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([]);
	const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>({});
	const [searchQuery, setSearchQuery] = React.useState("");
	const [typeFilter, setTypeFilter] = React.useState<string>("all");

	const columns: ColumnDef<EntityLink>[] = [
		{
			accessorKey: "name",
			header: "Name",
			cell: ({ row }) => {
				const type = row.original.type;
				const id = row.original.id;
				return (
					<Link
						to={`/games/${gameId}/${type}s/${id}` as string}
						className="font-medium hover:underline"
					>
						{row.getValue("name")}
					</Link>
				);
			},
		},
		{
			accessorKey: "type",
			header: "Type",
			cell: ({ row }) => (
				<Badge variant="secondary" className="capitalize">
					{row.getValue("type")}
				</Badge>
			),
		},
		{
			accessorKey: "description_meta",
			header: "Description",
			cell: ({ row }) => {
				return <div className="text-sm">{row.getValue("description_meta")}</div>;
			},
		},
		{
			accessorKey: "relationship_type",
			header: "Relationship",
			cell: ({ row }) => {
				return <div className="text-sm">{row.getValue("relationship_type")}</div>;
			},
		},
		{
			accessorKey: "is_active",
			header: "Active",
			cell: ({ row }) => {
				return (
					<div className="text-sm">
						{row.getValue("is_active") ? "Yes" : "No"}
					</div>
				);
			},
		},
		{
			id: "actions",
			enableHiding: false,
			cell: ({ row }) => {
				return <EntityLinkButton entity={row.original} />;
			},
		},
		{
			id: "edit",
			enableHiding: false,
			cell: ({ row }) => {
				return (
					<UpdateLinkDialog
						link={row.original}
						gameId={gameId}
						sourceId={sourceId}
						sourceType={sourceType}
					/>
				);
			},
		},
		{
			id: "delete",
			enableHiding: false,
			cell: ({ row }) => {
				return (
					<DeleteLink
						gameId={gameId}
						sourceId={sourceId}
						sourceType={sourceType}
						targetId={row.original.id}
						targetType={row.getValue("type")}
					/>
				);
			},
		},
	];

	const table = useReactTable({
		data: links,
		columns,
		onSortingChange: setSorting,
		onColumnFiltersChange: setColumnFilters,
		getCoreRowModel: getCoreRowModel(),
		getPaginationRowModel: getPaginationRowModel(),
		getSortedRowModel: getSortedRowModel(),
		getFilteredRowModel: getFilteredRowModel(),
		onColumnVisibilityChange: setColumnVisibility,
		state: {
			sorting,
			columnFilters,
			columnVisibility,
		},
		initialState: {
			pagination: {
				pageSize: 5,
			},
		},
	});

	const uniqueTypes = React.useMemo(() => {
		const types = [...new Set(links.map((link) => link.type))];
		return types.sort();
	}, [links]);

	React.useEffect(() => {
		table.getColumn("name")?.setFilterValue(searchQuery);
	}, [searchQuery, table]);

	React.useEffect(() => {
		table.getColumn("type")?.setFilterValue(typeFilter === "all" ? "" : typeFilter);
	}, [typeFilter, table]);

	return (
		<div className="w-full">
			<div className="flex items-center gap-4 py-4">
				<Input
					placeholder="Filter links..."
					value={searchQuery}
					onChange={(event) => setSearchQuery(event.target.value)}
					className="max-w-sm"
				/>
				<DropdownMenu>
					<DropdownMenuTrigger
						render={
							<Button variant="outline">
								Type: {typeFilter === "all" ? "All" : typeFilter}
								<ChevronDown className="ml-2 h-4 w-4" />
							</Button>
						}
					></DropdownMenuTrigger>
					<DropdownMenuPortal>
						<DropdownMenuPositioner>
							<DropdownMenuContent>
								<DropdownMenuCheckboxItem
									checked={typeFilter === "all"}
									onCheckedChange={() => setTypeFilter("all")}
								>
									All Types
								</DropdownMenuCheckboxItem>
								{uniqueTypes.map((type) => (
									<DropdownMenuCheckboxItem
										key={type}
										checked={typeFilter === type}
										onCheckedChange={() => setTypeFilter(type)}
										className="capitalize"
									>
										{type}
									</DropdownMenuCheckboxItem>
								))}
							</DropdownMenuContent>
						</DropdownMenuPositioner>
					</DropdownMenuPortal>
				</DropdownMenu>
				<DropdownMenu>
					<DropdownMenuTrigger
						render={
							<Button variant="outline" className="ml-auto">
								Columns <ChevronDown className="ml-2 h-4 w-4" />
							</Button>
						}
					></DropdownMenuTrigger>
					<DropdownMenuPortal>
						<DropdownMenuPositioner>
							<DropdownMenuContent>
								{table
									.getAllColumns()
									.filter((column) => column.getCanHide())
									.map((column) => {
										return (
											<DropdownMenuCheckboxItem
												key={column.id}
												className="capitalize"
												checked={column.getIsVisible()}
												onCheckedChange={(value) =>
													column.toggleVisibility(!!value)
												}
											>
												{column.id}
											</DropdownMenuCheckboxItem>
										);
									})}
							</DropdownMenuContent>
						</DropdownMenuPositioner>
					</DropdownMenuPortal>
				</DropdownMenu>
			</div>
			<div className="overflow-hidden rounded-md border">
				<Table>
					<TableHeader>
						{table.getHeaderGroups().map((headerGroup) => (
							<TableRow key={headerGroup.id}>
								{headerGroup.headers.map((header) => {
									return (
										<TableHead key={header.id}>
											{header.isPlaceholder
												? null
												: flexRender(
														header.column.columnDef.header,
														header.getContext(),
													)}
										</TableHead>
									);
								})}
							</TableRow>
						))}
					</TableHeader>
					<TableBody>
						{table.getRowModel().rows?.length ? (
							table.getRowModel().rows.map((row) => (
								<TableRow
									key={row.id}
									data-state={row.getIsSelected() && "selected"}
								>
									{row.getVisibleCells().map((cell) => (
										<TableCell key={cell.id}>
											{flexRender(
												cell.column.columnDef.cell,
												cell.getContext(),
											)}
										</TableCell>
									))}
								</TableRow>
							))
						) : (
							<TableRow>
								<TableCell
									colSpan={columns.length}
									className="h-24 text-center"
								>
									No links found.
								</TableCell>
							</TableRow>
						)}
					</TableBody>
				</Table>
			</div>
			<div className="flex items-center justify-end space-x-2 py-4">
				<div className="flex-1 text-sm text-muted-foreground">
					{table.getFilteredRowModel().rows.length} link(s) total.
				</div>
				<div className="space-x-2">
					<Button
						variant="outline"
						size="sm"
						onClick={() => table.previousPage()}
						disabled={!table.getCanPreviousPage()}
					>
						Previous
					</Button>
					<Button
						variant="outline"
						size="sm"
						onClick={() => table.nextPage()}
						disabled={!table.getCanNextPage()}
					>
						Next
					</Button>
				</div>
			</div>
		</div>
	);
}
</file>

<file path="src/components/ui/input.tsx">
import { Input as InputPrimitive } from "@base-ui-components/react/input";
import type * as React from "react";
import { cn } from "~/utils/cn";

function Input({
	className,
	type,
	...props
}: React.ComponentProps<typeof InputPrimitive>) {
	return (
		<InputPrimitive
			type={type}
			data-slot="input"
			className={cn(
				"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
				"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
				"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
				className,
			)}
			{...props}
		/>
	);
}

export { Input };
</file>

<file path="src/components/ui/label.tsx">
/** biome-ignore-all lint/a11y/noLabelWithoutControl: Provided via props */
import type * as React from "react";
import { cn } from "~/utils/cn";

function Label({ className, ...props }: React.ComponentProps<"label">) {
	return (
		<label
			data-slot="label"
			className={cn(
				"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
				className,
			)}
			{...props}
		/>
	);
}

export { Label };
</file>

<file path="src/components/ui/menubar.tsx">
import { Menu as MenuPrimitive } from "@base-ui-components/react/menu";
import { Menubar as MenubarPrimitive } from "@base-ui-components/react/menubar";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
import type * as React from "react";
import { cn } from "~/utils/cn";

function Menubar({ className, ...props }: React.ComponentProps<typeof MenubarPrimitive>) {
	return (
		<MenubarPrimitive
			data-slot="menubar"
			className={cn(
				"bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs",
				className,
			)}
			{...props}
		/>
	);
}

function MenubarMenu({ ...props }: React.ComponentProps<typeof MenuPrimitive.Root>) {
	return <MenuPrimitive.Root data-slot="menubar-menu" {...props} />;
}

function MenubarGroup({ ...props }: React.ComponentProps<typeof MenuPrimitive.Group>) {
	return <MenuPrimitive.Group data-slot="menubar-group" {...props} />;
}

function MenubarPortal({ ...props }: React.ComponentProps<typeof MenuPrimitive.Portal>) {
	return <MenuPrimitive.Portal data-slot="menubar-portal" {...props} />;
}

function MenubarRadioGroup({
	...props
}: React.ComponentProps<typeof MenuPrimitive.RadioGroup>) {
	return <MenuPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />;
}

function MenubarTrigger({
	className,
	...props
}: React.ComponentProps<typeof MenuPrimitive.Trigger>) {
	return (
		<MenuPrimitive.Trigger
			data-slot="menubar-trigger"
			className={cn(
				"focus:bg-accent focus:text-accent-foreground data-[popup-open]:bg-accent data-[open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none",
				className,
			)}
			{...props}
		/>
	);
}

function MenubarPositioner({
	align = "start",
	alignOffset = -4,
	sideOffset = 8,
	...props
}: React.ComponentProps<typeof MenuPrimitive.Positioner>) {
	return (
		<MenubarPortal>
			<MenuPrimitive.Positioner
				data-slot="menubar-positioner"
				align={align}
				alignOffset={alignOffset}
				sideOffset={sideOffset}
				{...props}
			/>
		</MenubarPortal>
	);
}

function MenubarContent({
	className,
	...props
}: React.ComponentProps<typeof MenuPrimitive.Popup>) {
	return (
		<MenuPrimitive.Popup
			data-slot="menubar-content"
			className={cn(
				"bg-popover text-popover-foreground data-[open]:animate-in data-[closed]:animate-out data-[closed]:fade-out-0 data-[open]:fade-in-0 data-[closed]:zoom-out-95 data-[open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] origin-(--transform-origin) overflow-hidden rounded-md border p-1 shadow-md",
				className,
			)}
			{...props}
		/>
	);
}

function MenubarItem({
	className,
	inset,
	variant = "default",
	...props
}: React.ComponentProps<typeof MenuPrimitive.Item> & {
	inset?: boolean;
	variant?: "default" | "destructive";
}) {
	return (
		<MenuPrimitive.Item
			data-slot="menubar-item"
			data-inset={inset}
			data-variant={variant}
			className={cn(
				"focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				className,
			)}
			{...props}
		/>
	);
}

function MenubarCheckboxItem({
	className,
	children,
	checked,
	...props
}: React.ComponentProps<typeof MenuPrimitive.CheckboxItem>) {
	return (
		<MenuPrimitive.CheckboxItem
			data-slot="menubar-checkbox-item"
			className={cn(
				"focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				className,
			)}
			checked={checked}
			{...props}
		>
			<span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
				<MenuPrimitive.CheckboxItemIndicator>
					<CheckIcon className="size-4" />
				</MenuPrimitive.CheckboxItemIndicator>
			</span>
			{children}
		</MenuPrimitive.CheckboxItem>
	);
}

function MenubarRadioItem({
	className,
	children,
	...props
}: React.ComponentProps<typeof MenuPrimitive.RadioItem>) {
	return (
		<MenuPrimitive.RadioItem
			data-slot="menubar-radio-item"
			className={cn(
				"focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				className,
			)}
			{...props}
		>
			<span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
				<MenuPrimitive.RadioItemIndicator>
					<CircleIcon className="size-2 fill-current" />
				</MenuPrimitive.RadioItemIndicator>
			</span>
			{children}
		</MenuPrimitive.RadioItem>
	);
}

function MenubarLabel({
	className,
	inset,
	...props
}: React.ComponentProps<typeof MenuPrimitive.GroupLabel> & {
	inset?: boolean;
}) {
	return (
		<MenuPrimitive.GroupLabel
			data-slot="menubar-label"
			data-inset={inset}
			className={cn("px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", className)}
			{...props}
		/>
	);
}

function MenubarSeparator({
	className,
	...props
}: React.ComponentProps<typeof MenuPrimitive.Separator>) {
	return (
		<MenuPrimitive.Separator
			data-slot="menubar-separator"
			className={cn("bg-border -mx-1 my-1 h-px", className)}
			{...props}
		/>
	);
}

function MenubarShortcut({ className, ...props }: React.ComponentProps<"span">) {
	return (
		<span
			data-slot="menubar-shortcut"
			className={cn(
				"text-muted-foreground ml-auto text-xs tracking-widest",
				className,
			)}
			{...props}
		/>
	);
}

function MenubarSub({
	...props
}: React.ComponentProps<typeof MenuPrimitive.SubmenuRoot>) {
	return <MenuPrimitive.SubmenuRoot data-slot="menubar-sub" {...props} />;
}

function MenubarSubTrigger({
	className,
	inset,
	children,
	...props
}: React.ComponentProps<typeof MenuPrimitive.SubmenuTrigger> & {
	inset?: boolean;
}) {
	return (
		<MenuPrimitive.SubmenuTrigger
			data-slot="menubar-sub-trigger"
			data-inset={inset}
			className={cn(
				"focus:bg-accent focus:text-accent-foreground data-[open]:bg-accent data-[open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8",
				className,
			)}
			{...props}
		>
			{children}
			<ChevronRightIcon className="ml-auto h-4 w-4" />
		</MenuPrimitive.SubmenuTrigger>
	);
}

export {
	Menubar,
	MenubarCheckboxItem,
	MenubarContent,
	MenubarGroup,
	MenubarItem,
	MenubarLabel,
	MenubarMenu,
	MenubarPortal,
	MenubarPositioner,
	MenubarRadioGroup,
	MenubarRadioItem,
	MenubarSeparator,
	MenubarShortcut,
	MenubarSub,
	MenubarSubTrigger,
	MenubarTrigger,
};
</file>

<file path="src/components/ui/popover.tsx">
import { Popover as PopoverPrimitive } from "@base-ui-components/react/popover";
import type * as React from "react";
import { cn } from "~/utils/cn";

function Popover({ ...props }: React.ComponentProps<typeof PopoverPrimitive.Root>) {
	return <PopoverPrimitive.Root data-slot="popover" {...props} />;
}

function PopoverTrigger({
	...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
	return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />;
}

function PopoverPositioner({
	sideOffset = 4,
	...props
}: React.ComponentProps<typeof PopoverPrimitive.Positioner>) {
	return (
		<PopoverPrimitive.Portal>
			<PopoverPrimitive.Positioner
				data-slot="popover-positioner"
				sideOffset={sideOffset}
				{...props}
			/>
		</PopoverPrimitive.Portal>
	);
}

function PopoverContent({
	className,
	...props
}: React.ComponentProps<typeof PopoverPrimitive.Popup>) {
	return (
		<PopoverPrimitive.Popup
			data-slot="popover-content"
			className={cn(
				"bg-popover text-popover-foreground data-[open]:animate-in data-[closed]:animate-out data-[closed]:fade-out-0 data-[open]:fade-in-0 data-[closed]:zoom-out-95 data-[open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
				className,
			)}
			{...props}
		/>
	);
}

function PopoverAnchor({
	...props
}: React.ComponentProps<typeof PopoverPrimitive.Arrow>) {
	return <PopoverPrimitive.Arrow data-slot="popover-anchor" {...props} />;
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor, PopoverPositioner };
</file>

<file path="src/components/ui/scroll-area.tsx">
import { ScrollArea as ScrollAreaPrimitive } from "@base-ui-components/react/scroll-area";
import type * as React from "react";
import { cn } from "~/utils/cn";

function ScrollArea({
	className,
	children,
	...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
	return (
		<ScrollAreaPrimitive.Root
			data-slot="scroll-area"
			className={cn("relative", className)}
			{...props}
		>
			<ScrollAreaPrimitive.Viewport
				data-slot="scroll-area-viewport"
				className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
			>
				<ScrollAreaPrimitive.Content>{children}</ScrollAreaPrimitive.Content>
			</ScrollAreaPrimitive.Viewport>
			<ScrollBar />
			<ScrollAreaPrimitive.Corner />
		</ScrollAreaPrimitive.Root>
	);
}

function ScrollBar({
	className,
	orientation = "vertical",
	...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Scrollbar>) {
	return (
		<ScrollAreaPrimitive.Scrollbar
			data-slot="scroll-area-scrollbar"
			orientation={orientation}
			className={cn(
				"flex touch-none p-px transition-[colors,opacity] select-none opacity-0 data-[hovering]:opacity-100 data-[scrolling]:opacity-100 duration-150 delay-300 data-[hovering]:duration-75 data-[scrolling]:duration-75  data-[hovering]:delay-0 data-[scrolling]:delay-0",
				orientation === "vertical" &&
					"h-full w-2.5 border-l border-l-transparent",
				orientation === "horizontal" &&
					"h-2.5 flex-col border-t border-t-transparent",
				className,
			)}
			{...props}
		>
			<ScrollAreaPrimitive.Thumb
				data-slot="scroll-area-thumb"
				className="bg-border relative flex-1 rounded-full"
			/>
		</ScrollAreaPrimitive.Scrollbar>
	);
}

export { ScrollArea, ScrollBar };
</file>

<file path="src/components/ui/separator.tsx">
import { Separator as SeparatorPrimitive } from "@base-ui-components/react/separator";
import type * as React from "react";
import { cn } from "~/utils/cn";

function Separator({
	className,
	...props
}: React.ComponentProps<typeof SeparatorPrimitive>) {
	return (
		<SeparatorPrimitive
			data-slot="separator"
			className={cn(
				"bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
				className,
			)}
			{...props}
		/>
	);
}

export { Separator };
</file>

<file path="src/components/ui/sonner.tsx">
import { useTheme } from "next-themes";
import { Toaster as Sonner, type ToasterProps } from "sonner";

const Toaster = ({ ...props }: ToasterProps) => {
	const { theme = "system" } = useTheme();

	return (
		<Sonner
			theme={theme as ToasterProps["theme"]}
			className="toaster group"
			style={
				{
					"--normal-bg": "var(--popover)",
					"--normal-text": "var(--popover-foreground)",
					"--normal-border": "var(--border)",
				} as React.CSSProperties
			}
			{...props}
		/>
	);
};

export { Toaster };
</file>

<file path="src/components/ui/table.tsx">
import type * as React from "react";
import { cn } from "~/utils/cn";

function Table({ className, ...props }: React.ComponentProps<"table">) {
	return (
		<div data-slot="table-container" className="relative w-full overflow-x-auto">
			<table
				data-slot="table"
				className={cn("w-full caption-bottom text-sm", className)}
				{...props}
			/>
		</div>
	);
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
	return (
		<thead
			data-slot="table-header"
			className={cn("[&_tr]:border-b", className)}
			{...props}
		/>
	);
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
	return (
		<tbody
			data-slot="table-body"
			className={cn("[&_tr:last-child]:border-0", className)}
			{...props}
		/>
	);
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
	return (
		<tfoot
			data-slot="table-footer"
			className={cn(
				"bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
				className,
			)}
			{...props}
		/>
	);
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
	return (
		<tr
			data-slot="table-row"
			className={cn(
				"hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
				className,
			)}
			{...props}
		/>
	);
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
	return (
		<th
			data-slot="table-head"
			className={cn(
				"text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
				className,
			)}
			{...props}
		/>
	);
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
	return (
		<td
			data-slot="table-cell"
			className={cn(
				"p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
				className,
			)}
			{...props}
		/>
	);
}

function TableCaption({ className, ...props }: React.ComponentProps<"caption">) {
	return (
		<caption
			data-slot="table-caption"
			className={cn("text-muted-foreground mt-4 text-sm", className)}
			{...props}
		/>
	);
}

export {
	Table,
	TableHeader,
	TableBody,
	TableFooter,
	TableHead,
	TableRow,
	TableCell,
	TableCaption,
};
</file>

<file path="src/components/ui/tabs.tsx">
import { Tabs as TabsPrimitive } from "@base-ui-components/react/tabs";
import type * as React from "react";
import { cn } from "~/utils/cn";

function Tabs({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Root>) {
	return (
		<TabsPrimitive.Root
			data-slot="tabs"
			className={cn("flex flex-col gap-2", className)}
			{...props}
		/>
	);
}

function TabsList({
	className,
	...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
	return (
		<TabsPrimitive.List
			data-slot="tabs-list"
			className={cn(
				"bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
				className,
			)}
			{...props}
		/>
	);
}

function TabsTrigger({
	className,
	...props
}: React.ComponentProps<typeof TabsPrimitive.Tab>) {
	return (
		<TabsPrimitive.Tab
			data-slot="tabs-trigger"
			className={cn(
				"data-[selected]:bg-background dark:data-[selected]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[selected]:border-input dark:data-[selected]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[selected]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				className,
			)}
			{...props}
		/>
	);
}

function TabsContent({
	className,
	...props
}: React.ComponentProps<typeof TabsPrimitive.Panel>) {
	return (
		<TabsPrimitive.Panel
			data-slot="tabs-content"
			className={cn("flex-1 outline-none", className)}
			{...props}
		/>
	);
}

export { Tabs, TabsList, TabsTrigger, TabsContent };
</file>

<file path="src/components/ui/textarea.tsx">
import type * as React from "react";
import { cn } from "~/utils/cn";

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
	return (
		<textarea
			data-slot="textarea"
			className={cn(
				"border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
				className,
			)}
			{...props}
		/>
	);
}

export { Textarea };
</file>

<file path="src/components/ui/toggle.tsx">
import { Toggle as TogglePrimitive } from "@base-ui-components/react/toggle";
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";
import { cn } from "~/utils/cn";

const toggleVariants = cva(
	"inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[pressed]:bg-accent data-[pressed]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
	{
		variants: {
			variant: {
				default: "bg-transparent",
				outline:
					"border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
			},
			size: {
				default: "h-9 px-2 min-w-9",
				sm: "h-8 px-1.5 min-w-8",
				lg: "h-10 px-2.5 min-w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

function Toggle({
	className,
	variant,
	size,
	...props
}: React.ComponentProps<typeof TogglePrimitive> & VariantProps<typeof toggleVariants>) {
	return (
		<TogglePrimitive
			data-slot="toggle"
			className={cn(toggleVariants({ variant, size, className }))}
			{...props}
		/>
	);
}

export { Toggle, toggleVariants };
</file>

<file path="src/components/ui/tooltip.tsx">
import { Tooltip as TooltipPrimitive } from "@base-ui-components/react/tooltip";
import type * as React from "react";
import { cn } from "~/utils/cn";

function TooltipProvider({
	delay = 0,
	...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
	return (
		<TooltipPrimitive.Provider
			data-slot="tooltip-provider"
			delay={delay}
			{...props}
		/>
	);
}

function Tooltip({ ...props }: React.ComponentProps<typeof TooltipPrimitive.Root>) {
	return (
		<TooltipProvider>
			<TooltipPrimitive.Root data-slot="tooltip" {...props} />
		</TooltipProvider>
	);
}

function TooltipTrigger({
	...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
	return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}

function TooltipPositioner({
	className,
	...props
}: React.ComponentProps<typeof TooltipPrimitive.Positioner>) {
	return (
		<TooltipPrimitive.Portal>
			<TooltipPrimitive.Positioner
				data-slot="tooltip-positioner"
				sideOffset={8}
				className={cn("z-50", className)}
				{...props}
			/>
		</TooltipPrimitive.Portal>
	);
}

function TooltipContent({
	className,
	children,
	...props
}: React.ComponentProps<typeof TooltipPrimitive.Popup>) {
	return (
		<TooltipPrimitive.Popup
			data-slot="tooltip-content"
			className={cn(
				"bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[closed]:animate-out data-[closed]:fade-out-0 data-[closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
				className,
			)}
			{...props}
		>
			{children}
			<TooltipArrow />
		</TooltipPrimitive.Popup>
	);
}

function TooltipArrow({
	className,
	...props
}: React.ComponentProps<typeof TooltipPrimitive.Arrow>) {
	return (
		<TooltipPrimitive.Arrow
			data-slot="tooltip-arrow"
			className={cn(
				"bg-primary fill-primary z-50 size-2.5 rotate-45 rounded-[2px]",
				"data-[side=bottom]:-translate-y-1/2 data-[side=bottom]:top-px",
				"data-[side=top]:translate-y-1/2 data-[side=top]:bottom-px",
				"data-[side=left]:translate-x-1/2 data-[side=left]:right-px",
				"data-[side=right]:-translate-x-1/2 data-[side=right]:left-px",
				className,
			)}
			{...props}
		/>
	);
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider, TooltipPositioner };
</file>

<file path="src/components/auth.tsx">
import { Button } from "./ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";
import { FormField } from "./ui/composite/form-field";

export function Auth({
	actionText,
	onSubmit,
	status,
	afterSubmit,
}: {
	actionText: string;
	onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
	status: "pending" | "idle" | "success" | "error";
	afterSubmit?: React.ReactNode;
}) {
	return (
		<Card>
			<CardHeader>
				<CardTitle>{actionText}</CardTitle>
			</CardHeader>
			<CardContent>
				<form
					onSubmit={(e) => {
						e.preventDefault();
						onSubmit(e);
					}}
					className="space-y-4"
				>
					<FormField id="email" label="Email" name="email" type="email" />
					<FormField
						id="password"
						label="Password"
						name="password"
						type="password"
					/>
					<Button type="submit" disabled={status === "pending"}>
						{status === "pending" ? "..." : actionText}
					</Button>
					{afterSubmit ? afterSubmit : null}
				</form>
			</CardContent>
		</Card>
	);
}
</file>

<file path="src/components/edit-entity-dialog.tsx">
import type { Character, Location, Note, Quest } from "~/api/types.gen";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "./ui/dialog";

interface EditEntityDialogProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
	children: React.ReactNode;
	entity: Character | Location | Quest | Note;
}

export function EditEntityDialog({
	isOpen,
	setIsOpen,
	children,
	entity,
}: EditEntityDialogProps) {
	return (
		<Dialog open={isOpen} onOpenChange={setIsOpen}>
			<DialogContent>
				<DialogHeader>
					<DialogTitle>{`Edit ${entity.name}`}</DialogTitle>
				</DialogHeader>
				{children}
			</DialogContent>
		</Dialog>
	);
}
</file>

<file path="src/components/entity-grid.tsx">
import { Edit, Eye, Plus, Trash2 } from "lucide-react";
import type { Character, Faction, Location, Note, Quest } from "~/api/types.gen";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import type { EntityType } from "~/types";

export type Entity = Character | Faction | Location | Note | Quest;

interface EntityGridProps<T extends Entity> {
	entities: T[];
	entityType: EntityType;
	entityIcon: string;
	onCreateNew: () => void;
	onView: (entity: T) => void;
	onEdit: (entity: T) => void;
	onDelete: (entity: T) => void;
	getEntitySpecificInfo?: (entity: T) => React.ReactNode;
}

export function EntityGrid<T extends Entity>({
	entities,
	entityType,
	entityIcon,
	onCreateNew,
	onView,
	onEdit,
	onDelete,
	getEntitySpecificInfo,
}: EntityGridProps<T>) {
	if (entities.length === 0) {
		return (
			<Card>
				<CardContent className="pt-6">
					<div className="text-center py-8">
						<div className="text-4xl mb-4">{entityIcon}</div>
						<h3 className="text-lg font-semibold mb-2">
							No {entityType}s found
						</h3>
						<Button onClick={onCreateNew}>
							<Plus className="w-4 h-4 mr-2" />
							Create {entityType}
						</Button>
					</div>
				</CardContent>
			</Card>
		);
	}

	return (
		<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
			{entities.map((entity) => (
				<Card key={entity.id} className="hover:shadow-md transition-shadow">
					<CardHeader className="pb-3">
						<div className="flex items-start justify-between">
							<CardTitle className="text-lg line-clamp-2">
								{"name" in entity ? entity.name : "Untitled"}
							</CardTitle>
							<div className="flex gap-1 ml-2">
								<Button
									variant="ghost"
									size="icon"
									onClick={() => onView(entity)}
								>
									<Eye className="w-4 h-4" />
								</Button>
								<Button
									variant="ghost"
									size="icon"
									onClick={() => onEdit(entity)}
								>
									<Edit className="w-4 h-4" />
								</Button>
								<Button
									variant="ghost"
									size="icon"
									onClick={() => onDelete(entity)}
									className="text-destructive hover:text-destructive"
								>
									<Trash2 className="w-4 h-4" />
								</Button>
							</div>
						</div>
						{getEntitySpecificInfo?.(entity)}
					</CardHeader>
					<CardContent>
						{"content" in entity && entity.content ? (
							<p className="text-sm text-muted-foreground line-clamp-3 mb-3">
								{(("content" in entity && entity.content) || "")
									.replace(/[#*`[\]]/g, "")
									.substring(0, 150)}
								...
							</p>
						) : null}
					</CardContent>
				</Card>
			))}
		</div>
	);
}
</file>

<file path="src/components/error.tsx">
import { ErrorComponent } from "@tanstack/react-router";
import { isApiError } from "~/utils/api-errors";
import { parseApiError } from "~/utils/error-parser";

export function BasicErrorComponent({ error }: { error: unknown }) {
	if (isApiError(error)) {
		const parsedError = parseApiError(error.errors);
		return <ErrorComponent error={parsedError} />;
	}

	return (
		<div>
			Error: <pre>{JSON.stringify(error, null, 2)}</pre>
		</div>
	);
}
</file>

<file path="src/components/games-list.tsx">
import { useSuspenseQuery } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import { listGamesOptions } from "~/api/@tanstack/react-query.gen";
import { Card, CardDescription, CardHeader, CardTitle } from "./ui/card";

export function GamesList() {
	const { data: games, error } = useSuspenseQuery(listGamesOptions());

	const navigate = useNavigate();

	return (
		<>
			{error && <div>Error: {error.message}</div>}
			<div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-4 m-10">
				{games.data?.map((game) => (
					<Card
						key={game.id}
						className="group cursor-pointer hover:bg-primary transition-colors ease-in-out duration-200 "
						onClick={() =>
							navigate({
								to: "/games/$gameId",
								from: "/games",
								params: { gameId: game.id },
							})
						}
					>
						<CardHeader>
							<CardTitle>{game.name}</CardTitle>
							<CardDescription className="group-hover:text-primary-foreground transition-colors ease-in-out duration-200">
								{game.content}
							</CardDescription>
						</CardHeader>
					</Card>
				))}
			</div>
		</>
	);
}
</file>

<file path="src/components/search-bar.tsx">
import { Search } from "lucide-react";
import { Card, CardContent } from "~/components/ui/card";
import { Input } from "~/components/ui/input";

interface SearchBarProps {
	searchQuery: string;
	onSearchChange: (value: string) => void;
	placeholder?: string;
}

export function SearchBar({
	searchQuery,
	onSearchChange,
	placeholder = "Search...",
}: SearchBarProps) {
	return (
		<Card>
			<CardContent className="pt-6">
				<div className="flex flex-col gap-4">
					<div className="flex gap-2">
						<div className="relative flex-1">
							<Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4" />
							<Input
								placeholder={placeholder}
								value={searchQuery}
								onChange={(e) => onSearchChange(e.target.value)}
								className="pl-10"
							/>
						</div>
					</div>
				</div>
			</CardContent>
		</Card>
	);
}
</file>

<file path="src/components/stat-card.tsx">
import { useNavigate } from "@tanstack/react-router";
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";

interface StatCardProps {
	title: string;
	value: string;
	href?: string;
	Icon?: React.ComponentType<{ className?: string }>;
}

export function StatCard({ title, value, href, Icon }: StatCardProps) {
	const navigate = useNavigate();

	return (
		<Card onClick={() => navigate({ to: href })}>
			<CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
				<CardTitle className="text-sm font-medium">{title}</CardTitle>
				{Icon && <Icon className="h-6 w-6 text-muted-foreground" />}
			</CardHeader>
			<CardContent>
				<div className="text-2xl font-bold">{value}</div>
			</CardContent>
		</Card>
	);
}

// TODO: better navigation using tanstack router features and type safety
</file>

<file path="src/components/theme-provider.tsx">
import {
	ThemeProvider as NextThemesProvider,
	type ThemeProviderProps,
} from "next-themes";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
	return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
</file>

<file path="src/hooks/useMobile.ts">
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
	const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);

	React.useEffect(() => {
		const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
		const onChange = () => {
			setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
		};
		mql.addEventListener("change", onChange);
		setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
		return () => mql.removeEventListener("change", onChange);
	}, []);

	return !!isMobile;
}
</file>

<file path="src/hooks/useMutationLite.ts">
import * as React from "react";

export function useMutationLite<TVariables, TData, TError = Error>(opts: {
	fn: (variables: TVariables) => Promise<TData>;
	onSuccess?: (ctx: { data: TData }) => void | Promise<void>;
}) {
	const [submittedAt, setSubmittedAt] = React.useState<number | undefined>();
	const [variables, setVariables] = React.useState<TVariables | undefined>();
	const [error, setError] = React.useState<TError | undefined>();
	const [data, setData] = React.useState<TData | undefined>();
	const [status, setStatus] = React.useState<"idle" | "pending" | "success" | "error">(
		"idle",
	);

	const mutate = React.useCallback(
		async (variables: TVariables): Promise<TData | undefined> => {
			setStatus("pending");
			setSubmittedAt(Date.now());
			setVariables(variables);
			//
			try {
				const data = await opts.fn(variables);
				await opts.onSuccess?.({ data });
				setStatus("success");
				setError(undefined);
				setData(data);
				return data;
			} catch (err: any) {
				setStatus("error");
				setError(err);
			}
		},
		[opts.fn],
	);

	return {
		status,
		variables,
		submittedAt,
		mutate,
		error,
		data,
	};
}
</file>

<file path="src/hooks/useTags.ts">
import * as React from "react";

export function useTags() {
	const [tags, setTags] = React.useState<string[]>([]);
	const [newTag, setNewTag] = React.useState("");

	const addTag = () => {
		if (newTag.trim() && !tags.includes(newTag)) {
			setTags([...tags, newTag]);
			setNewTag("");
		}
	};

	const removeTag = (tag: string) => {
		setTags(tags.filter((t) => t !== tag));
	};

	return { tags, newTag, setNewTag, addTag, removeTag };
}
</file>

<file path="src/routes/_auth/games/$gameId/locations/$id/route.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import {
	getLocationLinksOptions,
	getLocationOptions,
} from "~/api/@tanstack/react-query.gen";
import { BasicErrorComponent } from "~/components/error";

export const Route = createFileRoute("/_auth/games/$gameId/locations/$id")({
	component: RouteComponent,
	loader: async ({ context, params }) => {
		await context.queryClient.ensureQueryData(
			getLocationOptions({
				path: { game_id: params.gameId, id: params.id },
			}),
		);
		context.queryClient.ensureQueryData(
			getLocationLinksOptions({
				path: { game_id: params.gameId, location_id: params.id },
			}),
		);
	},
	errorComponent: BasicErrorComponent,
});

function RouteComponent() {
	return <Outlet />;
}
</file>

<file path="src/routes/_auth/games/$gameId/all.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { AllEntitiesTable, type AllEntity } from "~/components/all-entities-table";
import { PageHeader } from "~/components/page-header";
import { useGetGameLinksSuspenseQuery } from "~/queries/games";
import type { EntityType } from "~/types";

export const Route = createFileRoute("/_auth/games/$gameId/all")({
	component: RouteComponent,
});

function RouteComponent() {
	const { gameId } = Route.useParams();
	const { data } = useGetGameLinksSuspenseQuery({ id: gameId });

	// Transform the API response into our AllEntity format
	const allEntities: AllEntity[] = [];

	if (data.data?.entities) {
		const { entities } = data.data;

		// Add characters
		if (entities.characters) {
			for (const character of entities.characters) {
				allEntities.push({
					...character,
					type: "character" as EntityType,
				});
			}
		}

		// Add factions
		if (entities.factions) {
			for (const faction of entities.factions) {
				allEntities.push({
					...faction,
					type: "faction" as EntityType,
				});
			}
		}

		// Add locations
		if (entities.locations) {
			for (const location of entities.locations) {
				allEntities.push({
					...location,
					type: "location" as EntityType,
				});
			}
		}

		// Add notes
		if (entities.notes) {
			for (const note of entities.notes) {
				allEntities.push({
					...note,
					type: "note" as EntityType,
				});
			}
		}

		// Add quests
		if (entities.quests) {
			for (const quest of entities.quests) {
				allEntities.push({
					...quest,
					type: "quest" as EntityType,
				});
			}
		}
	}

	return (
		<div className="container mx-auto py-8">
			<PageHeader
				title="All Entities"
				description="Browse all characters, factions, locations, notes, and quests in your game."
			/>
			<AllEntitiesTable entities={allEntities} gameId={gameId} />
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/tree.tsx">
import { createFileRoute } from "@tanstack/react-router";
import {
	getGameEntityTreeOptions,
	useGetGameEntityTreeQuery,
} from "~/api/@tanstack/react-query.gen";
import { PageHeader } from "~/components/page-header";

export const Route = createFileRoute("/_auth/games/$gameId/tree")({
	component: RouteComponent,
	loader: async ({ params, context }) => {
		await context.queryClient.ensureQueryData(
			getGameEntityTreeOptions({ path: { game_id: params.gameId } }),
		);
	},
});

function RouteComponent() {
	const { gameId } = Route.useParams();
	const { data } = useGetGameEntityTreeQuery({ path: { game_id: gameId } });
	return (
		<div>
			<PageHeader title="Game Entity Tree" />
			<pre>{JSON.stringify(data, null, 2)}</pre>
		</div>
	);
}
</file>

<file path="src/utils/api-client.ts">
import { client } from "~/api/client.gen";

export function initializeApiClient() {
	client.setConfig({
		baseUrl: "http://localhost:4000",
	});
}

export function updateApiAuth(token: string) {
	client.setConfig({
		headers: {
			Authorization: `Bearer ${token}`,
		},
	});
}

export function clearApiAuth() {
	client.setConfig({
		headers: {},
	});
}
</file>

<file path="src/utils/api-errors.ts">
import type { _Error, ErrorDetails } from "~/api";

export function isApiError(obj: unknown): obj is _Error {
	if (obj === null || typeof obj !== "object") {
		return false;
	}

	const candidate = obj as Record<string, unknown>;

	if ("errors" in candidate) {
		return candidate.errors === undefined || isErrorDetails(candidate.errors);
	}

	return true;
}

function isErrorDetails(obj: unknown): obj is ErrorDetails {
	return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
</file>

<file path="src/utils/cn.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}
</file>

<file path="src/utils/parse-errors.ts">
import type { ErrorDetails } from "~/api/types.gen";

interface ParsedError {
	message: string;
	code?: string;
	statusCode?: number;
	field?: string;
	details?: Record<string, unknown>;
}

export function parseApiError(errorDetails: ErrorDetails): ParsedError {
	// Common field names to check for error information
	const messageFields = ["message", "error", "description", "detail", "msg"];
	const codeFields = ["code", "errorCode", "error_code", "type"];
	const statusFields = ["status", "statusCode", "status_code", "httpStatus"];
	const fieldFields = ["field", "fieldName", "property", "param"];

	const getMessage = (): string => {
		for (const field of messageFields) {
			const value = errorDetails[field];
			if (typeof value === "string" && value.length > 0) {
				return value;
			}
		}
		return "An unknown error occurred";
	};

	const getCode = (): string | undefined => {
		for (const field of codeFields) {
			const value = errorDetails[field];
			if (typeof value === "string" || typeof value === "number") {
				return String(value);
			}
		}
		return undefined;
	};

	const getStatusCode = (): number | undefined => {
		for (const field of statusFields) {
			const value = errorDetails[field];
			if (typeof value === "number") {
				return value;
			}
		}
		return undefined;
	};

	const getField = (): string | undefined => {
		for (const field of fieldFields) {
			const value = errorDetails[field];
			if (typeof value === "string") {
				return value;
			}
		}
		return undefined;
	};

	return {
		message: getMessage(),
		code: getCode(),
		statusCode: getStatusCode(),
		field: getField(),
		details: errorDetails,
	};
}
</file>

<file path="src/logo.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_1"
  xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 841.9 595.3">
  <!-- Generator: Adobe Illustrator 29.3.0, SVG Export Plug-In . SVG Version: 2.1.0 Build 146)  -->
  <defs>
    <style>
      .st0 {
        fill: #9ae7fc;
      }

      .st1 {
        fill: #61dafb;
      }
    </style>
  </defs>
  <g>
    <path class="st1" d="M666.3,296.5c0-32.5-40.7-63.3-103.1-82.4,14.4-63.6,8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6,0,8.3.9,11.4,2.6,13.6,7.8,19.5,37.5,14.9,75.7-1.1,9.4-2.9,19.3-5.1,29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50,32.6-30.3,63.2-46.9,84-46.9v-22.3c-27.5,0-63.5,19.6-99.9,53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7,0,51.4,16.5,84,46.6-14,14.7-28,31.4-41.3,49.9-22.6,2.4-44,6.1-63.6,11-2.3-10-4-19.7-5.2-29-4.7-38.2,1.1-67.9,14.6-75.8,3-1.8,6.9-2.6,11.5-2.6v-22.3c-8.4,0-16,1.8-22.6,5.6-28.1,16.2-34.4,66.7-19.9,130.1-62.2,19.2-102.7,49.9-102.7,82.3s40.7,63.3,103.1,82.4c-14.4,63.6-8,114.2,20.2,130.4,6.5,3.8,14.1,5.6,22.5,5.6,27.5,0,63.5-19.6,99.9-53.6,36.4,33.8,72.4,53.2,99.9,53.2,8.4,0,16-1.8,22.6-5.6,28.1-16.2,34.4-66.7,19.9-130.1,62-19.1,102.5-49.9,102.5-82.3zm-130.2-66.7c-3.7,12.9-8.3,26.2-13.5,39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4,14.2,2.1,27.9,4.7,41,7.9zm-45.8,106.5c-7.8,13.5-15.8,26.3-24.1,38.2-14.9,1.3-30,2-45.2,2s-30.2-.7-45-1.9c-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8,6.2-13.4,13.2-26.8,20.7-39.9,7.8-13.5,15.8-26.3,24.1-38.2,14.9-1.3,30-2,45.2-2s30.2.7,45,1.9c8.3,11.9,16.4,24.6,24.2,38,7.6,13.1,14.5,26.4,20.8,39.8-6.3,13.4-13.2,26.8-20.7,39.9zm32.3-13c5.4,13.4,10,26.8,13.8,39.8-13.1,3.2-26.9,5.9-41.2,8,4.9-7.7,9.8-15.6,14.4-23.7,4.6-8,8.9-16.1,13-24.1zm-101.4,106.7c-9.3-9.6-18.6-20.3-27.8-32,9,.4,18.2.7,27.5.7s18.7-.2,27.8-.7c-9,11.7-18.3,22.4-27.5,32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9,3.7-12.9,8.3-26.2,13.5-39.5,4.1,8,8.4,16,13.1,24s9.5,15.8,14.4,23.4zm73.9-208.1c9.3,9.6,18.6,20.3,27.8,32-9-.4-18.2-.7-27.5-.7s-18.7.2-27.8.7c9-11.7,18.3-22.4,27.5-32zm-74,58.9c-4.9,7.7-9.8,15.6-14.4,23.7-4.6,8-8.9,16-13,24-5.4-13.4-10-26.8-13.8-39.8,13.1-3.1,26.9-5.8,41.2-7.9zm-90.5,125.2c-35.4-15.1-58.3-34.9-58.3-50.6s22.9-35.6,58.3-50.6c8.6-3.7,18-7,27.7-10.1,5.7,19.6,13.2,40,22.5,60.9-9.2,20.8-16.6,41.1-22.2,60.6-9.9-3.1-19.3-6.5-28-10.2zm53.8,142.9c-13.6-7.8-19.5-37.5-14.9-75.7,1.1-9.4,2.9-19.3,5.1-29.4,19.6,4.8,41,8.5,63.5,10.9,13.5,18.5,27.5,35.3,41.6,50-32.6,30.3-63.2,46.9-84,46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7,38.2-1.1,67.9-14.6,75.8-3,1.8-6.9,2.6-11.5,2.6-20.7,0-51.4-16.5-84-46.6,14-14.7,28-31.4,41.3-49.9,22.6-2.4,44-6.1,63.6-11,2.3,10.1,4.1,19.8,5.2,29.1zm38.5-66.7c-8.6,3.7-18,7-27.7,10.1-5.7-19.6-13.2-40-22.5-60.9,9.2-20.8,16.6-41.1,22.2-60.6,9.9,3.1,19.3,6.5,28.1,10.2,35.4,15.1,58.3,34.9,58.3,50.6,0,15.7-23,35.6-58.4,50.6zm-264.9-268.7z"/>
    <circle class="st1" cx="420.9" cy="296.5" r="45.7"/>
    <path class="st1" d="M520.5,78.1"/>
  </g>
  <circle class="st0" cx="420.8" cy="296.6" r="43"/>
  <path class="st1" d="M466.1,296.6c0,25-20.2,45.2-45.2,45.2s-45.2-20.2-45.2-45.2,20.2-45.2,45.2-45.2,45.2,20.2,45.2,45.2ZM386,295.6v-6.3c0-1.1,1.2-5.1,1.8-6.2,1-1.9,2.9-3.5,4.6-4.7l-3.4-3.4c4-3.6,9.4-3.7,13.7-.7,1.9-4.7,6.6-7.1,11.6-6.7l-.8,4.2c5.9.2,13.1,4.1,13.1,10.8s0,.5-.7.7c-1.7.3-3.4-.4-5-.6s-1.2-.4-1.2.3,2.5,4.1,3,5.5,1,3.5.8,5.3c-5.6-.8-10.5-3.2-14.8-6.7.3,2.6,4.1,21.7,5.3,21.9s.8-.6,1-1.1,1.3-6.3,1.3-6.7c0-1-1.7-1.8-2.2-2.8-1.2-2.7,1.3-4.7,3.7-3.3s5.2,6.2,7.5,7.3,13,1.4,14.8,3.3-2.9,4.6-1.5,7.6c6.7-2.6,13.5-3.3,20.6-2.5,3.1-9.7,3.1-20.3-.9-29.8-7.3,0-14.7-3.6-17.2-10.8-2.5-7.2-.7-8.6-1.3-9.3-.8-1-6.3.6-7.4-1.5s.3-1.1-.2-1.4-1.9-.6-2.6-.8c-26-6.4-51.3,15.7-49.7,42.1,0,1.6,1.6,10.3,2.4,11.1s4.8,0,6.3,0,3.7.3,5,.5c2.9.4,7.2,2.4,9.4,2.5s2.4-.8,2.7-2.4c.4-2.6.5-7.4.5-10.1s-1-7.8-1.3-11.6c-.9-.2-.7,0-.9.5-.7,1.3-1.1,3.2-1.9,4.8s-5.2,8.7-5.7,9-.7-.5-.8-.8c-1.6-3.5-2-7.9-1.9-11.8-.9-1-5.4,4.9-6.7,5.3l-.8-.4v-.3h-.2ZM455.6,276.4c1.1-1.2-6-8.9-7.2-10-3-2.7-5.4-4.5-3.5,1.4s5.7,7.8,10.6,8.5h.1ZM410.9,270.1c-.4-.5-6.1,2.9-5.5,4.6,1.9-1.3,5.9-1.7,5.5-4.6ZM400.4,276.4c-.3-2.4-6.3-2.7-7.2-1s1.6,1.4,1.9,1.4c1.8.3,3.5-.6,5.2-.4h.1ZM411.3,276.8c3.8,1.3,6.6,3.6,10.9,3.7s0-3-1.2-3.9c-2.2-1.7-5.1-2.4-7.8-2.4s-1.6-.3-1.4.4c2.8.6,7.3.7,8.4,3.8-2.3-.3-3.9-1.6-6.2-2s-2.5-.5-2.6.3h0ZM420.6,290.3c-.8-5.1-5.7-10.8-10.9-11.6s-1.3-.4-.8.5,4.7,3.2,5.7,4,4.5,4.2,2.1,3.8-8.4-7.8-9.4-6.7c.2.9,1.1,1.9,1.7,2.7,3,3.8,6.9,6.8,11.8,7.4h-.2ZM395.3,279.8c-5,1.1-6.9,6.3-6.7,11,.7.8,5-3.8,5.4-4.5s2.7-4.6,1.1-4-2.9,4.4-4.2,4.6.2-2.1.4-2.5c1.1-1.6,2.9-3.1,4-4.6h0ZM400.4,281.5c-.4-.5-2,1.3-2.3,1.7-2.9,3.9-2.6,10.2-1.5,14.8.8.2.8-.3,1.2-.7,3-3.8,5.5-10.5,4.5-15.4-2.1,3.1-3.1,7.3-3.6,11h-1.3c0-4,1.9-7.7,3-11.4h0ZM426.9,305.9c0-1.7-1.7-1.4-2.5-1.9s-1.3-1.9-3-1.4c1.3,2.1,3,3.2,5.5,3.4h0ZM417.2,308.5c7.6.7,5.5-1.9,1.4-5.5-1.3-.3-1.5,4.5-1.4,5.5ZM437,309.7c-3.5-.3-7.8-2-11.2-2.1s-1.3,0-1.9.7c4,1.3,8.4,1.7,12.1,4l1-2.5h0ZM420.5,312.8c-7.3,0-15.1,3.7-20.4,8.8s-4.8,5.3-4.8,6.2c0,1.8,8.6,6.2,10.5,6.8,12.1,4.8,27.5,3.5,38.2-4.2s3.1-2.7,0-6.2c-5.7-6.6-14.7-11.4-23.4-11.3h-.1ZM398.7,316.9c-1.4-1.4-5-1.9-7-2.1s-5.3-.3-6.9.6l13.9,1.4h0ZM456.9,314.8h-7.4c-.9,0-4.9,1.1-6,1.6s-.8.6,0,.5c2.4,0,5.1-1,7.6-1.3s3.5.2,5.1,0,1.3-.3.6-.8h0Z"/>
  <path class="st0" d="M386,295.6l.8.4c1.3-.3,5.8-6.2,6.7-5.3,0,3.9.3,8.3,1.9,11.8s0,1.2.8.8,5.1-7.8,5.7-9,1.3-3.5,1.9-4.8,0-.7.9-.5c.3,3.8,1.2,7.8,1.3,11.6s0,7.5-.5,10.1-1.1,2.4-2.7,2.4-6.5-2.1-9.4-2.5-3.7-.5-5-.5-5.4,1.1-6.3,0-2.2-9.5-2.4-11.1c-1.5-26.4,23.7-48.5,49.7-42.1s2.2.4,2.6.8,0,1,.2,1.4c1.1,2,6.5.5,7.4,1.5s.4,6.9,1.3,9.3c2.5,7.2,10,10.9,17.2,10.8,4,9.4,4,20.1.9,29.8-7.2-.7-13.9,0-20.6,2.5-1.3-3.1,4.1-5.1,1.5-7.6s-11.8-1.9-14.8-3.3-5.4-6.1-7.5-7.3-4.9.6-3.7,3.3,2.1,1.8,2.2,2.8-1,6.2-1.3,6.7-.3,1.3-1,1.1c-1.1-.3-5-19.3-5.3-21.9,4.3,3.5,9.2,5.9,14.8,6.7.2-1.9-.3-3.5-.8-5.3s-3-5.1-3-5.5c0-.8.9-.3,1.2-.3,1.6,0,3.3.8,5,.6s.7.3.7-.7c0-6.6-7.2-10.6-13.1-10.8l.8-4.2c-5.1-.3-9.6,2-11.6,6.7-4.3-3-9.8-3-13.7.7l3.4,3.4c-1.8,1.3-3.5,2.8-4.6,4.7s-1.8,5.1-1.8,6.2v6.6h.2ZM431.6,265c7.8,2.1,8.7-3.5.2-1.3l-.2,1.3ZM432.4,270.9c.3.6,6.4-.4,5.8-2.3s-4.6.6-5.7.6l-.2,1.7h.1ZM434.5,276c.8,1.2,5.7-1.8,5.5-2.7-.4-1.9-6.6,1.2-5.5,2.7ZM442.9,276.4c-.9-.9-5,2.8-4.6,4,.6,2.4,5.7-3,4.6-4ZM445.1,279.9c-.3.2-3.1,4.6-1.5,5s3.5-3.4,3.5-4-1.3-1.3-2-.9h0ZM448.9,287.4c2.1.8,3.8-5.1,2.3-5.5-1.9-.6-2.6,5.1-2.3,5.5ZM457.3,288.6c.5-1.7,1.1-4.7-1-5.5-1,.3-.6,3.9-.6,4.8l.3.5,1.3.2h0Z"/>
  <path class="st0" d="M455.6,276.4c-5-.8-9.1-3.6-10.6-8.5s.5-4,3.5-1.4,8.3,8.7,7.2,10h-.1Z"/>
  <path class="st0" d="M420.6,290.3c-4.9-.6-8.9-3.6-11.8-7.4s-1.5-1.8-1.7-2.7c1-1,8.5,6.6,9.4,6.7,2.4.4-1.8-3.5-2.1-3.8-1-.8-5.4-3.5-5.7-4-.4-.8.5-.5.8-.5,5.2.8,10.1,6.6,10.9,11.6h.2Z"/>
  <path class="st0" d="M400.4,281.5c-1.1,3.7-3,7.3-3,11.4h1.3c.5-3.7,1.5-7.8,3.6-11,1,4.8-1.5,11.6-4.5,15.4s-.4.8-1.2.7c-1.1-4.5-1.3-10.8,1.5-14.8s1.9-2.2,2.3-1.7h0Z"/>
  <path class="st0" d="M411.3,276.8c0-.8,2.1-.4,2.6-.3,2.4.4,4,1.7,6.2,2-1.2-3.1-5.7-3.2-8.4-3.8,0-.8.9-.4,1.4-.4,2.8,0,5.6.7,7.8,2.4,2.2,1.7,4,4,1.2,3.9-4.3,0-7.1-2.4-10.9-3.7h0Z"/>
  <path class="st0" d="M395.3,279.8c-1.1,1.6-3,3-4,4.6s-1.9,2.8-.4,2.5,2.8-4,4.2-4.6-.9,3.6-1.1,4c-.4.7-4.7,5.2-5.4,4.5-.2-4.6,1.8-9.9,6.7-11h0Z"/>
  <path class="st0" d="M437,309.7l-1,2.5c-3.6-2.3-8-2.8-12.1-4,.5-.7,1.1-.7,1.9-.7,3.4,0,7.8,1.8,11.2,2.1h0Z"/>
  <path class="st0" d="M417.2,308.5c0-1,0-5.8,1.4-5.5,4,3.5,6.1,6.2-1.4,5.5Z"/>
  <path class="st0" d="M400.4,276.4c-1.8-.3-3.5.7-5.2.4s-2.3-.8-1.9-1.4c.8-1.6,6.9-1.4,7.2,1h-.1Z"/>
  <path class="st0" d="M410.9,270.1c.4,3-3.6,3.3-5.5,4.6-.6-1.8,5-5.1,5.5-4.6Z"/>
  <path class="st0" d="M426.9,305.9c-2.5-.2-4.1-1.3-5.5-3.4,1.7-.4,2,.8,3,1.4s2.6.3,2.5,1.9h0Z"/>
  <path class="st1" d="M432.4,270.9l.2-1.7c1.1,0,5.1-2.2,5.7-.6s-5.5,2.9-5.8,2.3h-.1Z"/>
  <path class="st1" d="M431.6,265l.2-1.3c8.4-2.1,7.7,3.4-.2,1.3Z"/>
  <path class="st1" d="M434.5,276c-1.1-1.5,5.1-4.6,5.5-2.7s-4.6,4-5.5,2.7Z"/>
  <path class="st1" d="M442.9,276.4c1.1,1.1-4,6.4-4.6,4s3.7-4.9,4.6-4Z"/>
  <path class="st1" d="M445.1,279.9c.7-.4,2.1,0,2,.9s-2.4,4.4-3.5,4,1.3-4.8,1.5-5h0Z"/>
  <path class="st1" d="M448.9,287.4c-.3-.3.4-6.1,2.3-5.5,1.4.4-.2,6.2-2.3,5.5Z"/>
  <path class="st1" d="M457.3,288.6l-1.3-.2-.3-.5c0-.9-.4-4.6.6-4.8,2.1.8,1.5,3.8,1,5.5h0Z"/>
  <path class="st0" d="M420.5,312.8c8.9,0,17.9,4.7,23.4,11.3,5.6,6.6,3.8,3.5,0,6.2-10.7,7.7-26.1,9-38.2,4.2-1.9-.8-10.5-5.1-10.5-6.8s4-5.3,4.8-6.2c5.3-5,13.1-8.6,20.4-8.8h.1Z"/>
  <path class="st0" d="M398.7,316.9l-13.9-1.4c1.7-1,5-.8,6.9-.6s5.6.7,7,2.1h0Z"/>
  <path class="st0" d="M456.9,314.8c.7.5,0,.8-.6.8-1.6.2-3.5-.2-5.1,0-2.4.3-5.2,1.2-7.6,1.3s-1.1,0,0-.5,5.1-1.6,6-1.6h7.4,0Z"/>
</svg>
</file>

<file path="AGENTS.md">
<!-- BACKLOG.MD GUIDELINES START -->
# Instructions for the usage of Backlog.md CLI Tool

## Backlog.md: Comprehensive Project Management Tool via CLI

### Assistant Objective

Efficiently manage all project tasks, status, and documentation using the Backlog.md CLI, ensuring all project metadata
remains fully synchronized and up-to-date.

### Core Capabilities

- ‚úÖ **Task Management**: Create, edit, assign, prioritize, and track tasks with full metadata
- ‚úÖ **Acceptance Criteria**: Granular control with add/remove/check/uncheck by index
- ‚úÖ **Board Visualization**: Terminal-based Kanban board (`backlog board`) and web UI (`backlog browser`)
- ‚úÖ **Git Integration**: Automatic tracking of task states across branches
- ‚úÖ **Dependencies**: Task relationships and subtask hierarchies
- ‚úÖ **Documentation & Decisions**: Structured docs and architectural decision records
- ‚úÖ **Export & Reporting**: Generate markdown reports and board snapshots
- ‚úÖ **AI-Optimized**: `--plain` flag provides clean text output for AI processing

### Why This Matters to You (AI Agent)

1. **Comprehensive system** - Full project management capabilities through CLI
2. **The CLI is the interface** - All operations go through `backlog` commands
3. **Unified interaction model** - You can use CLI for both reading (`backlog task 1 --plain`) and writing (
   `backlog task edit 1`)
4. **Metadata stays synchronized** - The CLI handles all the complex relationships

### Key Understanding

- **Tasks** live in `backlog/tasks/` as `task-<id> - <title>.md` files
- **You interact via CLI only**: `backlog task create`, `backlog task edit`, etc.
- **Use `--plain` flag** for AI-friendly output when viewing/listing
- **Never bypass the CLI** - It handles Git, metadata, file naming, and relationships

---

# ‚ö†Ô∏è CRITICAL: NEVER EDIT TASK FILES DIRECTLY. Edit Only via CLI

**ALL task operations MUST use the Backlog.md CLI commands**

- ‚úÖ **DO**: Use `backlog task edit` and other CLI commands
- ‚úÖ **DO**: Use `backlog task create` to create new tasks
- ‚úÖ **DO**: Use `backlog task edit <id> --check-ac <index>` to mark acceptance criteria
- ‚ùå **DON'T**: Edit markdown files directly
- ‚ùå **DON'T**: Manually change checkboxes in files
- ‚ùå **DON'T**: Add or modify text in task files without using CLI

**Why?** Direct file editing breaks metadata synchronization, Git tracking, and task relationships.

---

## 1. Source of Truth & File Structure

### üìñ **UNDERSTANDING** (What you'll see when reading)

- Markdown task files live under **`backlog/tasks/`** (drafts under **`backlog/drafts/`**)
- Files are named: `task-<id> - <title>.md` (e.g., `task-42 - Add GraphQL resolver.md`)
- Project documentation is in **`backlog/docs/`**
- Project decisions are in **`backlog/decisions/`**

### üîß **ACTING** (How to change things)

- **All task operations MUST use the Backlog.md CLI tool**
- This ensures metadata is correctly updated and the project stays in sync
- **Always use `--plain` flag** when listing or viewing tasks for AI-friendly text output

---

## 2. Common Mistakes to Avoid

### ‚ùå **WRONG: Direct File Editing**

```markdown
# DON'T DO THIS:

1. Open backlog/tasks/task-7 - Feature.md in editor
2. Change "- [ ]" to "- [x]" manually
3. Add notes directly to the file
4. Save the file
```

### ‚úÖ **CORRECT: Using CLI Commands**

```bash
# DO THIS INSTEAD:
backlog task edit 7 --check-ac 1  # Mark AC #1 as complete
backlog task edit 7 --notes "Implementation complete"  # Add notes
backlog task edit 7 -s "In Progress" -a @agent-k  # Multiple commands: change status and assign the task when you start working on the task
```

---

## 3. Understanding Task Format (Read-Only Reference)

‚ö†Ô∏è **FORMAT REFERENCE ONLY** - The following sections show what you'll SEE in task files.
**Never edit these directly! Use CLI commands to make changes.**

### Task Structure You'll See

```markdown
---
id: task-42
title: Add GraphQL resolver
status: To Do
assignee: [@sara]
labels: [backend, api]
---

## Description

Brief explanation of the task purpose.

## Acceptance Criteria

<!-- AC:BEGIN -->

- [ ] #1 First criterion
- [x] #2 Second criterion (completed)
- [ ] #3 Third criterion

<!-- AC:END -->

## Implementation Plan

1. Research approach
2. Implement solution

## Implementation Notes

Summary of what was done.
```

### How to Modify Each Section

| What You Want to Change | CLI Command to Use                                       |
|-------------------------|----------------------------------------------------------|
| Title                   | `backlog task edit 42 -t "New Title"`                    |
| Status                  | `backlog task edit 42 -s "In Progress"`                  |
| Assignee                | `backlog task edit 42 -a @sara`                          |
| Labels                  | `backlog task edit 42 -l backend,api`                    |
| Description             | `backlog task edit 42 -d "New description"`              |
| Add AC                  | `backlog task edit 42 --ac "New criterion"`              |
| Check AC #1             | `backlog task edit 42 --check-ac 1`                      |
| Uncheck AC #2           | `backlog task edit 42 --uncheck-ac 2`                    |
| Remove AC #3            | `backlog task edit 42 --remove-ac 3`                     |
| Add Plan                | `backlog task edit 42 --plan "1. Step one\n2. Step two"` |
| Add Notes (replace)     | `backlog task edit 42 --notes "What I did"`              |
| Append Notes            | `backlog task edit 42 --append-notes "Another note"` |

---

## 4. Defining Tasks

### Creating New Tasks

**Always use CLI to create tasks:**

```bash
# Example
backlog task create "Task title" -d "Description" --ac "First criterion" --ac "Second criterion"
```

### Title (one liner)

Use a clear brief title that summarizes the task.

### Description (The "why")

Provide a concise summary of the task purpose and its goal. Explains the context without implementation details.

### Acceptance Criteria (The "what")

**Understanding the Format:**

- Acceptance criteria appear as numbered checkboxes in the markdown files
- Format: `- [ ] #1 Criterion text` (unchecked) or `- [x] #1 Criterion text` (checked)

**Managing Acceptance Criteria via CLI:**

‚ö†Ô∏è **IMPORTANT: How AC Commands Work**

- **Adding criteria (`--ac`)** accepts multiple flags: `--ac "First" --ac "Second"` ‚úÖ
- **Checking/unchecking/removing** accept multiple flags too: `--check-ac 1 --check-ac 2` ‚úÖ
- **Mixed operations** work in a single command: `--check-ac 1 --uncheck-ac 2 --remove-ac 3` ‚úÖ

```bash
# Examples

# Add new criteria (MULTIPLE values allowed)
backlog task edit 42 --ac "User can login" --ac "Session persists"

# Check specific criteria by index (MULTIPLE values supported)
backlog task edit 42 --check-ac 1 --check-ac 2 --check-ac 3  # Check multiple ACs
# Or check them individually if you prefer:
backlog task edit 42 --check-ac 1    # Mark #1 as complete
backlog task edit 42 --check-ac 2    # Mark #2 as complete

# Mixed operations in single command
backlog task edit 42 --check-ac 1 --uncheck-ac 2 --remove-ac 3

# ‚ùå STILL WRONG - These formats don't work:
# backlog task edit 42 --check-ac 1,2,3  # No comma-separated values
# backlog task edit 42 --check-ac 1-3    # No ranges
# backlog task edit 42 --check 1         # Wrong flag name

# Multiple operations of same type
backlog task edit 42 --uncheck-ac 1 --uncheck-ac 2  # Uncheck multiple ACs
backlog task edit 42 --remove-ac 2 --remove-ac 4    # Remove multiple ACs (processed high-to-low)
```

**Key Principles for Good ACs:**

- **Outcome-Oriented:** Focus on the result, not the method.
- **Testable/Verifiable:** Each criterion should be objectively testable
- **Clear and Concise:** Unambiguous language
- **Complete:** Collectively cover the task scope
- **User-Focused:** Frame from end-user or system behavior perspective

Good Examples:

- "User can successfully log in with valid credentials"
- "System processes 1000 requests per second without errors"
- "CLI preserves literal newlines in description/plan/notes; `\\n` sequences are not auto‚Äëconverted"

Bad Example (Implementation Step):

- "Add a new function handleLogin() in auth.ts"
- "Define expected behavior and document supported input patterns"

### Task Breakdown Strategy

1. Identify foundational components first
2. Create tasks in dependency order (foundations before features)
3. Ensure each task delivers value independently
4. Avoid creating tasks that block each other

### Task Requirements

- Tasks must be **atomic** and **testable** or **verifiable**
- Each task should represent a single unit of work for one PR
- **Never** reference future tasks (only tasks with id < current task id)
- Ensure tasks are **independent** and don't depend on future work

---

## 5. Implementing Tasks

### 5.1. First step when implementing a task

The very first things you must do when you take over a task are:

* set the task in progress
* assign it to yourself

```bash
# Example
backlog task edit 42 -s "In Progress" -a @{myself}
```

### 5.2. Create an Implementation Plan (The "how")

Previously created tasks contain the why and the what. Once you are familiar with that part you should think about a
plan on **HOW** to tackle the task and all its acceptance criteria. This is your **Implementation Plan**.
First do a quick check to see if all the tools that you are planning to use are available in the environment you are
working in.   
When you are ready, write it down in the task so that you can refer to it later.

```bash
# Example
backlog task edit 42 --plan "1. Research codebase for references\n2Research on internet for similar cases\n3. Implement\n4. Test"
```

## 5.3. Implementation

Once you have a plan, you can start implementing the task. This is where you write code, run tests, and make sure
everything works as expected. Follow the acceptance criteria one by one and MARK THEM AS COMPLETE as soon as you
finish them.

### 5.4 Implementation Notes (PR description)

When you are done implementing a tasks you need to prepare a PR description for it.
Because you cannot create PRs directly, write the PR as a clean description in the task notes.
Append notes progressively during implementation using `--append-notes`:

```
backlog task edit 42 --append-notes "Implemented X" --append-notes "Added tests"
```

```bash
# Example
backlog task edit 42 --notes "Implemented using pattern X because Reason Y, modified files Z and W"
```

**IMPORTANT**: Do NOT include an Implementation Plan when creating a task. The plan is added only after you start the
implementation.

- Creation phase: provide Title, Description, Acceptance Criteria, and optionally labels/priority/assignee.
- When you begin work, switch to edit, set the task in progress and assign to yourself
  `backlog task edit <id> -s "In Progress" -a "..."`.
- Think about how you would solve the task and add the plan: `backlog task edit <id> --plan "..."`.
- Add Implementation Notes only after completing the work: `backlog task edit <id> --notes "..."` (replace) or append progressively using `--append-notes`.

## Phase discipline: What goes where

- Creation: Title, Description, Acceptance Criteria, labels/priority/assignee.
- Implementation: Implementation Plan (after moving to In Progress and assigning to yourself).
- Wrap-up: Implementation Notes (Like a PR description), AC and Definition of Done checks.

**IMPORTANT**: Only implement what's in the Acceptance Criteria. If you need to do more, either:

1. Update the AC first: `backlog task edit 42 --ac "New requirement"`
2. Or create a new follow up task: `backlog task create "Additional feature"`

---

## 6. Typical Workflow

```bash
# 1. Identify work
backlog task list -s "To Do" --plain

# 2. Read task details
backlog task 42 --plain

# 3. Start work: assign yourself & change status
backlog task edit 42 -s "In Progress" -a @myself

# 4. Add implementation plan
backlog task edit 42 --plan "1. Analyze\n2. Refactor\n3. Test"

# 5. Work on the task (write code, test, etc.)

# 6. Mark acceptance criteria as complete (supports multiple in one command)
backlog task edit 42 --check-ac 1 --check-ac 2 --check-ac 3  # Check all at once
# Or check them individually if preferred:
# backlog task edit 42 --check-ac 1
# backlog task edit 42 --check-ac 2
# backlog task edit 42 --check-ac 3

# 7. Add implementation notes (PR Description)
backlog task edit 42 --notes "Refactored using strategy pattern, updated tests"

# 8. Mark task as done
backlog task edit 42 -s Done
```

---

## 7. Definition of Done (DoD)

A task is **Done** only when **ALL** of the following are complete:

### ‚úÖ Via CLI Commands:

1. **All acceptance criteria checked**: Use `backlog task edit <id> --check-ac <index>` for each
2. **Implementation notes added**: Use `backlog task edit <id> --notes "..."`
3. **Status set to Done**: Use `backlog task edit <id> -s Done`

### ‚úÖ Via Code/Testing:

4. **Tests pass**: Run test suite and linting
5. **Documentation updated**: Update relevant docs if needed
6. **Code reviewed**: Self-review your changes
7. **No regressions**: Performance, security checks pass

‚ö†Ô∏è **NEVER mark a task as Done without completing ALL items above**

---

## 8. Quick Reference: DO vs DON'T

### Viewing Tasks

| Task         | ‚úÖ DO                        | ‚ùå DON'T                         |
|--------------|-----------------------------|---------------------------------|
| View task    | `backlog task 42 --plain`   | Open and read .md file directly |
| List tasks   | `backlog task list --plain` | Browse backlog/tasks folder     |
| Check status | `backlog task 42 --plain`   | Look at file content            |

### Modifying Tasks

| Task          | ‚úÖ DO                                 | ‚ùå DON'T                           |
|---------------|--------------------------------------|-----------------------------------|
| Check AC      | `backlog task edit 42 --check-ac 1`  | Change `- [ ]` to `- [x]` in file |
| Add notes     | `backlog task edit 42 --notes "..."` | Type notes into .md file          |
| Change status | `backlog task edit 42 -s Done`       | Edit status in frontmatter        |
| Add AC        | `backlog task edit 42 --ac "New"`    | Add `- [ ] New` to file           |

---

## 9. Complete CLI Command Reference

### Task Creation

| Action           | Command                                                                             |
|------------------|-------------------------------------------------------------------------------------|
| Create task      | `backlog task create "Title"`                                                       |
| With description | `backlog task create "Title" -d "Description"`                                      |
| With AC          | `backlog task create "Title" --ac "Criterion 1" --ac "Criterion 2"`                 |
| With all options | `backlog task create "Title" -d "Desc" -a @sara -s "To Do" -l auth --priority high` |
| Create draft     | `backlog task create "Title" --draft`                                               |
| Create subtask   | `backlog task create "Title" -p 42`                                                 |

### Task Modification

| Action           | Command                                     |
|------------------|---------------------------------------------|
| Edit title       | `backlog task edit 42 -t "New Title"`       |
| Edit description | `backlog task edit 42 -d "New description"` |
| Change status    | `backlog task edit 42 -s "In Progress"`     |
| Assign           | `backlog task edit 42 -a @sara`             |
| Add labels       | `backlog task edit 42 -l backend,api`       |
| Set priority     | `backlog task edit 42 --priority high`      |

### Acceptance Criteria Management

| Action              | Command                                                                     |
|---------------------|-----------------------------------------------------------------------------|
| Add AC              | `backlog task edit 42 --ac "New criterion" --ac "Another"`                  |
| Remove AC #2        | `backlog task edit 42 --remove-ac 2`                                        |
| Remove multiple ACs | `backlog task edit 42 --remove-ac 2 --remove-ac 4`                          |
| Check AC #1         | `backlog task edit 42 --check-ac 1`                                         |
| Check multiple ACs  | `backlog task edit 42 --check-ac 1 --check-ac 3`                            |
| Uncheck AC #3       | `backlog task edit 42 --uncheck-ac 3`                                       |
| Mixed operations    | `backlog task edit 42 --check-ac 1 --uncheck-ac 2 --remove-ac 3 --ac "New"` |

### Task Content

| Action           | Command                                                  |
|------------------|----------------------------------------------------------|
| Add plan         | `backlog task edit 42 --plan "1. Step one\n2. Step two"` |
| Add notes        | `backlog task edit 42 --notes "Implementation details"`  |
| Add dependencies | `backlog task edit 42 --dep task-1 --dep task-2`         |

### Multi‚Äëline Input (Description/Plan/Notes)

The CLI preserves input literally. Shells do not convert `\n` inside normal quotes. Use one of the following to insert real newlines:

- Bash/Zsh (ANSI‚ÄëC quoting):
  - Description: `backlog task edit 42 --desc $'Line1\nLine2\n\nFinal'`
  - Plan: `backlog task edit 42 --plan $'1. A\n2. B'`
  - Notes: `backlog task edit 42 --notes $'Done A\nDoing B'`
  - Append notes: `backlog task edit 42 --append-notes $'Progress update line 1\nLine 2'`
- POSIX portable (printf):
  - `backlog task edit 42 --notes "$(printf 'Line1\nLine2')"`
- PowerShell (backtick n):
  - `backlog task edit 42 --notes "Line1`nLine2"`

Do not expect `"...\n..."` to become a newline. That passes the literal backslash + n to the CLI by design.

Descriptions support literal newlines; shell examples may show escaped `\\n`, but enter a single `\n` to create a newline.

### Task Operations

| Action             | Command                                      |
|--------------------|----------------------------------------------|
| View task          | `backlog task 42 --plain`                    |
| List tasks         | `backlog task list --plain`                  |
| Filter by status   | `backlog task list -s "In Progress" --plain` |
| Filter by assignee | `backlog task list -a @sara --plain`         |
| Archive task       | `backlog task archive 42`                    |
| Demote to draft    | `backlog task demote 42`                     |

---

## Common Issues

| Problem              | Solution                                                           |
|----------------------|--------------------------------------------------------------------|
| Task not found       | Check task ID with `backlog task list --plain`                     |
| AC won't check       | Use correct index: `backlog task 42 --plain` to see AC numbers     |
| Changes not saving   | Ensure you're using CLI, not editing files                         |
| Metadata out of sync | Re-edit via CLI to fix: `backlog task edit 42 -s <current-status>` |

---

## Remember: The Golden Rule

**üéØ If you want to change ANYTHING in a task, use the `backlog task edit` command.**
**üìñ Use CLI to read tasks, exceptionally READ task files directly, never WRITE to them.**

Full help available: `backlog --help`

<!-- BACKLOG.MD GUIDELINES END -->
</file>

<file path="components.json">
{
	"$schema": "https://ui.shadcn.com/schema.json",
	"style": "new-york",
	"rsc": false,
	"tsx": true,
	"tailwind": {
		"config": "",
		"css": "src/styles.css",
		"baseColor": "neutral",
		"cssVariables": true,
		"prefix": ""
	},
	"iconLibrary": "lucide",
	"aliases": {
		"components": "~/components",
		"utils": "~/lib/utils",
		"ui": "~/components/ui",
		"lib": "~/lib",
		"hooks": "~/hooks"
	},
	"registries": {
		"@basecn": "https://basecn.dev/r/{name}.json"
	}
}
</file>

<file path="README.md">
Welcome to your new TanStack app! 

# Getting Started

To run this application:

```bash
pnpm install
pnpm start
```

# Building For Production

To build this application for production:

```bash
pnpm build
```

## Testing

This project uses [Vitest](https://vitest.dev/) for testing. You can run the tests with:

```bash
pnpm test
```

## Styling

This project uses [Tailwind CSS](https://tailwindcss.com/) for styling.


## Linting & Formatting

This project uses [Biome](https://biomejs.dev/) for linting and formatting. The following scripts are available:


```bash
pnpm lint
pnpm format
pnpm check
```



## Routing
This project uses [TanStack Router](https://tanstack.com/router). The initial setup is a file based router. Which means that the routes are managed as files in `src/routes`.

### Adding A Route

To add a new route to your application just add another a new file in the `./src/routes` directory.

TanStack will automatically generate the content of the route file for you.

Now that you have two routes you can use a `Link` component to navigate between them.

### Adding Links

To use SPA (Single Page Application) navigation you will need to import the `Link` component from `@tanstack/react-router`.

```tsx
import { Link } from "@tanstack/react-router";
```

Then anywhere in your JSX you can use it like so:

```tsx
<Link to="/about">About</Link>
```

This will create a link that will navigate to the `/about` route.

More information on the `Link` component can be found in the [Link documentation](https://tanstack.com/router/v1/docs/framework/react/api/router/linkComponent).

### Using A Layout

In the File Based Routing setup the layout is located in `src/routes/__root.tsx`. Anything you add to the root route will appear in all the routes. The route content will appear in the JSX where you use the `<Outlet />` component.

Here is an example layout that includes a header:

```tsx
import { Outlet, createRootRoute } from '@tanstack/react-router'
import { TanStackRouterDevtools } from '@tanstack/react-router-devtools'

import { Link } from "@tanstack/react-router";

export const Route = createRootRoute({
  component: () => (
    <>
      <header>
        <nav>
          <Link to="/">Home</Link>
          <Link to="/about">About</Link>
        </nav>
      </header>
      <Outlet />
      <TanStackRouterDevtools />
    </>
  ),
})
```

The `<TanStackRouterDevtools />` component is not required so you can remove it if you don't want it in your layout.

More information on layouts can be found in the [Layouts documentation](https://tanstack.com/router/latest/docs/framework/react/guide/routing-concepts#layouts).


## Data Fetching

There are multiple ways to fetch data in your application. You can use TanStack Query to fetch data from a server. But you can also use the `loader` functionality built into TanStack Router to load the data for a route before it's rendered.

For example:

```tsx
const peopleRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/people",
  loader: async () => {
    const response = await fetch("https://swapi.dev/api/people");
    return response.json() as Promise<{
      results: {
        name: string;
      }[];
    }>;
  },
  component: () => {
    const data = peopleRoute.useLoaderData();
    return (
      <ul>
        {data.results.map((person) => (
          <li key={person.name}>{person.name}</li>
        ))}
      </ul>
    );
  },
});
```

Loaders simplify your data fetching logic dramatically. Check out more information in the [Loader documentation](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#loader-parameters).

### React-Query

React-Query is an excellent addition or alternative to route loading and integrating it into you application is a breeze.

First add your dependencies:

```bash
pnpm add @tanstack/react-query @tanstack/react-query-devtools
```

Next we'll need to create a query client and provider. We recommend putting those in `main.tsx`.

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

// ...

const queryClient = new QueryClient();

// ...

if (!rootElement.innerHTML) {
  const root = ReactDOM.createRoot(rootElement);

  root.render(
    <QueryClientProvider client={queryClient}>
      <RouterProvider router={router} />
    </QueryClientProvider>
  );
}
```

You can also add TanStack Query Devtools to the root route (optional).

```tsx
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

const rootRoute = createRootRoute({
  component: () => (
    <>
      <Outlet />
      <ReactQueryDevtools buttonPosition="top-right" />
      <TanStackRouterDevtools />
    </>
  ),
});
```

Now you can use `useQuery` to fetch your data.

```tsx
import { useQuery } from "@tanstack/react-query";

import "./App.css";

function App() {
  const { data } = useQuery({
    queryKey: ["people"],
    queryFn: () =>
      fetch("https://swapi.dev/api/people")
        .then((res) => res.json())
        .then((data) => data.results as { name: string }[]),
    initialData: [],
  });

  return (
    <div>
      <ul>
        {data.map((person) => (
          <li key={person.name}>{person.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

You can find out everything you need to know on how to use React-Query in the [React-Query documentation](https://tanstack.com/query/latest/docs/framework/react/overview).

## State Management

Another common requirement for React applications is state management. There are many options for state management in React. TanStack Store provides a great starting point for your project.

First you need to add TanStack Store as a dependency:

```bash
pnpm add @tanstack/store
```

Now let's create a simple counter in the `src/App.tsx` file as a demonstration.

```tsx
import { useStore } from "@tanstack/react-store";
import { Store } from "@tanstack/store";
import "./App.css";

const countStore = new Store(0);

function App() {
  const count = useStore(countStore);
  return (
    <div>
      <button onClick={() => countStore.setState((n) => n + 1)}>
        Increment - {count}
      </button>
    </div>
  );
}

export default App;
```

One of the many nice features of TanStack Store is the ability to derive state from other state. That derived state will update when the base state updates.

Let's check this out by doubling the count using derived state.

```tsx
import { useStore } from "@tanstack/react-store";
import { Store, Derived } from "@tanstack/store";
import "./App.css";

const countStore = new Store(0);

const doubledStore = new Derived({
  fn: () => countStore.state * 2,
  deps: [countStore],
});
doubledStore.mount();

function App() {
  const count = useStore(countStore);
  const doubledCount = useStore(doubledStore);

  return (
    <div>
      <button onClick={() => countStore.setState((n) => n + 1)}>
        Increment - {count}
      </button>
      <div>Doubled - {doubledCount}</div>
    </div>
  );
}

export default App;
```

We use the `Derived` class to create a new store that is derived from another store. The `Derived` class has a `mount` method that will start the derived store updating.

Once we've created the derived store we can use it in the `App` component just like we would any other store using the `useStore` hook.

You can find out everything you need to know on how to use TanStack Store in the [TanStack Store documentation](https://tanstack.com/store/latest).

# Demo files

Files prefixed with `demo` can be safely deleted. They are there to provide a starting point for you to play around with the features you've installed.

# Learn More

You can learn more about all of the offerings from TanStack in the [TanStack documentation](https://tanstack.com).
</file>

<file path="src/api/client.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import type { ClientOptions } from './types.gen';
import { type Config, type ClientOptions as DefaultClientOptions, createClient, createConfig } from './client';

/**
 * The `createClientConfig()` function will be called on client initialization
 * and the returned object will become the client's initial configuration.
 *
 * You may want to initialize your client this way instead of calling
 * `setConfig()`. This is useful for example if you're using Next.js
 * to ensure your client always has the correct values.
 */
export type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> = (override?: Config<DefaultClientOptions & T>) => Config<Required<DefaultClientOptions> & T>;

export const client = createClient(createConfig<ClientOptions>({
    baseUrl: 'https://gamemastercore-production.up.railway.app'
}));
</file>

<file path="src/api/zod.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * Login Request
 * Login credentials - either email/password or magic link token
 */
export const zLoginRequest = z.object({
    email: z.optional(z.string()),
    password: z.optional(z.string()),
    token: z.optional(z.string())
});

/**
 * Entity Character
 * Character entity in game entities list
 */
export const zEntityCharacter = z.object({
    class: z.string(),
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    faction_role: z.optional(z.string()),
    id: z.uuid(),
    image_url: z.optional(z.string()),
    level: z.int(),
    member_of_faction_id: z.optional(z.uuid()),
    name: z.string(),
    tags: z.optional(z.array(z.string())),
    updated_at: z.optional(z.string())
});

/**
 * Entity Faction
 * Faction entity in game entities list
 */
export const zEntityFaction = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    id: z.uuid(),
    name: z.string(),
    tags: z.optional(z.array(z.string())),
    updated_at: z.optional(z.string())
});

/**
 * Entity Location
 * Location entity in game entities list
 */
export const zEntityLocation = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    has_parent: z.boolean(),
    id: z.uuid(),
    name: z.string(),
    tags: z.optional(z.array(z.string())),
    type: z.enum([
        'continent',
        'nation',
        'region',
        'city',
        'settlement',
        'building',
        'complex'
    ]),
    updated_at: z.optional(z.string())
});

/**
 * Entity Note
 * Note entity in game entities list
 */
export const zEntityNote = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    id: z.uuid(),
    name: z.string(),
    tags: z.optional(z.array(z.string())),
    updated_at: z.optional(z.string())
});

/**
 * Entity Quest
 * Quest entity in game entities list
 */
export const zEntityQuest = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    id: z.uuid(),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    tags: z.optional(z.array(z.string())),
    updated_at: z.optional(z.string())
});

/**
 * Entities
 * Collection of game entities
 */
export const zEntities = z.object({
    characters: z.optional(z.array(zEntityCharacter)),
    factions: z.optional(z.array(zEntityFaction)),
    locations: z.optional(z.array(zEntityLocation)),
    notes: z.optional(z.array(zEntityNote)),
    quests: z.optional(z.array(zEntityQuest))
});

/**
 * Entities Data
 * Game entities data structure
 */
export const zEntitiesData = z.object({
    entities: z.optional(zEntities),
    game_id: z.uuid(),
    game_name: z.string()
});

/**
 * Entities Response
 * Response containing all game entities
 */
export const zEntitiesResponse = z.object({
    data: z.optional(zEntitiesData)
});

/**
 * Link Update Request
 * Request to update link metadata between entities
 */
export const zLinkUpdateRequest = z.object({
    description: z.optional(z.string()),
    is_active: z.optional(z.boolean()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    relationship_type: z.optional(z.string()),
    strength: z.optional(z.int().gte(1).lte(10))
});

/**
 * Member
 * A game member
 */
export const zMember = z.object({
    email: z.string(),
    joined_at: z.optional(z.string()),
    role: z.string(),
    user_id: z.int()
});

/**
 * Members Response
 * Response containing a list of game members
 */
export const zMembersResponse = z.object({
    data: z.optional(z.array(zMember))
});

/**
 * Location Create Parameters
 * Parameters for creating a new location
 */
export const zLocationCreateParams = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    tags: z.optional(z.array(z.string())),
    type: z.enum([
        'continent',
        'nation',
        'region',
        'city',
        'settlement',
        'building',
        'complex'
    ])
});

/**
 * Location Create Request
 * Location creation parameters
 */
export const zLocationCreateRequest = z.object({
    location: zLocationCreateParams
});

/**
 * Faction Create Parameters
 * Parameters for creating a new faction
 */
export const zFactionCreateParams = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    name: z.string(),
    tags: z.optional(z.array(z.string()))
});

/**
 * User
 * User information
 */
export const zUser = z.object({
    confirmed_at: z.optional(z.string()),
    email: z.string(),
    id: z.int()
});

/**
 * Linked Character
 * A character with relationship metadata
 */
export const zLinkedCharacter = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    description_meta: z.optional(z.string()),
    faction_role: z.optional(z.string()),
    id: z.uuid(),
    is_active: z.optional(z.boolean()),
    member_of_faction_id: z.optional(z.uuid()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    name: z.string(),
    relationship_type: z.optional(z.string()),
    strength: z.optional(z.int()),
    tags: z.optional(z.array(z.unknown()))
});

/**
 * Linked Faction
 * A faction with relationship metadata
 */
export const zLinkedFaction = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    description_meta: z.optional(z.string()),
    id: z.uuid(),
    is_active: z.optional(z.boolean()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    name: z.string(),
    relationship_type: z.optional(z.string()),
    strength: z.optional(z.int()),
    tags: z.optional(z.array(z.unknown()))
});

/**
 * Linked Location
 * A location with relationship metadata
 */
export const zLinkedLocation = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    description_meta: z.optional(z.string()),
    id: z.uuid(),
    is_active: z.optional(z.boolean()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    name: z.string(),
    relationship_type: z.optional(z.string()),
    strength: z.optional(z.int()),
    tags: z.optional(z.array(z.unknown()))
});

/**
 * Linked Note
 * A note with relationship metadata
 */
export const zLinkedNote = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    description_meta: z.optional(z.string()),
    id: z.uuid(),
    is_active: z.optional(z.boolean()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    name: z.string(),
    relationship_type: z.optional(z.string()),
    strength: z.optional(z.int()),
    tags: z.optional(z.array(z.unknown()))
});

/**
 * Linked Quest
 * A quest with relationship metadata
 */
export const zLinkedQuest = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    description_meta: z.optional(z.string()),
    id: z.uuid(),
    is_active: z.optional(z.boolean()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    name: z.string(),
    relationship_type: z.optional(z.string()),
    strength: z.optional(z.int()),
    tags: z.optional(z.array(z.unknown()))
});

/**
 * Location Links
 * Collections of entities linked to a location
 */
export const zLocationLinks = z.object({
    characters: z.optional(z.array(zLinkedCharacter)),
    factions: z.optional(z.array(zLinkedFaction)),
    locations: z.optional(z.array(zLinkedLocation)),
    notes: z.optional(z.array(zLinkedNote)),
    quests: z.optional(z.array(zLinkedQuest))
});

export const zLinkedEntityBase = z.object({
    description: z.optional(z.string()),
    is_active: z.optional(z.boolean()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    relationship_type: z.optional(z.string()),
    strength: z.optional(z.int())
});

/**
 * Character Links
 * Collections of entities linked to a character
 */
export const zCharacterLinks = z.object({
    characters: z.optional(z.array(zLinkedCharacter)),
    factions: z.optional(z.array(zLinkedFaction)),
    locations: z.optional(z.array(zLinkedLocation)),
    notes: z.optional(z.array(zLinkedNote)),
    quests: z.optional(z.array(zLinkedQuest))
});

/**
 * Character Links Data
 * Links associated with a character
 */
export const zCharacterLinksData = z.object({
    character_id: z.uuid(),
    character_name: z.string(),
    links: z.optional(zCharacterLinks)
});

/**
 * Character Links Response
 * Response containing character links
 */
export const zCharacterLinksResponse = z.object({
    data: z.optional(zCharacterLinksData)
});

/**
 * Error Details
 * Detailed error information
 */
export const zErrorDetails = z.record(z.string(), z.unknown());

/**
 * Game Create Parameters
 * Parameters for creating a new game
 */
export const zGameCreateParams = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    name: z.string(),
    setting: z.optional(z.string())
});

/**
 * Game Create Request
 * Game creation parameters
 */
export const zGameCreateRequest = z.object({
    game: zGameCreateParams
});

/**
 * Character
 * A game character
 */
export const zCharacter = z.object({
    class: z.string(),
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    faction_role: z.optional(z.string()),
    game_id: z.uuid(),
    id: z.uuid(),
    image_url: z.optional(z.string()),
    level: z.int(),
    member_of_faction_id: z.optional(z.uuid()),
    name: z.string(),
    pinned: z.boolean(),
    tags: z.optional(z.array(z.string())),
    updated_at: z.optional(z.string()),
    user_id: z.int()
});

/**
 * Characters Response
 * Response containing a list of characters
 */
export const zCharactersResponse = z.object({
    data: z.optional(z.array(zCharacter))
});

/**
 * Faction Update Parameters
 * Parameters for updating an existing faction (partial updates supported)
 */
export const zFactionUpdateParams = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    name: z.optional(z.string()),
    pinned: z.optional(z.boolean()),
    tags: z.optional(z.array(z.string()))
});

/**
 * Faction Update Request
 * Faction update parameters
 */
export const zFactionUpdateRequest = z.object({
    faction: zFactionUpdateParams
});

/**
 * Faction Members Data
 * Characters that are members of a faction
 */
export const zFactionMembersData = z.object({
    faction_id: z.uuid(),
    faction_name: z.string(),
    members: z.optional(z.array(zCharacter))
});

/**
 * Entity Tree Node
 * A single node in the entity relationship tree
 */
export const zEntityTreeNode = z.object({
    get children() {
        return z.array(z.lazy((): any => {
            return zEntityTreeNode;
        }));
    },
    description: z.optional(z.string()),
    id: z.uuid(),
    is_active: z.optional(z.boolean()),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    name: z.string(),
    relationship_type: z.optional(z.string()),
    strength: z.optional(z.int().gte(1).lte(5)),
    type: z.enum([
        'character',
        'faction',
        'location',
        'quest',
        'note'
    ])
});

/**
 * Entity Tree Data
 * Entity relationship tree data grouped by entity types or single tree
 */
export const zEntityTreeData = z.object({
    characters: z.optional(z.array(zEntityTreeNode)),
    factions: z.optional(z.array(zEntityTreeNode)),
    locations: z.optional(z.array(zEntityTreeNode)),
    notes: z.optional(z.array(zEntityTreeNode)),
    quests: z.optional(z.array(zEntityTreeNode))
});

/**
 * Quest Tree Node
 * A node in the quest hierarchy tree
 */
export const zQuestTreeNode = z.object({
    get children(): z.ZodOptional {
        return z.optional(z.array(z.lazy((): any => {
            return zQuestTreeNode;
        })));
    },
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    entity_type: z.enum([
        'quest'
    ]),
    id: z.uuid(),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    tags: z.optional(z.array(z.string()))
});

/**
 * Character Create Parameters
 * Parameters for creating a new character
 */
export const zCharacterCreateParams = z.object({
    class: z.string(),
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    faction_role: z.optional(z.string()),
    image_url: z.optional(z.string()),
    level: z.int(),
    member_of_faction_id: z.optional(z.uuid()),
    name: z.string(),
    tags: z.optional(z.array(z.string()))
});

/**
 * Character Create Request
 * Character creation parameters
 */
export const zCharacterCreateRequest = z.object({
    character: zCharacterCreateParams
});

/**
 * Note Links
 * Collections of entities linked to a note
 */
export const zNoteLinks = z.object({
    characters: z.optional(z.array(zLinkedCharacter)),
    factions: z.optional(z.array(zLinkedFaction)),
    locations: z.optional(z.array(zLinkedLocation)),
    notes: z.optional(z.array(zLinkedNote)),
    quests: z.optional(z.array(zLinkedQuest))
});

/**
 * Faction Links
 * Collections of entities linked to a faction
 */
export const zFactionLinks = z.object({
    characters: z.optional(z.array(zLinkedCharacter)),
    factions: z.optional(z.array(zLinkedFaction)),
    locations: z.optional(z.array(zLinkedLocation)),
    notes: z.optional(z.array(zLinkedNote)),
    quests: z.optional(z.array(zLinkedQuest))
});

/**
 * Faction
 * A game faction
 */
export const zFaction = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    game_id: z.uuid(),
    id: z.uuid(),
    name: z.string(),
    pinned: z.boolean(),
    tags: z.optional(z.array(z.string())),
    updated_at: z.optional(z.string()),
    user_id: z.int()
});

/**
 * Factions Response
 * Response containing a list of factions
 */
export const zFactionsResponse = z.object({
    data: z.optional(z.array(zFaction))
});

/**
 * Note Tree Node
 * A node in the note hierarchy tree
 */
export const zNoteTreeNode = z.object({
    get children(): z.ZodOptional {
        return z.optional(z.array(z.lazy((): any => {
            return zNoteTreeNode;
        })));
    },
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    entity_type: z.enum([
        'note'
    ]),
    id: z.uuid(),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    parent_type: z.optional(z.enum([
        'character',
        'quest',
        'location',
        'faction'
    ])),
    tags: z.optional(z.array(z.string())),
    updated_at: z.optional(z.string())
});

/**
 * Quest Links
 * Collections of entities linked to a quest
 */
export const zQuestLinks = z.object({
    characters: z.optional(z.array(zLinkedCharacter)),
    factions: z.optional(z.array(zLinkedFaction)),
    locations: z.optional(z.array(zLinkedLocation)),
    notes: z.optional(z.array(zLinkedNote)),
    quests: z.optional(z.array(zLinkedQuest))
});

/**
 * Quest Links Data
 * Links associated with a quest
 */
export const zQuestLinksData = z.object({
    links: z.optional(zQuestLinks),
    quest_id: z.uuid(),
    quest_name: z.string()
});

/**
 * Character Primary Faction Data
 * Primary faction information for a character
 */
export const zCharacterPrimaryFactionData = z.object({
    character_id: z.uuid(),
    faction: zFaction,
    role: z.string()
});

/**
 * Character Primary Faction Response
 * Response containing character's primary faction data
 */
export const zCharacterPrimaryFactionResponse = z.object({
    data: z.optional(zCharacterPrimaryFactionData)
});

/**
 * Quest
 * A game quest
 */
export const zQuest = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    game_id: z.uuid(),
    id: z.uuid(),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    pinned: z.boolean(),
    tags: z.optional(z.array(z.string())),
    updated_at: z.optional(z.string()),
    user_id: z.int()
});

/**
 * Quest Response
 * Response containing a single quest
 */
export const zQuestResponse = z.object({
    data: z.optional(zQuest)
});

/**
 * Location
 * A game location
 */
export const zLocation = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    game_id: z.uuid(),
    id: z.uuid(),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    pinned: z.boolean(),
    tags: z.optional(z.array(z.string())),
    type: z.enum([
        'continent',
        'nation',
        'region',
        'city',
        'settlement',
        'building',
        'complex'
    ]),
    updated_at: z.optional(z.string()),
    user_id: z.int()
});

/**
 * Location Update Parameters
 * Parameters for updating an existing location (partial updates supported)
 */
export const zLocationUpdateParams = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    name: z.optional(z.string()),
    parent_id: z.optional(z.uuid()),
    pinned: z.optional(z.boolean()),
    tags: z.optional(z.array(z.string())),
    type: z.optional(z.enum([
        'continent',
        'nation',
        'region',
        'city',
        'settlement',
        'building',
        'complex'
    ]))
});

/**
 * Location Update Request
 * Location update parameters
 */
export const zLocationUpdateRequest = z.object({
    location: zLocationUpdateParams
});

/**
 * Link Request
 * Request to create a link between entities
 */
export const zLinkRequest = z.object({
    description: z.optional(z.string()),
    entity_id: z.uuid(),
    entity_type: z.enum([
        'character',
        'faction',
        'location',
        'quest',
        'note'
    ]),
    is_active: z.optional(z.boolean()).default(true),
    metadata: z.optional(z.record(z.string(), z.unknown())),
    relationship_type: z.optional(z.string()),
    strength: z.optional(z.int().gte(1).lte(10))
});

/**
 * Game
 * A game instance
 */
export const zGame = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    id: z.uuid(),
    name: z.string(),
    owner_id: z.int(),
    setting: z.optional(z.string()),
    updated_at: z.optional(z.string())
});

/**
 * Games Response
 * Response containing a list of games
 */
export const zGamesResponse = z.object({
    data: z.optional(z.array(zGame))
});

/**
 * Note
 * A game note
 */
export const zNote = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    created_at: z.optional(z.string()),
    game_id: z.uuid(),
    id: z.uuid(),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    parent_type: z.optional(z.enum([
        'character',
        'quest',
        'location',
        'faction'
    ])),
    pinned: z.boolean(),
    tags: z.optional(z.array(z.string())),
    updated_at: z.optional(z.string()),
    user_id: z.int()
});

/**
 * Pinned Entities
 * Collection of pinned entities grouped by type
 */
export const zPinnedEntities = z.object({
    characters: z.optional(z.array(zCharacter)),
    factions: z.optional(z.array(zFaction)),
    locations: z.optional(z.array(zLocation)),
    notes: z.optional(z.array(zNote)),
    quests: z.optional(z.array(zQuest))
});

/**
 * Pinned Entities Data
 * All pinned entities for a game
 */
export const zPinnedEntitiesData = z.object({
    game_id: z.uuid(),
    pinned_entities: zPinnedEntities,
    total_count: z.int()
});

/**
 * Note Create Parameters
 * Parameters for creating a new note
 */
export const zNoteCreateParams = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    parent_type: z.optional(z.enum([
        'character',
        'quest',
        'location',
        'faction'
    ])),
    tags: z.optional(z.array(z.string()))
});

/**
 * Note Create Request
 * Note creation parameters
 */
export const zNoteCreateRequest = z.object({
    note: zNoteCreateParams
});

/**
 * Location Response
 * Response containing a single location
 */
export const zLocationResponse = z.object({
    data: z.optional(zLocation)
});

/**
 * Character Response
 * Response containing a single character
 */
export const zCharacterResponse = z.object({
    data: z.optional(zCharacter)
});

/**
 * Location Links Data
 * Links associated with a location
 */
export const zLocationLinksData = z.object({
    links: z.optional(zLocationLinks),
    location_id: z.uuid(),
    location_name: z.string()
});

/**
 * Location Links Response
 * Response containing location links
 */
export const zLocationLinksResponse = z.object({
    data: z.optional(zLocationLinksData)
});

/**
 * Entity Tree Response
 * Response containing hierarchical tree of entity relationships
 */
export const zEntityTreeResponse = z.object({
    data: z.optional(zEntityTreeData)
});

/**
 * Quest Links Response
 * Response containing quest links
 */
export const zQuestLinksResponse = z.object({
    data: z.optional(zQuestLinksData)
});

/**
 * Signup Request
 * User registration credentials
 */
export const zSignupRequest = z.object({
    email: z.string(),
    password: z.string()
});

/**
 * Notes Response
 * Response containing a list of notes
 */
export const zNotesResponse = z.object({
    data: z.optional(z.array(zNote))
});

/**
 * Quest Update Parameters
 * Parameters for updating an existing quest (partial updates supported)
 */
export const zQuestUpdateParams = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    name: z.optional(z.string()),
    parent_id: z.optional(z.uuid()),
    pinned: z.optional(z.boolean()),
    tags: z.optional(z.array(z.string()))
});

/**
 * Quest Update Request
 * Quest update parameters
 */
export const zQuestUpdateRequest = z.object({
    quest: zQuestUpdateParams
});

/**
 * Set Primary Faction Request
 * Parameters for setting a character's primary faction
 */
export const zSetPrimaryFactionRequest = z.object({
    faction_id: z.uuid(),
    role: z.string()
});

/**
 * Faction Links Data
 * Links associated with a faction
 */
export const zFactionLinksData = z.object({
    faction_id: z.uuid(),
    faction_name: z.string(),
    links: z.optional(zFactionLinks)
});

/**
 * Faction Links Response
 * Response containing faction links
 */
export const zFactionLinksResponse = z.object({
    data: z.optional(zFactionLinksData)
});

/**
 * Character Update Parameters
 * Parameters for updating an existing character (partial updates supported)
 */
export const zCharacterUpdateParams = z.object({
    class: z.optional(z.string()),
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    faction_role: z.optional(z.string()),
    image_url: z.optional(z.string()),
    level: z.optional(z.int()),
    member_of_faction_id: z.optional(z.uuid()),
    name: z.optional(z.string()),
    pinned: z.optional(z.boolean()),
    tags: z.optional(z.array(z.string()))
});

/**
 * Character Update Request
 * Character update parameters
 */
export const zCharacterUpdateRequest = z.object({
    character: zCharacterUpdateParams
});

/**
 * Auth Status Response
 * Authentication status response
 */
export const zAuthStatusResponse = z.object({
    authenticated: z.boolean(),
    user: z.optional(zUser)
});

/**
 * Character Notes Tree Data
 * Hierarchical tree of notes associated with a character
 */
export const zCharacterNotesTreeData = z.object({
    character_id: z.uuid(),
    character_name: z.string(),
    notes_tree: z.optional(z.array(zNoteTreeNode))
});

/**
 * Faction Response
 * Response containing a single faction
 */
export const zFactionResponse = z.object({
    data: z.optional(zFaction)
});

/**
 * Faction Members Response
 * Response containing faction members
 */
export const zFactionMembersResponse = z.object({
    data: z.optional(zFactionMembersData)
});

/**
 * Note Update Parameters
 * Parameters for updating an existing note (partial updates supported)
 */
export const zNoteUpdateParams = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    name: z.optional(z.string()),
    parent_id: z.optional(z.union([
        z.uuid(),
        z.null()
    ])),
    parent_type: z.optional(z.enum([
        'character',
        'quest',
        'location',
        'faction'
    ])),
    pinned: z.optional(z.boolean()),
    tags: z.optional(z.array(z.string()))
});

/**
 * Note Update Request
 * Note update parameters
 */
export const zNoteUpdateRequest = z.object({
    note: zNoteUpdateParams
});

/**
 * Location Tree Node
 * A node in the location hierarchy tree
 */
export const zLocationTreeNode = z.object({
    get children(): z.ZodOptional {
        return z.optional(z.array(z.lazy((): any => {
            return zLocationTreeNode;
        })));
    },
    content: z.optional(z.string()),
    entity_type: z.enum([
        'location'
    ]),
    id: z.uuid(),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    tags: z.optional(z.array(z.string())),
    type: z.enum([
        'continent',
        'nation',
        'region',
        'city',
        'settlement',
        'building',
        'complex'
    ])
});

/**
 * Location Tree Response
 * Response containing hierarchical location tree
 */
export const zLocationTreeResponse = z.object({
    data: z.optional(z.array(zLocationTreeNode))
});

/**
 * Note Links Data
 * Links associated with a note
 */
export const zNoteLinksData = z.object({
    links: z.optional(zNoteLinks),
    note_id: z.uuid(),
    note_name: z.string()
});

/**
 * Note Links Response
 * Response containing note links
 */
export const zNoteLinksResponse = z.object({
    data: z.optional(zNoteLinksData)
});

/**
 * Pinned Entities Response
 * Response containing all pinned entities for a game
 */
export const zPinnedEntitiesResponse = z.object({
    data: z.optional(zPinnedEntitiesData)
});

/**
 * Game Response
 * Response containing a single game
 */
export const zGameResponse = z.object({
    data: z.optional(zGame)
});

/**
 * Quests Response
 * Response containing a list of quests
 */
export const zQuestsResponse = z.object({
    data: z.optional(z.array(zQuest))
});

/**
 * Note Response
 * Response containing a single note
 */
export const zNoteResponse = z.object({
    data: z.optional(zNote)
});

/**
 * Error
 * Error response
 */
export const zError = z.object({
    errors: z.optional(zErrorDetails)
});

/**
 * Locations Response
 * Response containing a list of locations
 */
export const zLocationsResponse = z.object({
    data: z.optional(z.array(zLocation))
});

/**
 * Game Update Parameters
 * Parameters for updating an existing game (partial updates supported)
 */
export const zGameUpdateParams = z.object({
    content: z.optional(z.string()),
    content_plain_text: z.optional(z.string()),
    name: z.optional(z.string()),
    setting: z.optional(z.string())
});

/**
 * Quest Tree Response
 * Response containing hierarchical quest tree
 */
export const zQuestTreeResponse = z.object({
    data: z.optional(z.array(zQuestTreeNode))
});

/**
 * Login Response
 * Successful login response
 */
export const zLoginResponse = z.object({
    token: z.string(),
    user: zUser
});

/**
 * Quest Create Parameters
 * Parameters for creating a new quest
 */
export const zQuestCreateParams = z.object({
    content: z.string(),
    content_plain_text: z.optional(z.string()),
    name: z.string(),
    parent_id: z.optional(z.uuid()),
    tags: z.optional(z.array(z.string()))
});

/**
 * Game Update Request
 * Game update parameters
 */
export const zGameUpdateRequest = z.object({
    game: zGameUpdateParams
});

/**
 * Faction Create Request
 * Faction creation parameters
 */
export const zFactionCreateRequest = z.object({
    faction: zFactionCreateParams
});

/**
 * Character Notes Tree Response
 * Response containing character notes tree
 */
export const zCharacterNotesTreeResponse = z.object({
    data: z.optional(zCharacterNotesTreeData)
});

/**
 * Quest Create Request
 * Quest creation parameters
 */
export const zQuestCreateRequest = z.object({
    quest: zQuestCreateParams
});

export const zGetFactionLinksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        faction_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetFactionLinksResponse = zFactionLinksResponse;

export const zCreateFactionLinkData = z.object({
    body: zLinkRequest,
    path: z.object({
        game_id: z.uuid(),
        faction_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zListLocationsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zListLocationsResponse = zLocationsResponse;

export const zCreateLocationData = z.object({
    body: zLocationCreateRequest,
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Created
 */
export const zCreateLocationResponse = zLocationResponse;

export const zLogoutUserData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zLoginUserData = z.object({
    body: zLoginRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zLoginUserResponse = zLoginResponse;

export const zDeleteLocationLinkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        location_id: z.uuid(),
        entity_type: z.enum([
            'character',
            'faction',
            'location',
            'quest',
            'note'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zUpdateLocationLinkData = z.object({
    body: zLinkUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        location_id: z.uuid(),
        entity_type: z.enum([
            'note',
            'character',
            'faction',
            'quest',
            'location'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateLocationLinkResponse = z.object({
    entity_id: z.optional(z.uuid()),
    entity_type: z.optional(z.string()),
    location_id: z.optional(z.uuid()),
    message: z.optional(z.string()),
    updated_at: z.optional(z.iso.datetime())
});

export const zListGameMembersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zListGameMembersResponse = zMembersResponse;

export const zAddGameMemberData = z.object({
    body: z.object({
        user_id: z.int(),
        role: z.optional(z.string())
    }),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zGetCharacterNotesTreeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetCharacterNotesTreeResponse = zCharacterNotesTreeResponse;

export const zDeleteLocationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zGetLocationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetLocationResponse = zLocationResponse;

export const zUpdateLocationData = z.object({
    body: zLocationUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateLocationResponse = zLocationResponse;

export const zListFactionsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zListFactionsResponse = zFactionsResponse;

export const zCreateFactionData = z.object({
    body: zFactionCreateRequest,
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Created
 */
export const zCreateFactionResponse = zFactionResponse;

export const zDeleteCharacterLinkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        character_id: z.uuid(),
        entity_type: z.enum([
            'note',
            'faction',
            'location',
            'quest',
            'character'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zUpdateCharacterLinkData = z.object({
    body: zLinkUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        character_id: z.uuid(),
        entity_type: z.enum([
            'note',
            'faction',
            'location',
            'quest',
            'character'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateCharacterLinkResponse = z.object({
    character_id: z.optional(z.uuid()),
    entity_id: z.optional(z.uuid()),
    entity_type: z.optional(z.string()),
    message: z.optional(z.string()),
    updated_at: z.optional(z.iso.datetime())
});

export const zListGameEntitiesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zListGameEntitiesResponse = zEntitiesResponse;

export const zGetNoteLinksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        note_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetNoteLinksResponse = zNoteLinksResponse;

export const zCreateNoteLinkData = z.object({
    body: zLinkRequest,
    path: z.object({
        game_id: z.uuid(),
        note_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Created
 */
export const zCreateNoteLinkResponse = z.object({
    entity_id: z.optional(z.uuid()),
    entity_type: z.optional(z.string()),
    message: z.optional(z.string()),
    note_id: z.optional(z.uuid())
});

export const zGetLocationTreeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetLocationTreeResponse = zLocationTreeResponse;

export const zRemoveCharacterPrimaryFactionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        character_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zRemoveCharacterPrimaryFactionResponse = zCharacterResponse;

export const zGetCharacterPrimaryFactionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        character_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetCharacterPrimaryFactionResponse = zCharacterPrimaryFactionResponse;

export const zSetCharacterPrimaryFactionData = z.object({
    body: zSetPrimaryFactionRequest,
    path: z.object({
        game_id: z.uuid(),
        character_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zSetCharacterPrimaryFactionResponse = zCharacterResponse;

export const zPinCharacterData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        character_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zPinCharacterResponse = zCharacterResponse;

export const zGetFactionMembersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        faction_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetFactionMembersResponse = zFactionMembersResponse;

export const zListQuestsData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zListQuestsResponse = zQuestsResponse;

export const zCreateQuestData = z.object({
    body: zQuestCreateRequest,
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Created
 */
export const zCreateQuestResponse = zQuestResponse;

export const zDeleteNoteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zGetNoteData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetNoteResponse = zNoteResponse;

export const zUpdateNoteData = z.object({
    body: zNoteUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateNoteResponse = zNoteResponse;

export const zGetCharacterLinksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        character_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetCharacterLinksResponse = zCharacterLinksResponse;

export const zCreateCharacterLinkData = z.object({
    body: zLinkRequest,
    path: z.object({
        game_id: z.uuid(),
        character_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zListCharactersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zListCharactersResponse = zCharactersResponse;

export const zCreateCharacterData = z.object({
    body: zCharacterCreateRequest,
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Created
 */
export const zCreateCharacterResponse = zCharacterResponse;

export const zDeleteGameData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zGetGameData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetGameResponse = zGameResponse;

export const zUpdateGameData = z.object({
    body: zGameUpdateRequest,
    path: z.object({
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateGameResponse = zGameResponse;

export const zGetGameEntityTreeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.object({
        depth: z.optional(z.int()),
        start_entity_type: z.optional(z.string()),
        start_entity_id: z.optional(z.uuid())
    }))
});

/**
 * Success
 */
export const zGetGameEntityTreeResponse = zEntityTreeResponse;

export const zUnpinCharacterData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        character_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUnpinCharacterResponse = zCharacterResponse;

export const zSignupUserData = z.object({
    body: zSignupRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Created
 */
export const zSignupUserResponse = zLoginResponse;

export const zGetAuthStatusData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetAuthStatusResponse = zAuthStatusResponse;

export const zDeleteQuestData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zGetQuestData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetQuestResponse = zQuestResponse;

export const zUpdateQuestData = z.object({
    body: zQuestUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateQuestResponse = zQuestResponse;

export const zGetLocationLinksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        location_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetLocationLinksResponse = zLocationLinksResponse;

export const zCreateLocationLinkData = z.object({
    body: zLinkRequest,
    path: z.object({
        game_id: z.uuid(),
        location_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zDeleteNoteLinkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        note_id: z.uuid(),
        entity_type: z.enum([
            'character',
            'faction',
            'location',
            'quest',
            'note'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zUpdateNoteLinkData = z.object({
    body: zLinkUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        note_id: z.uuid(),
        entity_type: z.enum([
            'character',
            'faction',
            'location',
            'quest',
            'note'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateNoteLinkResponse = z.object({
    entity_id: z.optional(z.uuid()),
    entity_type: z.optional(z.string()),
    message: z.optional(z.string()),
    note_id: z.optional(z.uuid()),
    updated_at: z.optional(z.iso.datetime())
});

export const zDeleteCharacterData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zGetCharacterData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetCharacterResponse = zCharacterResponse;

export const zUpdateCharacterData = z.object({
    body: zCharacterUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateCharacterResponse = zCharacterResponse;

export const zGetQuestLinksData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        quest_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetQuestLinksResponse = zQuestLinksResponse;

export const zCreateQuestLinkData = z.object({
    body: zLinkRequest,
    path: z.object({
        game_id: z.uuid(),
        quest_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zDeleteFactionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zGetFactionData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetFactionResponse = zFactionResponse;

export const zUpdateFactionData = z.object({
    body: zFactionUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateFactionResponse = zFactionResponse;

export const zRemoveGameMemberData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        user_id: z.int()
    }),
    query: z.optional(z.never())
});

export const zDeleteFactionLinkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        faction_id: z.uuid(),
        entity_type: z.enum([
            'character',
            'location',
            'quest',
            'note',
            'faction'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zUpdateFactionLinkData = z.object({
    body: zLinkUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        faction_id: z.uuid(),
        entity_type: z.enum([
            'note',
            'character',
            'location',
            'quest',
            'faction'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateFactionLinkResponse = z.object({
    entity_id: z.optional(z.uuid()),
    entity_type: z.optional(z.string()),
    faction_id: z.optional(z.uuid()),
    message: z.optional(z.string()),
    updated_at: z.optional(z.iso.datetime())
});

export const zListNotesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zListNotesResponse = zNotesResponse;

export const zCreateNoteData = z.object({
    body: zNoteCreateRequest,
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Created
 */
export const zCreateNoteResponse = zNoteResponse;

export const zListPinnedEntitiesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zListPinnedEntitiesResponse = zPinnedEntitiesResponse;

export const zListGamesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zListGamesResponse = zGamesResponse;

export const zCreateGameData = z.object({
    body: zGameCreateRequest,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Created
 */
export const zCreateGameResponse = zGameResponse;

export const zDeleteQuestLinkData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid(),
        quest_id: z.uuid(),
        entity_type: z.enum([
            'character',
            'faction',
            'location',
            'note',
            'quest'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

export const zUpdateQuestLinkData = z.object({
    body: zLinkUpdateRequest,
    path: z.object({
        game_id: z.uuid(),
        quest_id: z.uuid(),
        entity_type: z.enum([
            'note',
            'character',
            'faction',
            'location',
            'quest'
        ]),
        entity_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zUpdateQuestLinkResponse = z.object({
    entity_id: z.optional(z.uuid()),
    entity_type: z.optional(z.string()),
    message: z.optional(z.string()),
    quest_id: z.optional(z.uuid()),
    updated_at: z.optional(z.iso.datetime())
});

export const zGetQuestTreeData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        game_id: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zGetQuestTreeResponse = zQuestTreeResponse;
</file>

<file path="src/components/characters/character-menu.tsx">
import { Link, useParams } from "@tanstack/react-router";
import { Pencil, Trash2 } from "lucide-react";
import {
	Menubar,
	MenubarContent,
	MenubarItem,
	MenubarMenu,
	MenubarPositioner,
	MenubarSub,
	MenubarSubTrigger,
	MenubarTrigger,
} from "../ui/menubar";

interface CharacterMenuProps {
	onEditDetails: () => void;
	onDelete: () => void;
}

export function CharacterMenu({ onEditDetails, onDelete }: CharacterMenuProps) {
	const params = useParams({ from: "/_auth/games/$gameId/characters/$id" });
	return (
		<Menubar className={"w-fit"}>
			<MenubarMenu>
				<MenubarTrigger>File</MenubarTrigger>
				<MenubarPositioner>
					<MenubarContent>
						<MenubarItem onClick={onEditDetails}>
							<Pencil className="w-4 h-4 mr-2" />
							Edit Details
						</MenubarItem>
						<MenubarItem onClick={onDelete}>
							<Trash2 className="w-4 h-4 mr-2" />
							Delete
						</MenubarItem>
					</MenubarContent>
				</MenubarPositioner>
			</MenubarMenu>
			<MenubarMenu>
				<MenubarTrigger>View</MenubarTrigger>
				<MenubarPositioner>
					<MenubarContent>
						<MenubarItem
							render={
								<Link
									to="/games/$gameId/characters/$id"
									params={params}
								/>
							}
						>
							Description
						</MenubarItem>
						<MenubarSub>
							<MenubarSubTrigger>Links..</MenubarSubTrigger>
							<MenubarPositioner>
								<MenubarContent>
									<MenubarItem>All</MenubarItem>
									<MenubarItem>Faction</MenubarItem>
									<MenubarItem>Characters</MenubarItem>
									<MenubarItem>Quests</MenubarItem>
								</MenubarContent>
							</MenubarPositioner>
						</MenubarSub>
						<MenubarItem>Create</MenubarItem>
					</MenubarContent>
				</MenubarPositioner>
			</MenubarMenu>
			<MenubarMenu>
				<MenubarTrigger>Faction</MenubarTrigger>
				<MenubarPositioner>
					<MenubarContent>
						<MenubarItem>Go..</MenubarItem>
						<MenubarItem>Delete</MenubarItem>
					</MenubarContent>
				</MenubarPositioner>
			</MenubarMenu>
		</Menubar>
	);
}
</file>

<file path="src/components/characters/character-note-view.tsx">
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Trash2 } from "lucide-react";
import * as React from "react";
import {
	getCharacterNotesTreeQueryKey,
	updateNoteMutation,
	useGetCharacterNotesTreeQuery,
} from "~/api/@tanstack/react-query.gen";
import { SelectNoteCombobox } from "~/components/characters/select-note-combobox";
import { CreateNoteSheet } from "~/components/notes/create-note-sheet";
import { Button } from "~/components/ui/button";
import { Link } from "~/components/ui/link";
import { ScrollArea } from "~/components/ui/scroll-area";
import { SidebarMenu, SidebarMenuButton, SidebarMenuItem } from "~/components/ui/sidebar";
import { TiptapViewer } from "../ui/editor/viewer";

interface CharacterNotesViewProps {
	gameId: string;
	characterId: string;
}

export function CharacterNotesView({ gameId, characterId }: CharacterNotesViewProps) {
	const client = useQueryClient();

	const [isOpen, setIsOpen] = React.useState(false);
	const [selectedNoteId, setSelectedNoteId] = React.useState<string | null>(null);

	const { data: noteTree } = useGetCharacterNotesTreeQuery({
		path: { game_id: gameId, id: characterId },
	});

	const notes = noteTree?.data?.notes_tree || [];
	const selectedNote = notes.find((note) => note.id === selectedNoteId);

	// Auto-select first note if none selected
	React.useEffect(() => {
		if (notes.length > 0 && !selectedNoteId) {
			setSelectedNoteId(notes[0].id);
		}
	}, [notes, selectedNoteId]);

	const removeNote = useMutation({
		...updateNoteMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: getCharacterNotesTreeQueryKey({
					path: { game_id: gameId, id: characterId },
				}),
			});
		},
	});

	const handleDeleteNote = (noteId: string) => {
		if (selectedNoteId === noteId && notes.length > 1) {
			const currentIndex = notes.findIndex((note) => note.id === noteId);
			const nextNote = notes[currentIndex + 1] || notes[currentIndex - 1];
			setSelectedNoteId(nextNote?.id || null);
		}

		removeNote.mutateAsync({
			path: { game_id: gameId, id: noteId },
			body: {
				note: { parent_id: null, parent_type: null as any },
			},
		});
	};

	return (
		<>
			<div className="space-y-4">
				<div className="flex gap-4">
					<Button onClick={() => setIsOpen(true)}>Create Note</Button>
					<SelectNoteCombobox gameId={gameId} characterId={characterId} />
				</div>

				<div className="flex flex-col lg:flex-row gap-4 min-h-[calc(100vh-26rem)]">
					{/* Notes List - Left Column */}
					<div className="w-full lg:w-1/4 border rounded-lg bg-sidebar">
						<div className="p-2">
							<ScrollArea className="max-h-[calc(100vh-28rem)]">
								{notes.length === 0 ? (
									<div className="p-4 text-center text-sidebar-foreground/60">
										No notes found
									</div>
								) : (
									<SidebarMenu>
										{notes.map((note) => (
											<SidebarMenuItem
												key={note.id}
												className="group relative"
											>
												<SidebarMenuButton
													isActive={selectedNoteId === note.id}
													onClick={() =>
														setSelectedNoteId(note.id)
													}
													className="w-full pr-8"
												>
													<span className="truncate">
														{note.name}
													</span>
												</SidebarMenuButton>
												<Button
													variant="ghost"
													size="sm"
													className="absolute right-1 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 h-6 w-6 p-0 hover:bg-sidebar-accent z-10"
													onClick={(e) => {
														e.stopPropagation();
														handleDeleteNote(note.id);
													}}
												>
													<Trash2 className="h-3 w-3" />
												</Button>
											</SidebarMenuItem>
										))}
									</SidebarMenu>
								)}
							</ScrollArea>
						</div>
					</div>

					{/* Note Preview - Right Column */}
					<div className="flex-1 border rounded-lg bg-background">
						{selectedNote ? (
							<div className="flex flex-col">
								<div className="p-4 border-b bg-muted/30">
									<div className="flex justify-between items-center">
										<h2 className="text-xl font-semibold">
											{selectedNote.name}
										</h2>
										<Link
											to="/games/$gameId/notes/$id"
											params={{ gameId, id: selectedNote.id }}
										>
											<Button variant="outline" size="sm">
												Open in full editor
											</Button>
										</Link>
									</div>
								</div>
								<div className="p-4">
									<TiptapViewer
										key={selectedNote.id}
										content={selectedNote.content}
									/>
								</div>
							</div>
						) : (
							<div className="min-h-[calc(100vh-32rem)] flex items-center justify-center text-muted-foreground">
								Select a note to preview
							</div>
						)}
					</div>
				</div>
			</div>
			<CreateNoteSheet
				isOpen={isOpen}
				setIsOpen={setIsOpen}
				parentType="character"
				parentId={characterId}
			/>
		</>
	);
}
</file>

<file path="src/components/characters/create-character-sheet.tsx">
import { Sheet, SheetContent } from "../ui/sheet";
import { CreateCharacterForm } from "./create-character-form";

interface CreateCharacterSheetProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
}

export function CreateCharacterSheet({ isOpen, setIsOpen }: CreateCharacterSheetProps) {
	return (
		<Sheet open={isOpen} onOpenChange={setIsOpen}>
			<SheetContent className="p-4 pt-10 overflow-scroll" width="lg">
				<CreateCharacterForm />
			</SheetContent>
		</Sheet>
	);
}
</file>

<file path="src/components/characters/edit-character-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import type { CharacterUpdateParams } from "~/api";
import {
	getCharacterQueryKey,
	listCharactersQueryKey,
	updateCharacterMutation,
} from "~/api/@tanstack/react-query.gen";
import { createSmartForm } from "../forms/smart-factory";
import { schemas } from "../forms/type-utils";

interface EditCharacterFormProps {
	params: {
		gameId: string;
		id: string;
	};
	initialData?: Partial<CharacterUpdateParams>;
}

export function EditCharacterForm({ initialData, params }: EditCharacterFormProps) {
	const { gameId, id } = params;
	const queryClient = useQueryClient();
	const navigate = useNavigate();

	// Create form component with proper context handling
	const FormComponent = createSmartForm({
		mutation: () =>
			updateCharacterMutation({
				path: {
					game_id: gameId,
					id,
				},
			}),
		onSuccess: async () => {
			toast("Character updated successfully!");
			queryClient.invalidateQueries({
				queryKey: listCharactersQueryKey({
					path: { game_id: gameId },
				}),
			});
			queryClient.invalidateQueries({
				queryKey: getCharacterQueryKey({
					path: {
						game_id: gameId,
						id: id,
					},
				}),
			});
			navigate({ to: ".." });
		},
		schema: schemas.character,
		entityName: "character",
		initialValues: {
			...initialData,
			image_url: initialData?.image_url || undefined,
		},
		fieldOverrides: {
			content: null,
		},
	});

	return <FormComponent />;
}
</file>

<file path="src/components/factions/edit-faction-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import type { Faction } from "~/api";
import {
	getFactionQueryKey,
	listFactionsQueryKey,
	updateFactionMutation,
} from "~/api/@tanstack/react-query.gen";
import { createSmartForm } from "../forms/smart-factory";
import { schemas } from "../forms/type-utils";

interface EditFactionFormProps {
	params: {
		gameId: string;
		id: string;
	};
	initialData?: Partial<Faction>;
}

export function EditFactionForm({ initialData, params }: EditFactionFormProps) {
	const { gameId, id } = params;
	const queryClient = useQueryClient();

	const FormWithContext = createSmartForm({
		mutation: () =>
			updateFactionMutation({
				path: {
					game_id: gameId,
					id: id,
				},
			}),

		onSuccess: async () => {
			queryClient.invalidateQueries({
				queryKey: listFactionsQueryKey({
					path: { game_id: gameId },
				}),
			});
			queryClient.invalidateQueries({
				queryKey: getFactionQueryKey({
					path: {
						game_id: gameId,
						id: id,
					},
				}),
			});
		},
		schema: schemas.faction,
		initialValues: initialData,
		entityName: "faction",
		fieldOverrides: {
			content: null,
		},
	});

	return <FormWithContext />;
}
</file>

<file path="src/components/forms/schemas.ts">
import { z } from "zod";

// Schema generators based on your Swagger definitions

export const schemas = {
	// Character schemas
	character: z.object({
		character: z.object({
			name: z.string().min(1, "Name is required"),
			class: z.string().min(1, "Class is required"),
			level: z.number().min(1).max(20),
			content: z.string().optional(),
			image_url: z.url().optional().or(z.literal("")),
		}),
	}),

	// Faction schemas
	faction: z.object({
		faction: z.object({
			name: z.string().min(1, "Name is required"),
			content: z.string().min(1, "Content is required"),
		}),
	}),

	// Location schemas
	location: z.object({
		location: z.object({
			name: z.string().min(1, "Name is required"),
			type: z.enum([
				"continent",
				"nation",
				"region",
				"city",
				"settlement",
				"building",
				"complex",
			]),
			content: z.string().optional(),
			parent_id: z.string().optional(),
		}),
	}),

	// Quest schemas
	quest: z.object({
		quest: z.object({
			name: z.string().min(1, "Name is required"),
			content: z.string().min(1, "Content is required"),
		}),
	}),

	// Note schemas
	note: z.object({
		note: z.object({
			name: z.string().min(1, "Name is required"),
			content: z.string().min(1, "Content is required"),
		}),
	}),

	// Game schemas
	game: z.object({
		game: z.object({
			name: z.string().min(1, "Name is required"),
			content: z.string().optional(),
			setting: z.string().optional(),
		}),
	}),

	// Link schemas
	link: z.object({
		entity_type: z.enum(["character", "faction", "location", "quest"]),
		entity_id: z.string().min(1, "Entity ID is required"),
	}),

	// Auth schemas
	login: z.object({
		email: z.email("Invalid email"),
		password: z.string().min(6, "Password must be at least 6 characters"),
	}),

	signup: z.object({
		email: z.email("Invalid email"),
		password: z.string().min(6, "Password must be at least 6 characters"),
	}),
};

// Field configurations for each entity type
export const fieldConfigs = {
	character: [
		{ name: "character.name", label: "Name", type: "text" as const, required: true },
		{
			name: "character.class",
			label: "Class",
			type: "text" as const,
			required: true,
		},
		{
			name: "character.level",
			label: "Level",
			type: "number" as const,
			required: true,
		},
		{
			name: "character.content",
			label: "Content",
			type: "textarea" as const,
		},
		{ name: "character.image_url", label: "Image URL", type: "text" as const },
	],

	faction: [
		{ name: "faction.name", label: "Name", type: "text" as const, required: true },
		{
			name: "faction.content",
			label: "Content",
			type: "textarea" as const,
			required: true,
		},
	],

	location: [
		{ name: "location.name", label: "Name", type: "text" as const, required: true },
		{
			name: "location.type",
			label: "Type",
			type: "select" as const,
			required: true,
			options: [
				{ value: "continent", label: "Continent" },
				{ value: "nation", label: "Nation" },
				{ value: "region", label: "Region" },
				{ value: "city", label: "City" },
				{ value: "settlement", label: "Settlement" },
				{ value: "building", label: "Building" },
				{ value: "complex", label: "Complex" },
			],
		},
		{ name: "location.content", label: "Content", type: "textarea" as const },
		{
			name: "location.parent_id",
			label: "Parent Location ID",
			type: "text" as const,
		},
	],

	quest: [
		{ name: "quest.name", label: "Name", type: "text" as const, required: true },
		{
			name: "quest.content",
			label: "Content",
			type: "textarea" as const,
			required: true,
		},
	],

	note: [
		{ name: "note.name", label: "Name", type: "text" as const, required: true },
		{
			name: "note.content",
			label: "Content",
			type: "textarea" as const,
			required: true,
		},
	],

	game: [
		{ name: "game.name", label: "Name", type: "text" as const, required: true },
		{ name: "game.content", label: "Content", type: "textarea" as const },
		{ name: "game.setting", label: "Setting", type: "text" as const },
	],

	link: [
		{
			name: "entity_type",
			label: "Entity Type",
			type: "select" as const,
			required: true,
			options: [
				{ value: "character", label: "Character" },
				{ value: "faction", label: "Faction" },
				{ value: "location", label: "Location" },
				{ value: "quest", label: "Quest" },
			],
		},
		{
			name: "entity_id",
			label: "Entity ID",
			type: "text" as const,
			required: true,
		},
	],

	login: [
		{ name: "email", label: "Email", type: "email" as const, required: true },
		{
			name: "password",
			label: "Password",
			type: "password" as const,
			required: true,
		},
	],

	signup: [
		{ name: "email", label: "Email", type: "email" as const, required: true },
		{
			name: "password",
			label: "Password",
			type: "password" as const,
			required: true,
		},
	],
};
</file>

<file path="src/components/links/create-link.tsx">
import * as React from "react";
import { toast } from "sonner";
import {
	Select,
	SelectContent,
	SelectGroup,
	SelectItem,
	SelectLabel,
	SelectPortal,
	SelectPositioner,
	SelectTrigger,
	SelectValue,
} from "~/components/ui/select";
import type { EntityType } from "~/types";
import { Button } from "../ui/button";
import { FormField } from "../ui/composite/form-field";
import { Label } from "../ui/label";
import { Textarea } from "../ui/textarea";
import { useCreateLink } from "./hooks/useCreateLink";
import { useGameEntities } from "./hooks/useGameEntities";

export interface CreateLinkFormProps {
	gameId: string;
	sourceEntityType: EntityType;
	sourceEntityId: string;
	onSuccess?: () => void;
	onError?: (error: Error) => void;
	excludeTypes?: EntityType[];
	excludeIds?: string[];
}

export function CreateLinkForm({
	gameId,
	sourceEntityType,
	sourceEntityId,
	onSuccess,
	onError,
	excludeTypes = [],
	excludeIds = [],
}: CreateLinkFormProps) {
	const [selectedValue, setSelectedValue] = React.useState("");
	const [relationshipValue, setRelationshipValue] = React.useState("");
	const [description, setDescription] = React.useState("");

	// Exclude self-referencing
	const finalExcludeIds = [...excludeIds, `${sourceEntityType}:${sourceEntityId}`];

	const {
		entities,
		isLoading,
		error: fetchError,
	} = useGameEntities(gameId, excludeTypes, finalExcludeIds);

	const createLink = useCreateLink(
		() => {
			setSelectedValue("");
			toast.success("Link created successfully");
			onSuccess?.();
		},
		(err) => {
			toast.error(`Failed to create link: ${err.message}`);
			onError?.(err);
		},
	);

	const handleSubmit = async (e: React.FormEvent) => {
		e.preventDefault();
		if (!selectedValue) return;

		const [targetType, targetId] = selectedValue.split(":");

		await createLink.mutateAsync({
			gameId,
			sourceType: sourceEntityType,
			sourceId: sourceEntityId,
			entity_type: targetType as EntityType,
			entity_id: targetId,
			relationship_type: relationshipValue,
			description,
		});
	};

	const hasEntities = Object.values(entities).some((group) => group.length > 0);

	// Find the label for the selected value
	const selectedLabel = React.useMemo(() => {
		if (!selectedValue) return "";

		for (const items of Object.values(entities)) {
			const selectedItem = items.find((item) => item.value === selectedValue);
			if (selectedItem) {
				return selectedItem.label;
			}
		}
		return selectedValue; // Fallback to value if label not found
	}, [selectedValue, entities]);

	if (fetchError) {
		return (
			<div className="text-sm text-red-600">
				Failed to load entities. Please try again.
			</div>
		);
	}

	return (
		<form onSubmit={handleSubmit}>
			<div className="flex flex-col gap-4">
				<div className="space-y-1">
					<Label>Target Link</Label>
					<Select
						disabled={isLoading || !hasEntities}
						value={selectedValue}
						onValueChange={(value) => setSelectedValue(value as string)}
					>
						<SelectTrigger className="w-full">
							<SelectValue
								placeholder={
									isLoading
										? "Loading entities..."
										: !hasEntities
											? "No entities available"
											: "Select an entity to link"
								}
							>
								{selectedLabel}
							</SelectValue>
						</SelectTrigger>
						<SelectPortal>
							<SelectPositioner>
								<SelectContent>
									{Object.entries(entities).map(
										([type, items]) =>
											items.length > 0 && (
												<SelectGroup key={type}>
													<SelectLabel className="capitalize">
														{type}
													</SelectLabel>
													{items.map((item) => (
														<SelectItem
															key={item.value}
															value={item.value}
														>
															{item.label}
														</SelectItem>
													))}
												</SelectGroup>
											),
									)}
								</SelectContent>
							</SelectPositioner>
						</SelectPortal>
					</Select>
				</div>

				<FormField
					label="Relationship"
					id="relationship"
					value={relationshipValue}
					onInput={(e) => setRelationshipValue(e.currentTarget.value)}
				/>

				<div className="space-y-1">
					<Label htmlFor="description">Description of connection</Label>
					<Textarea
						id="description"
						value={description}
						onInput={(e) => setDescription(e.currentTarget.value)}
					/>
				</div>

				<Button type="submit" disabled={!selectedValue || createLink.isPending}>
					{createLink.isPending ? "Creating Link..." : "Create Link"}
				</Button>
			</div>
		</form>
	);
}
</file>

<file path="src/components/locations/create-location-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useParams } from "@tanstack/react-router";
import { toast } from "sonner";
import {
	createLocationMutation,
	getLocationTreeQueryKey,
	listLocationsQueryKey,
	useListLocationsQuery,
} from "~/api/@tanstack/react-query.gen";
import { Button } from "~/components/ui/button";
import { useSmartForm } from "../forms/smart-factory";
import { schemas } from "../forms/type-utils";
import { ParentLocationSelect } from "./parent-location-select";

export function CreateLocationForm() {
	const { gameId } = useParams({ from: "/_auth/games/$gameId" });
	const queryClient = useQueryClient();

	// Fetch existing locations for parent selection
	const { data: locationsData, isLoading: locationsLoading } = useListLocationsQuery({
		path: { game_id: gameId },
	});
	const locations = locationsData?.data || [];

	const { form, mutation, renderSmartField } = useSmartForm({
		mutation: () =>
			createLocationMutation({
				path: { game_id: gameId },
			}),
		schema: schemas.location,
		entityName: "location",
		onSuccess: async () => {
			toast("Location created successfully!");
			queryClient.invalidateQueries({
				queryKey: listLocationsQueryKey({
					path: { game_id: gameId },
				}),
			});
			queryClient.invalidateQueries({
				queryKey: getLocationTreeQueryKey({
					path: { game_id: gameId },
				}),
			});
		},
	});

	return (
		<div className="space-y-6">
			<form.AppForm>
				<form
					onSubmit={(e) => {
						e.preventDefault();
						form.handleSubmit();
					}}
				>
					<div className="space-y-6">
						{renderSmartField("name")}
						{renderSmartField("type", {
							label: "Location Type",
						})}

						{/* Custom parent location selector */}
						<form.AppField name="parent_id">
							{(field) => (
								<form.Item>
									<field.Label>Parent Location</field.Label>
									<field.Control>
										{locationsLoading ? (
											<div className="text-muted-foreground text-sm p-2">
												Loading locations...
											</div>
										) : (
											<ParentLocationSelect
												locations={locations}
												value={field.state.value}
												onChange={field.handleChange}
												currentType={form.getFieldValue("type")}
												placeholder="Select parent location (optional)"
											/>
										)}
									</field.Control>
									<field.Description>
										Choose a parent location to create a hierarchical
										structure. Leave empty for top-level locations.
									</field.Description>
									<field.Message />
								</form.Item>
							)}
						</form.AppField>

						{renderSmartField("tags")}
						{renderSmartField("content")}

						<div className="flex gap-2">
							<Button type="submit" disabled={mutation.isPending}>
								{mutation.isPending ? "Creating..." : "Create Location"}
							</Button>

							<Button
								type="button"
								variant="outline"
								onClick={() => {
									if (
										form.state.isDirty &&
										!confirm(
											"Are you sure? All unsaved changes will be lost.",
										)
									) {
										return;
									}
									form.reset();
								}}
							>
								Reset
							</Button>
						</div>
					</div>
				</form>
			</form.AppForm>

			{mutation.isError && (
				<div className="mt-4 bg-destructive/10 border border-destructive/20 text-destructive px-4 py-3 rounded-md">
					<p className="text-sm">
						{(mutation.error as any)?.message || "Something went wrong"}
					</p>
				</div>
			)}
		</div>
	);
}
</file>

<file path="src/components/locations/parent-location-select.tsx">
import type { Location } from "~/api/types.gen";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectPositioner,
	SelectTrigger,
	SelectValue,
} from "~/components/ui/select";

interface ParentLocationSelectProps {
	locations: Location[];
	value?: string;
	onChange: (value: string | undefined) => void;
	currentType?: string;
	disabled?: boolean;
	placeholder?: string;
}

// Location type hierarchy - defines which types can be parents of which
const LOCATION_HIERARCHY = {
	continent: [],
	nation: ["continent"],
	region: ["continent", "nation"],
	city: ["continent", "nation", "region"],
	settlement: ["continent", "nation", "region", "city"],
	building: ["city", "settlement"],
	complex: ["city", "settlement", "building"],
} as const;

type LocationType = keyof typeof LOCATION_HIERARCHY;

function isValidParent(parentType: LocationType, currentType?: string): boolean {
	if (!currentType) return true;

	const validParentTypes = LOCATION_HIERARCHY[currentType as LocationType];
	return (validParentTypes as readonly LocationType[])?.includes(parentType) ?? false;
}

function buildLocationHierarchy(locations: Location[]): Map<string, Location[]> {
	const hierarchy = new Map<string, Location[]>();

	// Create a map for quick lookup
	const locationMap = new Map(locations.map((loc) => [loc.id, loc]));

	// Build hierarchy by following parent_id chains
	locations.forEach((location) => {
		const path: Location[] = [];
		let current: Location | undefined = location;

		// Traverse up the hierarchy to build the full path
		while (current && path.length < 10) {
			// Prevent infinite loops
			path.unshift(current);
			current = current.parent_id ? locationMap.get(current.parent_id) : undefined;
		}

		hierarchy.set(location.id, path);
	});

	return hierarchy;
}

function formatLocationLabel(location: Location, hierarchy: Location[]): string {
	if (hierarchy.length <= 1) {
		return location.name;
	}

	// Show hierarchy: "Grandparent > Parent > Location"
	const pathNames = hierarchy.slice(0, -1).map((loc) => loc.name);
	return `${location.name} (${pathNames.join(" > ")})`;
}

export function ParentLocationSelect({
	locations,
	value,
	onChange,
	currentType,
	disabled = false,
	placeholder = "Select parent location",
}: ParentLocationSelectProps) {
	// Filter locations that can be valid parents
	const validParentLocations = locations.filter((location) =>
		isValidParent(location.type as LocationType, currentType),
	);

	// Build hierarchy for display
	const hierarchy = buildLocationHierarchy(locations);

	// Sort locations by type hierarchy and then by name
	const typeOrder: Record<string, number> = {
		continent: 1,
		nation: 2,
		region: 3,
		city: 4,
		settlement: 5,
		building: 6,
		complex: 7,
	};

	const sortedLocations = validParentLocations.sort((a, b) => {
		const typeComparison = (typeOrder[a.type] || 999) - (typeOrder[b.type] || 999);
		if (typeComparison !== 0) return typeComparison;
		return a.name.localeCompare(b.name);
	});

	const handleValueChange = (selectedValue: string) => {
		if (selectedValue === "none") {
			onChange(undefined);
		} else {
			onChange(selectedValue);
		}
	};

	// Find the selected location to display its name
	const selectedLocation = value ? locations.find((loc) => loc.id === value) : null;
	const displayValue = value || "none";

	// Get the display name for the selected location
	const getSelectedDisplayName = () => {
		if (!selectedLocation) return undefined;
		const locationHierarchy = hierarchy.get(selectedLocation.id) || [
			selectedLocation,
		];
		return formatLocationLabel(selectedLocation, locationHierarchy);
	};

	return (
		<Select
			value={displayValue}
			onValueChange={handleValueChange}
			disabled={disabled}
		>
			<SelectTrigger className="w-full">
				<SelectValue placeholder={placeholder}>
					{selectedLocation ? (
						<div className="flex items-center gap-2">
							<span className="text-xs bg-muted px-1.5 py-0.5 rounded text-muted-foreground">
								{selectedLocation.type}
							</span>
							<span>{getSelectedDisplayName()}</span>
						</div>
					) : displayValue === "none" ? (
						<span className="text-muted-foreground">
							No parent (top-level location)
						</span>
					) : null}
				</SelectValue>
			</SelectTrigger>
			<SelectPositioner>
				<SelectContent>
					<SelectItem value="none">
						<span className="text-muted-foreground">
							No parent (top-level location)
						</span>
					</SelectItem>

					{sortedLocations.map((location) => {
						const locationHierarchy = hierarchy.get(location.id) || [
							location,
						];
						const label = formatLocationLabel(location, locationHierarchy);

						return (
							<SelectItem key={location.id} value={location.id}>
								<div className="flex items-center gap-2">
									<span className="text-xs bg-muted px-1.5 py-0.5 rounded text-muted-foreground">
										{location.type}
									</span>
									<span>{label}</span>
								</div>
							</SelectItem>
						);
					})}

					{sortedLocations.length === 0 && (
						<SelectItem value="disabled" disabled>
							<span className="text-muted-foreground">
								{currentType
									? `No valid parent locations for ${currentType}`
									: "No locations available"}
							</span>
						</SelectItem>
					)}
				</SelectContent>
			</SelectPositioner>
		</Select>
	);
}
</file>

<file path="src/components/notes/create-note-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useParams } from "@tanstack/react-router";
import { toast } from "sonner";
import { createNoteMutation, listNotesQueryKey } from "~/api/@tanstack/react-query.gen";
import { Button } from "~/components/ui/button";
import type { EntityType } from "~/types";
import { useSmartForm } from "../forms/smart-factory";
import { schemas } from "../forms/type-utils";

interface CreateNoteFormProps {
	/** Optional parent entity ID */
	parentId?: string;
	/** Optional parent entity type */
	parentType?: EntityType;
	/** Custom CSS class for form container */
	className?: string;
	/** Custom submit button text */
	submitText?: string;
	/** Custom success callback (overrides default navigation) */
	onSuccess?: () => void;
}

export function CreateNoteForm({
	parentId,
	parentType,
	className = "space-y-6",
	submitText = "Create Note",
	onSuccess: customOnSuccess,
}: CreateNoteFormProps = {}) {
	const { gameId } = useParams({ from: "/_auth/games/$gameId" });
	const queryClient = useQueryClient();

	// Prepare initial values with parent info if provided
	const initialValues = {
		...(parentId && { parent_id: parentId }),
		...(parentType && { parent_type: parentType }),
	};

	const { form, mutation, renderSmartField } = useSmartForm({
		mutation: () =>
			createNoteMutation({
				path: { game_id: gameId },
			}),
		schema: schemas.note,
		entityName: "note",
		initialValues,
		onSuccess: async () => {
			toast("Note created successfully!");
			await queryClient.refetchQueries({
				queryKey: listNotesQueryKey({
					path: { game_id: gameId },
				}),
			});

			if (customOnSuccess) {
				customOnSuccess();
			} else {
			}
		},
	});

	return (
		<div className={className}>
			<form.AppForm>
				<form
					onSubmit={(e) => {
						e.preventDefault();
						form.handleSubmit();
					}}
				>
					<div className="space-y-6">
						{renderSmartField("name")}
						{renderSmartField("tags")}

						{/* Only show parent fields if not pre-filled via props */}
						{!parentId &&
							renderSmartField("parent_id", {
								label: "Parent Entity ID",
								description:
									"Optional ID of the parent entity this note belongs to",
							})}

						{!parentType &&
							renderSmartField("parent_type", {
								label: "Parent Entity Type",
								description: "Type of the parent entity",
							})}

						{renderSmartField("content")}

						<div className="flex gap-2">
							<Button type="submit" disabled={mutation.isPending}>
								{mutation.isPending ? "Creating..." : submitText}
							</Button>

							<Button
								type="button"
								variant="outline"
								onClick={() => {
									if (
										form.state.isDirty &&
										!confirm(
											"Are you sure? All unsaved changes will be lost.",
										)
									) {
										return;
									}
									form.reset();
								}}
							>
								Reset
							</Button>
						</div>
					</div>
				</form>
			</form.AppForm>

			{mutation.isError && (
				<div className="mt-4 bg-destructive/10 border border-destructive/20 text-destructive px-4 py-3 rounded-md">
					<p className="text-sm">
						{(mutation.error as any)?.message || "Something went wrong"}
					</p>
				</div>
			)}
		</div>
	);
}
</file>

<file path="src/components/notes/edit-note-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import type { NoteUpdateParams } from "~/api";
import {
	getNoteQueryKey,
	listNotesQueryKey,
	updateNoteMutation,
} from "~/api/@tanstack/react-query.gen";
import { createSmartForm } from "../forms/smart-factory";
import { schemas } from "../forms/type-utils";

interface EditNoteFormProps {
	params: {
		gameId: string;
		id: string;
	};
	initialData?: Partial<NoteUpdateParams>;
}

export function EditNoteForm({ initialData, params }: EditNoteFormProps) {
	const { gameId, id } = params;
	const queryClient = useQueryClient();
	const navigate = useNavigate();

	const FormComponent = createSmartForm({
		mutation: () =>
			updateNoteMutation({
				path: {
					game_id: gameId,
					id,
				},
			}),
		onSuccess: async () => {
			toast("Note updated successfully!");
			queryClient.invalidateQueries({
				queryKey: listNotesQueryKey({
					path: { game_id: gameId },
				}),
			});
			queryClient.invalidateQueries({
				queryKey: getNoteQueryKey({
					path: {
						game_id: gameId,
						id: id,
					},
				}),
			});
			navigate({ to: ".." });
		},
		schema: schemas.note,
		entityName: "note",
		initialValues: {
			...initialData,
			image_url: initialData?.image_url || undefined,
		},
		fieldOverrides: {
			content: null,
		},
	});

	return <FormComponent />;
}
</file>

<file path="src/components/quests/create-quest-sheet.tsx">
import * as React from "react";
import { Sheet, SheetContent } from "../ui/sheet";
import { CreateQuestForm } from "./create-quest-form";

interface CreateQuestSheetProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
}

export function CreateQuestSheet({ isOpen, setIsOpen }: CreateQuestSheetProps) {
	const sheetRef = React.useRef<HTMLDivElement>(null);
	return (
		<Sheet open={isOpen} onOpenChange={setIsOpen}>
			<SheetContent className="p-4 pt-10" width="lg" ref={sheetRef}>
				<CreateQuestForm container={sheetRef} />
			</SheetContent>
		</Sheet>
	);
}
</file>

<file path="src/components/quests/parent-quest-select.tsx">
import type { Quest } from "~/api/types.gen";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectPortal,
	SelectPositioner,
	SelectTrigger,
	SelectValue,
} from "~/components/ui/select";

interface ParentQuestSelectProps {
	quests: Quest[];
	value?: string;
	onChange: (value: string | undefined) => void;
	disabled?: boolean;
	placeholder?: string;
	container?: React.RefObject<HTMLElement | null>;
}

function buildQuestHierarchy(quests: Quest[]): Map<string, Quest[]> {
	const hierarchy = new Map<string, Quest[]>();

	// Create a map for quick lookup
	const questMap = new Map(quests.map((quest) => [quest.id, quest]));

	// Build hierarchy by following parent_id chains
	quests.forEach((quest) => {
		const path: Quest[] = [];
		let current: Quest | undefined = quest;

		// Traverse up the hierarchy to build the full path
		while (current && path.length < 10) {
			// Prevent infinite loops
			path.unshift(current);
			current = current.parent_id ? questMap.get(current.parent_id) : undefined;
		}

		hierarchy.set(quest.id, path);
	});

	return hierarchy;
}

function formatQuestLabel(quest: Quest, hierarchy: Quest[]): string {
	if (hierarchy.length <= 1) {
		return quest.name;
	}

	// Show hierarchy: "Main Quest > Sub Quest > Current Quest"
	const pathNames = hierarchy.slice(0, -1).map((q) => q.name);
	return `${quest.name} (${pathNames.join(" > ")})`;
}

export function ParentQuestSelect({
	quests,
	value,
	onChange,
	disabled = false,
	placeholder = "Select parent quest",
	container,
}: ParentQuestSelectProps) {
	// Build hierarchy for display
	const hierarchy = buildQuestHierarchy(quests);

	// Sort quests alphabetically by name
	const sortedQuests = [...quests].sort((a, b) => a.name.localeCompare(b.name));

	const handleValueChange = (selectedValue: unknown) => {
		if (selectedValue === "none") {
			onChange(undefined);
		} else {
			onChange(selectedValue as string);
		}
	};

	// Find the selected quest to display its name
	const selectedQuest = value ? quests.find((quest) => quest.id === value) : null;
	const displayValue = value || "none";

	// Get the display name for the selected quest
	const getSelectedDisplayName = () => {
		if (!selectedQuest) return undefined;
		const questHierarchy = hierarchy.get(selectedQuest.id) || [selectedQuest];
		return formatQuestLabel(selectedQuest, questHierarchy);
	};

	return (
		<Select
			value={displayValue}
			onValueChange={handleValueChange}
			disabled={disabled}
		>
			<SelectTrigger className="w-full">
				<SelectValue placeholder={placeholder}>
					{selectedQuest ? (
						<div className="flex items-center gap-2">
							<span className="text-xs bg-blue-100 dark:bg-blue-950 px-1.5 py-0.5 rounded text-blue-700 dark:text-blue-300">
								quest
							</span>
							<span>{getSelectedDisplayName()}</span>
						</div>
					) : displayValue === "none" ? (
						<span className="text-muted-foreground">
							No parent (main quest)
						</span>
					) : null}
				</SelectValue>
			</SelectTrigger>
			<SelectPortal container={container}>
				<SelectPositioner>
					<SelectContent>
						<SelectItem value="none">
							<span className="text-muted-foreground">
								No parent (main quest)
							</span>
						</SelectItem>

						{sortedQuests.map((quest) => {
							const questHierarchy = hierarchy.get(quest.id) || [quest];
							const label = formatQuestLabel(quest, questHierarchy);

							return (
								<SelectItem key={quest.id} value={quest.id}>
									<div className="flex items-center gap-2">
										<span className="text-xs bg-blue-100 dark:bg-blue-950 px-1.5 py-0.5 rounded text-blue-700 dark:text-blue-300">
											quest
										</span>
										<span>{label}</span>
									</div>
								</SelectItem>
							);
						})}

						{sortedQuests.length === 0 && (
							<SelectItem value="disabled" disabled>
								<span className="text-muted-foreground">
									No other quests available
								</span>
							</SelectItem>
						)}
					</SelectContent>
				</SelectPositioner>
			</SelectPortal>
		</Select>
	);
}
</file>

<file path="src/components/ui/composite/tag-input.tsx">
import { Plus, X } from "lucide-react";
import { useState } from "react";
import { Badge } from "../badge";
import { Input } from "../input";
import { Button } from "../button";

interface TagInputProps {
	value: string[];
	onChange: (tags: string[]) => void;
	placeholder?: string;
	disabled?: boolean;
}

export function TagInput({
	value = [],
	onChange,
	placeholder = "Add a tag",
	disabled = false,
}: TagInputProps) {
	const [newTag, setNewTag] = useState("");

	const addTag = () => {
		if (newTag.trim() && !value.includes(newTag.trim())) {
			onChange([...value, newTag.trim()]);
			setNewTag("");
		}
	};

	const removeTag = (tagToRemove: string) => {
		onChange(value.filter((tag) => tag !== tagToRemove));
	};

	return (
		<div className="space-y-2">
			<div className="flex flex-wrap gap-2 mb-2">
				{value.map((tag) => (
					<Badge
						key={tag}
						variant="secondary"
						className="flex items-center gap-1"
					>
						{tag}
						{!disabled && (
							<button
								type="button"
								onClick={() => removeTag(tag)}
								className="ml-1 hover:text-destructive"
							>
								<X className="w-3 h-3" />
							</button>
						)}
					</Badge>
				))}
			</div>
			{!disabled && (
				<div className="flex gap-2">
					<Input
						value={newTag}
						onChange={(e) => setNewTag(e.target.value)}
						placeholder={placeholder}
						onKeyDown={(e) => {
							if (e.key === "Enter") {
								e.preventDefault();
								addTag();
							}
						}}
					/>
					<Button type="button" onClick={addTag} variant="outline" size="icon">
						<Plus className="w-4 h-4" />
					</Button>
				</div>
			)}
		</div>
	);
}
</file>

<file path="src/components/ui/editor/entity-editor.tsx">
import { Button } from "~/components/ui/button";
import type { EntityType } from "~/types";
import { useEditorContentActions } from "./hooks";
import { useCreateLinksFromMentions } from "./hooks/useCreateLinksFromMentions";
import { Tiptap } from "./index";
import { parseContentForEditor } from "./utils";

interface EntityEditorProps {
	/** The entity's current content (JSON string or object) */
	content?: string | object | null;
	/** The game ID for creating mention links */
	gameId: string;
	/** The entity type (character, faction, location, note, quest) */
	entityType: EntityType;
	/** The entity ID for creating mention links */
	entityId: string;
	/** Callback when save is clicked - receives the payload to send to the server */
	onSave: (payload: {
		content: string;
		content_plain_text: string;
	}) => void | Promise<void>;
	/** Whether the save operation is currently pending */
	isSaving?: boolean;
	/** Custom save button text */
	saveButtonText?: string;
	/** Custom save button variant */
	saveButtonVariant?:
		| "default"
		| "destructive"
		| "outline"
		| "secondary"
		| "ghost"
		| "link";
	/** Additional className for the container */
	className?: string;
}

export function EntityEditor({
	content,
	gameId,
	entityType,
	entityId,
	onSave,
	isSaving = false,
	saveButtonText = "Save",
	saveButtonVariant = "secondary",
	className,
}: EntityEditorProps) {
	const { isUpdated, setIsUpdated, onChange, getPayload, updatedContent } =
		useEditorContentActions();
	const { createLinksFromMentions, isCreatingLinks } = useCreateLinksFromMentions();

	const handleSave = async () => {
		// Get the payload for this entity type
		const payload = getPayload(entityType)[entityType];

		// Call the provided save function
		await onSave(payload);

		// Create links from mentions (runs in background)
		if (updatedContent.json) {
			try {
				await createLinksFromMentions(updatedContent.json, {
					gameId,
					type: entityType,
					id: entityId,
				});
			} catch (error) {
				// Silently handle errors - user doesn't need to know about mention link failures
				console.warn("Some mention links failed to create:", error);
			}
		}

		setIsUpdated(false);
	};

	return (
		<div className={`space-y-4 ${className || ""}`}>
			<Tiptap
				content={
					typeof content === "object" ? content : parseContentForEditor(content)
				}
				onChange={onChange}
			/>
			<Button
				variant={saveButtonVariant}
				onClick={handleSave}
				disabled={!isUpdated || isSaving || isCreatingLinks}
			>
				{isSaving || isCreatingLinks ? "Saving..." : saveButtonText}
			</Button>
		</div>
	);
}
</file>

<file path="src/components/ui/editor/index.tsx">
import { EditorContent, useEditor } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import {
	Bold,
	Code,
	Heading1,
	Heading2,
	Heading3,
	Italic,
	List,
	ListOrdered,
	Minus,
	Quote,
	Redo,
	Strikethrough,
	Undo,
} from "lucide-react";
import * as React from "react";
import { cn } from "~/utils/cn";
import "src/components/ui/editor/tiptap.css";
import { useQuery } from "@tanstack/react-query";
import { useParams } from "@tanstack/react-router";
import { listGameEntitiesOptions } from "~/api/@tanstack/react-query.gen";
import { Button } from "../button";
import { Separator } from "../separator";
import { Toggle } from "../toggle";
import { type MentionItem, SimpleMention } from "./mention-extension-simple";

export interface TiptapProps {
	content?: object | null;
	onChange?: (content: { json: object; text: string }) => void;
	placeholder?: string;
	editable?: boolean;
	className?: string;
}

export function Tiptap({
	content = null,
	onChange,
	placeholder = "Start typing...",
	editable = true,
	className,
}: TiptapProps) {
	const initialContentRef = React.useRef(content);
	const isInternalUpdate = React.useRef(false);
	const params = useParams({ from: "/_auth/games/$gameId" });
	const gameId = params?.gameId;

	const { data: entitiesData } = useQuery({
		...listGameEntitiesOptions({ path: { game_id: gameId } }),
		enabled: !!gameId,
		staleTime: 5 * 60 * 1000, // 5 minutes
	});

	// Transform entities into mention items
	const mentionItems = React.useMemo((): MentionItem[] => {
		if (!entitiesData?.data?.entities || !gameId) return [];

		const items: MentionItem[] = [];
		const entities = entitiesData.data.entities;

		// Add characters
		entities.characters?.forEach((character) => {
			items.push({
				id: character.id,
				label: character.name,
				type: "character",
				gameId,
			});
		});

		// Add factions
		entities.factions?.forEach((faction) => {
			items.push({
				id: faction.id,
				label: faction.name,
				type: "faction",
				gameId,
			});
		});

		// Add locations
		entities.locations?.forEach((location) => {
			items.push({
				id: location.id,
				label: location.name,
				type: "location",
				gameId,
			});
		});

		// Add notes
		entities.notes?.forEach((note) => {
			items.push({
				id: note.id,
				label: note.name,
				type: "note",
				gameId,
			});
		});

		// Add quests
		entities.quests?.forEach((quest) => {
			items.push({
				id: quest.id,
				label: quest.name,
				type: "quest",
				gameId,
			});
		});

		return items;
	}, [entitiesData, gameId]);

	const editor = useEditor({
		extensions: [
			StarterKit.configure({
				bulletList: {
					keepMarks: true,
					keepAttributes: false,
				},
				orderedList: {
					keepMarks: true,
					keepAttributes: false,
				},
			}),
			SimpleMention.configure({
				suggestion: {
					items: ({ query }: { query: string }) => {
						return mentionItems
							.filter((item) =>
								item.label.toLowerCase().includes(query.toLowerCase()),
							)
							.slice(0, 10);
					},
				},
			}),
		],
		content,
		editable,
		onUpdate: ({ editor }) => {
			isInternalUpdate.current = true;
			// Defer the onChange callback to avoid flushSync conflicts
			React.startTransition(() => {
				onChange?.({
					json: editor.getJSON(),
					text: editor.getText(),
				});
			});
		},
		editorProps: {
			attributes: {
				class: cn(
					"prose prose-sm sm:prose-base lg:prose-lg xl:prose-2xl mx-auto focus:outline-none",
					"min-h-[360px] px-3 pt-1 pb-2 border-0",
				),
			},
		},
		immediatelyRender: false,
	});

	React.useEffect(() => {
		if (editor && content !== null && !isInternalUpdate.current) {
			if (initialContentRef.current !== content) {
				// Use startTransition to defer content updates and avoid flushSync conflicts
				React.startTransition(() => {
					editor.commands.setContent(content);
					initialContentRef.current = content;
				});
			}
		}
		isInternalUpdate.current = false;
	}, [editor, content]);

	// Cleanup effect to prevent memory leaks and flushSync issues on unmount
	React.useEffect(() => {
		return () => {
			if (editor) {
				editor.destroy();
			}
		};
	}, [editor]);

	if (!editor) {
		return null;
	}

	return (
		<div
			className={cn(
				"border min-h-1/2 bg-input/30 rounded-lg overflow-hidden",
				className,
			)}
		>
			<div className="border-b px-3 py-1.5 flex flex-wrap items-center gap-1">
				<Toggle
					size="sm"
					pressed={editor.isActive("bold")}
					onPressedChange={() => editor.chain().focus().toggleBold().run()}
					disabled={!editor.can().chain().focus().toggleBold().run()}
				>
					<Bold className="h-4 w-4" />
				</Toggle>

				<Toggle
					size="sm"
					pressed={editor.isActive("italic")}
					onPressedChange={() => editor.chain().focus().toggleItalic().run()}
					disabled={!editor.can().chain().focus().toggleItalic().run()}
				>
					<Italic className="h-4 w-4" />
				</Toggle>

				<Toggle
					size="sm"
					pressed={editor.isActive("strike")}
					onPressedChange={() => editor.chain().focus().toggleStrike().run()}
					disabled={!editor.can().chain().focus().toggleStrike().run()}
				>
					<Strikethrough className="h-4 w-4" />
				</Toggle>

				<Toggle
					size="sm"
					pressed={editor.isActive("code")}
					onPressedChange={() => editor.chain().focus().toggleCode().run()}
					disabled={!editor.can().chain().focus().toggleCode().run()}
				>
					<Code className="h-4 w-4" />
				</Toggle>

				<Separator orientation="vertical" className="h-6" />

				<Toggle
					size="sm"
					pressed={editor.isActive("heading", { level: 1 })}
					onPressedChange={() =>
						editor.chain().focus().toggleHeading({ level: 1 }).run()
					}
				>
					<Heading1 className="h-4 w-4" />
				</Toggle>

				<Toggle
					size="sm"
					pressed={editor.isActive("heading", { level: 2 })}
					onPressedChange={() =>
						editor.chain().focus().toggleHeading({ level: 2 }).run()
					}
				>
					<Heading2 className="h-4 w-4" />
				</Toggle>

				<Toggle
					size="sm"
					pressed={editor.isActive("heading", { level: 3 })}
					onPressedChange={() =>
						editor.chain().focus().toggleHeading({ level: 3 }).run()
					}
				>
					<Heading3 className="h-4 w-4" />
				</Toggle>

				<Separator orientation="vertical" className="h-6" />

				<Toggle
					size="sm"
					pressed={editor.isActive("bulletList")}
					onPressedChange={() =>
						editor.chain().focus().toggleBulletList().run()
					}
				>
					<List className="h-4 w-4" />
				</Toggle>

				<Toggle
					size="sm"
					pressed={editor.isActive("orderedList")}
					onPressedChange={() =>
						editor.chain().focus().toggleOrderedList().run()
					}
				>
					<ListOrdered className="h-4 w-4" />
				</Toggle>

				<Toggle
					size="sm"
					pressed={editor.isActive("blockquote")}
					onPressedChange={() =>
						editor.chain().focus().toggleBlockquote().run()
					}
				>
					<Quote className="h-4 w-4" />
				</Toggle>

				<Separator orientation="vertical" className="h-6" />

				<Button
					variant="ghost"
					size="sm"
					onClick={() => editor.chain().focus().setHorizontalRule().run()}
				>
					<Minus className="h-4 w-4" />
				</Button>

				<Separator orientation="vertical" className="h-6" />

				<Button
					variant="ghost"
					size="sm"
					onClick={() => editor.chain().focus().undo().run()}
					disabled={!editor.can().chain().focus().undo().run()}
				>
					<Undo className="h-4 w-4" />
				</Button>

				<Button
					variant="ghost"
					size="sm"
					onClick={() => editor.chain().focus().redo().run()}
					disabled={!editor.can().chain().focus().redo().run()}
				>
					<Redo className="h-4 w-4" />
				</Button>
			</div>

			<EditorContent editor={editor} placeholder={placeholder} />
		</div>
	);
}
</file>

<file path="src/components/ui/editor/mention-component.tsx">
import { Link } from "@tanstack/react-router";
import { NodeViewWrapper, type ReactNodeViewProps } from "@tiptap/react";
import type * as React from "react";
import { cn } from "~/utils/cn";

interface MentionAttributes {
	id: string;
	label: string;
	type: "character" | "faction" | "location" | "note" | "quest";
	gameId: string;
}

export const MentionComponent: React.FC<ReactNodeViewProps> = ({ node }) => {
	const { id, label, type, gameId } = node.attrs as MentionAttributes;

	if (!id || !label || !type || !gameId) {
		return (
			<NodeViewWrapper className="inline">@{label || "unknown"}</NodeViewWrapper>
		);
	}

	const getRouteParams = () => {
		switch (type) {
			case "character":
				return {
					to: "/games/$gameId/characters/$id" as const,
					params: { gameId, id },
				};
			case "faction":
				return {
					to: "/games/$gameId/factions/$id" as const,
					params: { gameId, id },
				};
			case "location":
				return {
					to: "/games/$gameId/locations/$id" as const,
					params: { gameId, id },
				};
			case "note":
				return {
					to: "/games/$gameId/notes/$id" as const,
					params: { gameId, id },
				};
			case "quest":
				return {
					to: "/games/$gameId/quests/$id" as const,
					params: { gameId, id },
				};
			default:
				return {
					to: "/games/$gameId" as const,
					params: { gameId },
				};
		}
	};

	const getEntityIcon = () => {
		switch (type) {
			case "character":
				return "üë§";
			case "faction":
				return "‚öî";
			case "location":
				return "üó∫";
			case "note":
				return "üìù";
			case "quest":
				return "üéØ";
			default:
				return "üìÑ";
		}
	};

	const routeParams = getRouteParams();

	return (
		<NodeViewWrapper className="inline mention" as="span" draggable={false}>
			<Link
				{...routeParams}
				className={cn(
					"inline-flex items-center gap-1 px-1.5 py-0.5 rounded text-sm",
					"bg-primary/10 text-primary border border-primary/20",
					"hover:bg-primary/20 hover:border-primary/30 hover:text-primary",
					"no-underline font-medium transition-colors cursor-pointer",
					"mention-link", // Add specific class for CSS targeting
				)}
				onMouseDown={(e) => e.stopPropagation()}
				onClick={(e) => e.stopPropagation()}
			>
				<span className="text-xs">{getEntityIcon()}</span>
				<span>{label}</span>
			</Link>
		</NodeViewWrapper>
	);
};
</file>

<file path="src/components/ui/editor/viewer.tsx">
import { EditorContent, useEditor } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import { cn } from "~/utils/cn";
import { SimpleMention } from "./mention-extension-simple";
import { parseContentForEditor } from "./utils";
import "src/components/ui/editor/tiptap.css";

export interface TiptapViewerProps {
	content?: string;
	className?: string;
}

export function TiptapViewer({ content, className }: TiptapViewerProps) {
	const editor = useEditor({
		extensions: [
			StarterKit.configure({
				bulletList: {
					keepMarks: true,
					keepAttributes: false,
				},
				orderedList: {
					keepMarks: true,
					keepAttributes: false,
				},
			}),
			// Add mention extension for rendering saved mentions
			SimpleMention.configure({
				suggestion: {
					// Disable suggestion in viewer (read-only)
					items: () => [],
				},
			}),
		],
		content: parseContentForEditor(content),
		editable: false,
		editorProps: {
			attributes: {
				class: cn(
					"prose prose-sm sm:prose-base lg:prose-lg xl:prose-2xl mx-auto focus:outline-none",
					className,
				),
			},
		},
		immediatelyRender: false,
	});

	if (!editor) {
		return null;
	}

	return <EditorContent editor={editor} />;
}
</file>

<file path="src/components/ui/button.tsx">
/** biome-ignore-all lint/a11y/useButtonType: disable for library component */
import { useRender } from "@base-ui-components/react/use-render";
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";
import { cn } from "~/utils/cn";

const buttonVariants = cva(
	"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
	{
		variants: {
			variant: {
				default:
					"border border-transparent bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
				destructive:
					"border border-transparent bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
				outline:
					"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
				secondary:
					"border border-transparent bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
				ghost: "border border-transparent hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
				link: "border border-transparent text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-9 px-4 py-2 has-[>svg]:px-3",
				sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
				lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
				icon: "size-9",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

interface ButtonProps
	extends React.ComponentProps<"button">,
		VariantProps<typeof buttonVariants> {
	render?: useRender.RenderProp;
}

function Button({
	className,
	variant,
	size,
	render = <button />,
	...props
}: ButtonProps) {
	return useRender({
		render,
		props: {
			"data-slot": "button",
			className: cn(buttonVariants({ variant, size, className })),
			...props,
		},
	});
}

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react";
import { cn } from "~/utils/cn";

function Card({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card"
			className={cn(
				"bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
				className,
			)}
			{...props}
		/>
	);
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-header"
			className={cn(
				"@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
				className,
			)}
			{...props}
		/>
	);
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-title"
			className={cn("leading-none font-semibold", className)}
			{...props}
		/>
	);
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-description"
			className={cn("text-muted-foreground text-sm", className)}
			{...props}
		/>
	);
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-action"
			className={cn(
				"col-start-2 row-span-2 row-start-1 self-start justify-self-end",
				className,
			)}
			{...props}
		/>
	);
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
	return <div data-slot="card-content" className={cn("px-6", className)} {...props} />;
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-footer"
			className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
			{...props}
		/>
	);
}

export {
	Card,
	CardHeader,
	CardFooter,
	CardTitle,
	CardAction,
	CardDescription,
	CardContent,
};
</file>

<file path="src/components/ui/collapsible.tsx">
import { Collapsible as CollapsiblePrimitive } from "@base-ui-components/react/collapsible";

function Collapsible({
	...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
	return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />;
}

function CollapsibleTrigger({
	...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Trigger>) {
	return <CollapsiblePrimitive.Trigger data-slot="collapsible-trigger" {...props} />;
}

function CollapsibleContent({
	...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Panel>) {
	return <CollapsiblePrimitive.Panel data-slot="collapsible-content" {...props} />;
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent };
</file>

<file path="src/components/ui/entity-link-button.tsx">
import { SquareArrowDownRight } from "lucide-react";
import * as React from "react";
import DraggableWindow from "~/components/draggable";
import { Button } from "~/components/ui/button";
import type { EntityLink } from "~/utils/linkHelpers";
import { Badge } from "./badge";
import { TiptapViewer } from "./editor/viewer";

interface EntityLinkButtonProps {
	entity: EntityLink;
}

// Simple counter for staggering window positions
let windowCounter = 0;

export function EntityLinkButton({ entity }: EntityLinkButtonProps) {
	const [isOpen, setIsOpen] = React.useState(false);
	const [windowOffset] = React.useState(() => {
		const offset = windowCounter * 30; // 30px stagger
		windowCounter = (windowCounter + 1) % 10; // Reset after 10 windows
		return { x: offset, y: offset };
	});

	return (
		<>
			<Button variant="ghost" onClick={() => setIsOpen(true)}>
				<SquareArrowDownRight className="h-4 w-4" />
			</Button>
			<DraggableWindow
				isOpen={isOpen}
				onOpenChange={setIsOpen}
				title={entity.name}
				defaultWidth={600}
				defaultHeight={400}
				minWidth={400}
				minHeight={300}
				initialOffset={windowOffset}
			>
				<div className="prose prose-sm max-w-none">
					<div className="mb-4">
						<Badge>{entity.type}</Badge>
					</div>
					<TiptapViewer content={entity.content} />
				</div>
			</DraggableWindow>
		</>
	);
}
</file>

<file path="src/components/ui/form-tanstack.tsx">
import { useRender } from "@base-ui-components/react/use-render";
import {
	createFormHookContexts,
	createFormHook as createTanstackFormHook,
} from "@tanstack/react-form";
import * as React from "react";

import { Label } from "~/components/ui/label";
import { cn } from "~/utils/cn";

const { fieldContext, formContext, useFieldContext } = createFormHookContexts();

const useFormField = () => {
	const itemContext = React.useContext(FormItemContext);
	const fieldContext = useFieldContext();

	if (!fieldContext) {
		throw new Error("useFormField should be used within <field.Container>");
	}

	const { id } = itemContext;

	return {
		id,
		name: fieldContext.name,
		formItemId: `${id}-form-item`,
		formDescriptionId: `${id}-form-item-description`,
		formMessageId: `${id}-form-item-message`,
		...fieldContext.state.meta,
	};
};

type FormItemContextValue = {
	id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
	{} as FormItemContextValue,
);

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
	const id = React.useId();

	return (
		<FormItemContext.Provider value={{ id }}>
			<div
				data-slot="form-item"
				className={cn("grid gap-2 mb-4", className)}
				{...props}
			/>
		</FormItemContext.Provider>
	);
}

function FieldLabel({ className, ...props }: React.ComponentProps<typeof Label>) {
	const { formItemId, isValid } = useFormField();

	return (
		<Label
			data-slot="field-label"
			data-error={!isValid}
			className={cn("data-[error=true]:text-destructive", className)}
			htmlFor={formItemId}
			{...props}
		/>
	);
}

function FieldControl({ children = <div /> }: { children?: useRender.RenderProp }) {
	const { formItemId, isValid, formDescriptionId, formMessageId } = useFormField();

	return useRender({
		render: children,
		props: {
			"data-slot": "field-control",
			id: formItemId,
			"aria-describedby": isValid
				? `${formDescriptionId}`
				: `${formDescriptionId} ${formMessageId}`,
			"aria-invalid": !isValid,
		},
	});
}

function FieldDescription({ className, ...props }: React.ComponentProps<"p">) {
	const { formDescriptionId } = useFormField();

	return (
		<p
			data-slot="field-description"
			id={formDescriptionId}
			className={cn("text-muted-foreground text-sm", className)}
			{...props}
		/>
	);
}

function FieldMessage({ className, ...props }: React.ComponentProps<"p">) {
	const { formMessageId, isValid, errors } = useFormField();

	if (props.children) return props.children;

	const body = isValid ? props.children : String(errors.join(", ") ?? "");

	if (!body) return null;

	return (
		<p
			data-slot="field-message"
			id={formMessageId}
			className={cn("text-destructive text-sm", className)}
			{...props}
		>
			{body}
		</p>
	);
}

const createFormHook = (args?: Parameters<typeof createTanstackFormHook>[0]) => {
	const formHook = createTanstackFormHook({
		fieldComponents: {
			...args?.fieldComponents,
			Label: FieldLabel,
			Control: FieldControl,
			Description: FieldDescription,
			Message: FieldMessage,
		},
		formComponents: { ...args?.formComponents, Item: FormItem },
		fieldContext,
		formContext,
	});

	return formHook;
};

export { createFormHook };
</file>

<file path="src/components/ui/link.tsx">
import { createLink, type LinkComponent } from "@tanstack/react-router";
import type { VariantProps } from "class-variance-authority";
import * as React from "react";
import { cn } from "~/utils/cn";
import { buttonVariants } from "./button";

interface BasicLinkProps
	extends React.AnchorHTMLAttributes<HTMLAnchorElement>,
		VariantProps<typeof buttonVariants> {}

const BasicLinkComponent = React.forwardRef<HTMLAnchorElement, BasicLinkProps>(
	({ className, variant = "link", size, ...props }, ref) => {
		return (
			<a
				ref={ref}
				className={cn(buttonVariants({ variant, size }), className)}
				{...props}
			/>
		);
	},
);

const CreatedLinkComponent = createLink(BasicLinkComponent);

export const Link: LinkComponent<typeof BasicLinkComponent> = (props) => {
	return <CreatedLinkComponent preload="intent" {...props} />;
};
</file>

<file path="src/components/ui/sidebar.tsx">
import { useRender } from "@base-ui-components/react/use-render";
import { createLink } from "@tanstack/react-router";
import { cva, type VariantProps } from "class-variance-authority";
import { PanelLeft } from "lucide-react";
import * as React from "react";
import { useIsMobile } from "~/hooks/useMobile";
import { cn } from "~/utils/cn";
import { Button } from "../ui/button";
import { Sheet, SheetContent } from "../ui/sheet";

const SIDEBAR_COOKIE_NAME = "sidebar:state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "/";

type SidebarContext = {
	state: "open" | "closed";
	open: boolean;
	setOpen: (open: boolean) => void;
	openMobile: boolean;
	setOpenMobile: (open: boolean) => void;
	isMobile: boolean;
	toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContext | null>(null);

function useSidebar() {
	const context = React.useContext(SidebarContext);
	if (!context) {
		throw new Error("useSidebar must be used within a SidebarProvider.");
	}
	return context;
}

const SidebarProvider = ({
	defaultOpen = true,
	open: openProp,
	onOpenChange: setOpenProp,
	className,
	style,
	children,
	ref,
	...props
}: React.ComponentProps<"div"> & {
	defaultOpen?: boolean;
	open?: boolean;
	onOpenChange?: (open: boolean) => void;
}) => {
	const isMobile = useIsMobile();
	const [openMobile, setOpenMobile] = React.useState(false);

	// This is the internal state of the sidebar.
	// We use openProp and setOpenProp for control from outside the component.
	const [_open, _setOpen] = React.useState(defaultOpen);
	const open = openProp ?? _open;
	const setOpen = React.useCallback(
		(value: boolean | ((value: boolean) => boolean)) => {
			const openState = typeof value === "function" ? value(open) : value;
			if (setOpenProp) {
				setOpenProp(openState);
			} else {
				_setOpen(openState);
			}

			// This sets the cookie to keep the sidebar state.
			// biome-ignore lint/suspicious/noDocumentCookie: This is fine, a cookie is used for persistence
			document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
		},
		[setOpenProp, open],
	);

	// Helper to toggle the sidebar.
	const toggleSidebar = React.useCallback(() => {
		return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
	}, [isMobile, setOpen]);

	// Adds a keyboard shortcut to toggle the sidebar.
	React.useEffect(() => {
		const handleKeyDown = (event: KeyboardEvent) => {
			if (
				event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
				(event.metaKey || event.ctrlKey)
			) {
				event.preventDefault();
				toggleSidebar();
			}
		};

		window.addEventListener("keydown", handleKeyDown);
		return () => window.removeEventListener("keydown", handleKeyDown);
	}, [toggleSidebar]);

	// We add a state so that we can do data-state="expanded" or "collapsed".
	// This makes it easier to style the sidebar with Tailwind classes.
	const state = open ? "open" : "closed";

	const contextValue = React.useMemo<SidebarContext>(
		() => ({
			state,
			open,
			setOpen,
			isMobile,
			openMobile,
			setOpenMobile,
			toggleSidebar,
		}),
		[state, open, setOpen, isMobile, openMobile, toggleSidebar],
	);

	return (
		<SidebarContext.Provider value={contextValue}>
			<div
				style={
					{
						"--sidebar-width": SIDEBAR_WIDTH,
						"--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
						...style,
					} as React.CSSProperties
				}
				className={cn(
					"group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
					className,
				)}
				ref={ref}
				{...props}
			>
				{children}
			</div>
		</SidebarContext.Provider>
	);
};
SidebarProvider.displayName = "SidebarProvider";

const Sidebar = ({
	side = "left",
	variant = "sidebar",
	collapsible = "offcanvas",
	className,
	children,
	ref,
	...props
}: React.ComponentProps<"div"> & {
	side?: "left" | "right";
	variant?: "sidebar" | "floating" | "inset";
	collapsible?: "offcanvas" | "icon" | "none";
}) => {
	const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

	if (collapsible === "none") {
		return (
			<div
				className={cn(
					"flex h-full w-(--sidebar-width) flex-col bg-sidebar text-sidebar-foreground",
					className,
				)}
				ref={ref}
				{...props}
			>
				{children}
			</div>
		);
	}

	if (isMobile) {
		return (
			<Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
				<SheetContent
					data-sidebar="sidebar"
					data-mobile="true"
					className="w-(--sidebar-width-mobile) bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
					style={
						{
							"--sidebar-width": SIDEBAR_WIDTH_MOBILE,
						} as React.CSSProperties
					}
					side={side}
				>
					<div className="flex h-full w-full flex-col">{children}</div>
				</SheetContent>
			</Sheet>
		);
	}

	return (
		<div
			ref={ref}
			className="group peer hidden md:block text-sidebar-foreground"
			data-state={state}
			data-collapsible={state === "closed" ? collapsible : ""}
			data-variant={variant}
			data-side={side}
		>
			{/* This is what handles the sidebar gap on desktop */}
			<div
				className={cn(
					"duration-200 relative h-svh w-(--sidebar-width) bg-transparent transition-[width] ease-linear",
					"group-data-[collapsible=offcanvas]:w-0",
					"group-data-[side=right]:rotate-180",
					variant === "floating" || variant === "inset"
						? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
						: "group-data-[collapsible=icon]:w-(--sidebar-width-icon)",
				)}
			/>
			<div
				className={cn(
					"duration-200 fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] ease-linear md:flex",
					side === "left"
						? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
						: "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
					// Adjust the padding for floating and inset variants.
					variant === "floating" || variant === "inset"
						? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
						: "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
					className,
				)}
				{...props}
			>
				<div
					data-sidebar="sidebar"
					className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
				>
					{children}
				</div>
			</div>
		</div>
	);
};
Sidebar.displayName = "Sidebar";

const SidebarTrigger = ({
	className,
	onClick,
	ref,
	...props
}: React.ComponentProps<typeof Button>) => {
	const { toggleSidebar } = useSidebar();

	return (
		<Button
			ref={ref}
			data-sidebar="trigger"
			variant="ghost"
			size="icon"
			className={cn("h-7 w-7", className)}
			onClick={(event) => {
				onClick?.(event);
				toggleSidebar();
			}}
			{...props}
		>
			<PanelLeft />
			<span className="sr-only">Toggle Sidebar</span>
		</Button>
	);
};
SidebarTrigger.displayName = "SidebarTrigger";

const SidebarHeader = ({ className, ref, ...props }: React.ComponentProps<"div">) => {
	return (
		<div
			ref={ref}
			data-sidebar="header"
			className={cn("flex flex-col gap-2 p-2", className)}
			{...props}
		/>
	);
};
SidebarHeader.displayName = "SidebarHeader";

const SidebarContent = ({ className, ref, ...props }: React.ComponentProps<"div">) => {
	return (
		<div
			ref={ref}
			data-sidebar="content"
			className={cn(
				"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
				className,
			)}
			{...props}
		/>
	);
};
SidebarContent.displayName = "SidebarContent";

const SidebarMenu = ({ className, ref, ...props }: React.ComponentProps<"ul">) => (
	<ul
		ref={ref}
		data-sidebar="menu"
		className={cn("flex w-full min-w-0 flex-col gap-1", className)}
		{...props}
	/>
);
SidebarMenu.displayName = "SidebarMenu";

const SidebarMenuItem = ({ className, ref, ...props }: React.ComponentProps<"li">) => (
	<li
		ref={ref}
		data-sidebar="menu-item"
		className={cn("group/menu-item relative", className)}
		{...props}
	/>
);
SidebarMenuItem.displayName = "SidebarMenuItem";

const sidebarMenuButtonVariants = cva(
	"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
	{
		variants: {
			variant: {
				default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
				outline:
					"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
			},
			size: {
				default: "h-8 text-sm",
				sm: "h-7 text-xs",
				lg: "h-12 text-sm group-data-[collapsible=icon]:!size-8",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

interface SidebarMenuButtonProps
	extends useRender.ComponentProps<"button">,
		VariantProps<typeof sidebarMenuButtonVariants> {
	isActive?: boolean;
	tooltip?: string | React.ComponentProps<any>;
}

const SidebarMenuButton = ({
	render,
	isActive = false,
	variant = "default",
	size = "default",
	tooltip,
	className,
	...props
}: SidebarMenuButtonProps) => {
	const element = useRender({
		defaultTagName: "button",
		render,
		props: {
			"data-sidebar": "menu-button",
			"data-size": size,
			"data-active": isActive,
			className: cn(
				sidebarMenuButtonVariants({ variant, size }),
				isActive && "bg-sidebar-accent text-sidebar-accent-foreground",
				className,
			),
			...props,
		},
	});

	return element;
};
SidebarMenuButton.displayName = "SidebarMenuButton";

const SidebarMenuLink = createLink(SidebarMenuButton);

const SidebarGroup = ({ className, ...props }: React.ComponentProps<"div">) => {
	return (
		<div
			data-sidebar="group"
			className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
			{...props}
		/>
	);
};

const SidebarMenuAction = ({
	className,
	showOnHover = false,
	ref,
	...props
}: React.ComponentProps<"button"> & {
	showOnHover?: boolean;
}) => {
	return (
		<button
			ref={ref}
			data-sidebar="menu-action"
			className={cn(
				"absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
				// Increases the hit area of the button on mobile.
				"after:absolute after:-inset-2 after:md:hidden",
				"peer-data-[size=sm]/menu-button:top-1",
				"peer-data-[size=default]/menu-button:top-1.5",
				"peer-data-[size=lg]/menu-button:top-2.5",
				"group-data-[collapsible=icon]:hidden",
				showOnHover &&
					"group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
				className,
			)}
			{...props}
		/>
	);
};
SidebarMenuAction.displayName = "SidebarMenuAction";

const SidebarGroupLabel = ({ className, ...props }: React.ComponentProps<"div">) => {
	return (
		<div
			data-sidebar="group-label"
			className={cn(
				"flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
				"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
				className,
			)}
			{...props}
		/>
	);
};

const SidebarGroupAction = ({ className, ...props }: React.ComponentProps<"button">) => {
	return (
		<button
			data-sidebar="group-action"
			className={cn(
				"absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
				// Increases the hit area of the button on mobile.
				"after:absolute after:-inset-2 after:md:hidden",
				"group-data-[collapsible=icon]:hidden",
				className,
			)}
			{...props}
		/>
	);
};

const SidebarGroupContent = ({ className, ...props }: React.ComponentProps<"div">) => (
	<div
		data-sidebar="group-content"
		className={cn("w-full text-sm", className)}
		{...props}
	/>
);

const SidebarMenuBadge = ({ className, ...props }: React.ComponentProps<"div">) => (
	<div
		data-sidebar="menu-badge"
		className={cn(
			"pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
			"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
			"peer-data-[size=sm]/menu-button:top-1",
			"peer-data-[size=default]/menu-button:top-1.5",
			"peer-data-[size=lg]/menu-button:top-2.5",
			"group-data-[collapsible=icon]:hidden",
			className,
		)}
		{...props}
	/>
);
SidebarMenuBadge.displayName = "SidebarMenuBadge";

const SidebarMenuSub = ({ className, ...props }: React.ComponentProps<"ul">) => (
	<ul
		data-sidebar="menu-sub"
		className={cn(
			"mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
			"group-data-[collapsible=icon]:hidden",
			className,
		)}
		{...props}
	/>
);
SidebarMenuSub.displayName = "SidebarMenuSub";

const SidebarMenuSubItem = ({ ...props }: React.ComponentProps<"li">) => (
	<li {...props} />
);
SidebarMenuSubItem.displayName = "SidebarMenuSubItem";

const SidebarMenuSubButton = ({
	size = "md",
	isActive,
	className,
	...props
}: React.ComponentProps<"a"> & {
	size?: "sm" | "md";
	isActive?: boolean;
}) => {
	return (
		<a
			data-sidebar="menu-sub-button"
			data-size={size}
			data-active={isActive}
			className={cn(
				"flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
				"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
				size === "sm" && "text-xs",
				size === "md" && "text-sm",
				"group-data-[collapsible=icon]:hidden",
				className,
			)}
			{...props}
		/>
	);
};
SidebarMenuSubButton.displayName = "SidebarMenuSubButton";

export {
	Sidebar,
	SidebarContent,
	SidebarHeader,
	SidebarMenu,
	SidebarMenuButton,
	SidebarMenuLink,
	SidebarMenuItem,
	SidebarMenuAction,
	SidebarProvider,
	SidebarTrigger,
	SidebarGroup,
	SidebarGroupLabel,
	SidebarGroupAction,
	SidebarGroupContent,
	SidebarMenuBadge,
	SidebarMenuSub,
	SidebarMenuSubItem,
	SidebarMenuSubButton,
	useSidebar,
};
</file>

<file path="src/components/all-entities-table.tsx">
import {
	type ColumnDef,
	type ColumnFiltersState,
	flexRender,
	getCoreRowModel,
	getFilteredRowModel,
	getPaginationRowModel,
	getSortedRowModel,
	type SortingState,
	useReactTable,
	type VisibilityState,
} from "@tanstack/react-table";
import { ArrowUpDown, ChevronDown } from "lucide-react";
import * as React from "react";

import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
	DropdownMenu,
	DropdownMenuCheckboxItem,
	DropdownMenuContent,
	DropdownMenuPortal,
	DropdownMenuPositioner,
	DropdownMenuTrigger,
} from "~/components/ui/dropdown-menu";
import { Input } from "~/components/ui/input";
import {
	Table,
	TableBody,
	TableCell,
	TableHead,
	TableHeader,
	TableRow,
} from "~/components/ui/table";
import type { EntityType } from "~/types";
import { Link } from "./ui/link";

// Combined entity type that includes all possible entity properties
export type AllEntity = {
	id: string;
	name: string;
	type: EntityType;
	content?: string;
	content_plain_text?: string;
	tags?: string[];
	created_at?: string;
	updated_at?: string;
	// Character specific
	class?: string;
	level?: number;
	faction_role?: string;
	// Quest specific
	parent_id?: string;
};

interface AllEntitiesTableProps {
	entities: AllEntity[];
	gameId: string;
}

export function AllEntitiesTable({ entities, gameId }: AllEntitiesTableProps) {
	const [sorting, setSorting] = React.useState<SortingState>([]);
	const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([]);
	const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>({});
	const [searchQuery, setSearchQuery] = React.useState("");
	const [typeFilter, setTypeFilter] = React.useState<string>("all");
	const [tagFilter, setTagFilter] = React.useState("");

	const PAGINATION_SIZE = 15;

	const columns: ColumnDef<AllEntity>[] = [
		{
			accessorKey: "name",
			header: ({ column }) => {
				return (
					<Button
						variant="ghost"
						onClick={() =>
							column.toggleSorting(column.getIsSorted() === "asc")
						}
					>
						Name
						<ArrowUpDown className="ml-2 h-4 w-4" />
					</Button>
				);
			},
			cell: ({ row }) => {
				const type = row.original.type;
				const id = row.original.id;
				return (
					<Link
						to={`/games/${gameId}/${type}s/${id}` as string}
						className="font-medium hover:underline truncate block"
					>
						{row.getValue("name")}
					</Link>
				);
			},
			size: 200,
		},
		{
			accessorKey: "type",
			header: "Type",
			cell: ({ row }) => (
				<Badge variant="secondary" className="capitalize">
					{row.getValue("type")}
				</Badge>
			),
			size: 100,
		},
		{
			accessorKey: "content_plain_text",
			header: "Description",
			cell: ({ row }) => {
				const description = row.getValue("content_plain_text") as string;
				return (
					<div className="text-sm max-w-md truncate">
						{description || "No description"}
					</div>
				);
			},
			size: 300,
		},
		{
			accessorKey: "tags",
			header: "Tags",
			filterFn: (row, columnId, value) => {
				const itemValue = row.getValue(columnId) as string | string[];
				if (Array.isArray(itemValue)) {
					return itemValue.some((tag) =>
						tag.toLowerCase().includes(value.toLowerCase()),
					);
				}
				return itemValue?.toLowerCase().includes(value.toLowerCase()) ?? false;
			},
			cell: ({ row }) => {
				const tags = row.getValue("tags") as string[] | undefined;
				if (!tags || tags.length === 0) {
					return <div className="text-sm text-muted-foreground">-</div>;
				}
				return (
					<div className="flex flex-wrap gap-1">
						{tags.slice(0, 3).map((tag) => (
							<Badge key={tag} variant="outline" className="text-xs">
								{tag}
							</Badge>
						))}
						{tags.length > 3 && (
							<Badge variant="outline" className="text-xs">
								+{tags.length - 3}
							</Badge>
						)}
					</div>
				);
			},
			size: 150,
		},
		{
			accessorKey: "updated_at",
			header: ({ column }) => {
				return (
					<Button
						variant="ghost"
						onClick={() =>
							column.toggleSorting(column.getIsSorted() === "asc")
						}
					>
						Last Updated
						<ArrowUpDown className="ml-2 h-4 w-4" />
					</Button>
				);
			},
			cell: ({ row }) => {
				const date = row.getValue("updated_at") as string | undefined;
				if (!date) return <div className="text-sm text-muted-foreground">-</div>;
				return (
					<div className="text-sm">{new Date(date).toLocaleDateString()}</div>
				);
			},
			size: 120,
		},
	];

	const table = useReactTable({
		data: entities,
		columns,
		onSortingChange: setSorting,
		onColumnFiltersChange: setColumnFilters,
		getCoreRowModel: getCoreRowModel(),
		getPaginationRowModel: getPaginationRowModel(),
		getSortedRowModel: getSortedRowModel(),
		getFilteredRowModel: getFilteredRowModel(),
		onColumnVisibilityChange: setColumnVisibility,
		state: {
			sorting,
			columnFilters,
			columnVisibility,
		},
		filterFns: {
			fuzzy: (row, columnId, value) => {
				const itemValue = row.getValue(columnId) as string | string[];
				if (Array.isArray(itemValue)) {
					return itemValue.some((tag) =>
						tag.toLowerCase().includes(value.toLowerCase()),
					);
				}
				return itemValue?.toLowerCase().includes(value.toLowerCase()) ?? false;
			},
		},
		initialState: {
			pagination: {
				pageSize: PAGINATION_SIZE,
			},
		},
	});

	const uniqueTypes = React.useMemo(() => {
		const types = [...new Set(entities.map((entity) => entity.type))];
		return types.sort();
	}, [entities]);

	React.useEffect(() => {
		table.getColumn("name")?.setFilterValue(searchQuery);
	}, [searchQuery, table]);

	React.useEffect(() => {
		table.getColumn("type")?.setFilterValue(typeFilter === "all" ? "" : typeFilter);
	}, [typeFilter, table]);

	React.useEffect(() => {
		table.getColumn("tags")?.setFilterValue(tagFilter);
	}, [tagFilter, table]);

	return (
		<div className="w-full max-w-full">
			<div className="flex items-center gap-4 py-4">
				<Input
					placeholder="Search entities..."
					value={searchQuery}
					onChange={(event) => setSearchQuery(event.target.value)}
					className="max-w-sm"
				/>
				<Input
					placeholder="Filter tags..."
					value={tagFilter}
					onChange={(event) => setTagFilter(event.target.value)}
					className="max-w-sm"
				/>
				<DropdownMenu>
					<DropdownMenuTrigger
						render={
							<Button variant="outline">
								Type: {typeFilter === "all" ? "All" : typeFilter}
								<ChevronDown className="ml-2 h-4 w-4" />
							</Button>
						}
					></DropdownMenuTrigger>
					<DropdownMenuPortal>
						<DropdownMenuPositioner>
							<DropdownMenuContent>
								<DropdownMenuCheckboxItem
									checked={typeFilter === "all"}
									onCheckedChange={() => setTypeFilter("all")}
								>
									All Types
								</DropdownMenuCheckboxItem>
								{uniqueTypes.map((type) => (
									<DropdownMenuCheckboxItem
										key={type}
										checked={typeFilter === type}
										onCheckedChange={() => setTypeFilter(type)}
										className="capitalize"
									>
										{type}
									</DropdownMenuCheckboxItem>
								))}
							</DropdownMenuContent>
						</DropdownMenuPositioner>
					</DropdownMenuPortal>
				</DropdownMenu>
				<DropdownMenu>
					<DropdownMenuTrigger
						render={
							<Button variant="outline" className="ml-auto">
								Columns <ChevronDown className="ml-2 h-4 w-4" />
							</Button>
						}
					></DropdownMenuTrigger>
					<DropdownMenuPortal>
						<DropdownMenuPositioner>
							<DropdownMenuContent>
								{table
									.getAllColumns()
									.filter((column) => column.getCanHide())
									.map((column) => {
										return (
											<DropdownMenuCheckboxItem
												key={column.id}
												className="capitalize"
												checked={column.getIsVisible()}
												onCheckedChange={(value) =>
													column.toggleVisibility(!!value)
												}
											>
												{column.id}
											</DropdownMenuCheckboxItem>
										);
									})}
							</DropdownMenuContent>
						</DropdownMenuPositioner>
					</DropdownMenuPortal>
				</DropdownMenu>
			</div>
			<div className="overflow-hidden rounded-md border">
				<div className="overflow-x-auto">
					<Table className="table-fixed w-full">
						<TableHeader>
							{table.getHeaderGroups().map((headerGroup) => (
								<TableRow key={headerGroup.id}>
									{headerGroup.headers.map((header) => {
										return (
											<TableHead key={header.id}>
												{header.isPlaceholder
													? null
													: flexRender(
															header.column.columnDef
																.header,
															header.getContext(),
														)}
											</TableHead>
										);
									})}
								</TableRow>
							))}
						</TableHeader>
						<TableBody>
							{table.getRowModel().rows?.length ? (
								table.getRowModel().rows.map((row) => (
									<TableRow
										key={row.id}
										data-state={row.getIsSelected() && "selected"}
									>
										{row.getVisibleCells().map((cell) => (
											<TableCell key={cell.id}>
												{flexRender(
													cell.column.columnDef.cell,
													cell.getContext(),
												)}
											</TableCell>
										))}
									</TableRow>
								))
							) : (
								<TableRow>
									<TableCell
										colSpan={columns.length}
										className="h-24 text-center"
									>
										No entities found.
									</TableCell>
								</TableRow>
							)}
						</TableBody>
					</Table>
				</div>
			</div>
			<div className="flex items-center justify-end space-x-2 py-4">
				<div className="flex-1 text-sm text-muted-foreground">
					{table.getFilteredRowModel().rows.length} of {entities.length}{" "}
					entity(s) total.
				</div>
				<div className="space-x-2">
					<Button
						variant="outline"
						size="sm"
						onClick={() => table.previousPage()}
						disabled={!table.getCanPreviousPage()}
					>
						Previous
					</Button>
					<Button
						variant="outline"
						size="sm"
						onClick={() => table.nextPage()}
						disabled={!table.getCanNextPage()}
					>
						Next
					</Button>
				</div>
			</div>
		</div>
	);
}
</file>

<file path="src/components/authenticated-layout.tsx">
import { Link } from "./ui/link";

interface AuthenticatedLayoutProps {
	user: {
		id: number;
		email: string;
	};
	children: React.ReactNode;
}

export function AuthenticatedLayout({ user, children }: AuthenticatedLayoutProps) {
	return (
		<div className="min-h-screen">
			<header className="bg-card text-card-foreground">
				<div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
					<div className="flex justify-between items-center py-4">
						<div className="flex items-center gap-8">
							<h1 className="text-xl font-semibold">Game Master</h1>
							<Link to="/games/new">Create Game</Link>
						</div>
						<div className="flex items-center gap-4">
							<span className="text-sm">{user.email}</span>
							<Link to="/logout">Logout</Link>
						</div>
					</div>
				</div>
			</header>
			<main className="py-8">{children}</main>
		</div>
	);
}
</file>

<file path="src/components/draggable.tsx">
/** biome-ignore-all lint/a11y/useSemanticElements: draggable element is not a semantic element */
import { Dialog } from "@base-ui-components/react/dialog";
import { XIcon } from "lucide-react";
import * as React from "react";
import { cn } from "~/utils/cn";

interface DraggableWindowProps {
	children: React.ReactNode;
	isOpen: boolean;
	onOpenChange: (open: boolean) => void;
	title?: string;
	defaultWidth?: number;
	defaultHeight?: number;
	minWidth?: number;
	minHeight?: number;
	className?: string;
	contentClassName?: string;
	initialOffset?: { x: number; y: number };
}

const DraggableWindow: React.FC<DraggableWindowProps> = ({
	children,
	isOpen,
	onOpenChange,
	title = "Window",
	defaultWidth = 400,
	defaultHeight = 300,
	minWidth = 250,
	minHeight = 150,
	className = "",
	contentClassName = "",
	initialOffset = { x: 0, y: 0 },
}) => {
	const popupRef = React.useRef<HTMLDivElement>(null);
	const dragDataRef = React.useRef({
		isDragging: false,
		isResizing: false,
		startMouseX: 0,
		startMouseY: 0,
		startX: 100,
		startY: 100,
		startWidth: defaultWidth,
		startHeight: defaultHeight,
		currentX: 100,
		currentY: 100,
		currentWidth: defaultWidth,
		currentHeight: defaultHeight,
	});

	const handleMouseMove = React.useCallback(
		(e: MouseEvent) => {
			const data = dragDataRef.current;
			const popup = popupRef.current;
			if (!popup) return;

			if (data.isDragging) {
				// Disable transitions for instant response
				popup.style.transition = "none";

				// Use transform for maximum performance - no layout recalculation
				const deltaX = e.clientX - data.startMouseX;
				const deltaY = e.clientY - data.startMouseY;

				data.currentX = data.startX + deltaX;
				data.currentY = data.startY + deltaY;

				popup.style.transform = `translate(${data.currentX}px, ${data.currentY}px)`;
			} else if (data.isResizing) {
				// Disable transitions for instant response
				popup.style.transition = "none";

				// Direct width/height manipulation for resizing
				const deltaX = e.clientX - data.startMouseX;
				const deltaY = e.clientY - data.startMouseY;

				data.currentWidth = Math.max(minWidth, data.startWidth + deltaX);
				data.currentHeight = Math.max(minHeight, data.startHeight + deltaY);

				popup.style.width = `${data.currentWidth}px`;
				popup.style.height = `${data.currentHeight}px`;
			}
		},
		[minWidth, minHeight],
	);

	const handleMouseUp = React.useCallback(() => {
		const data = dragDataRef.current;

		if (data.isDragging || data.isResizing) {
			data.isDragging = false;
			data.isResizing = false;

			document.body.style.userSelect = "";
			document.body.style.cursor = "";

			document.removeEventListener("mousemove", handleMouseMove);
			document.removeEventListener("mouseup", handleMouseUp);

			// Re-enable transitions after drag/resize ends
			if (popupRef.current) {
				const popup = popupRef.current;
				popup.style.transition = "";

				// After drag ends, apply bounds checking and update position
				const maxX = window.innerWidth - data.currentWidth;
				const maxY = window.innerHeight - data.currentHeight;

				data.currentX = Math.max(0, Math.min(maxX, data.currentX));
				data.currentY = Math.max(0, Math.min(maxY, data.currentY));

				// Update both transform and left/top for consistency
				popup.style.transform = `translate(${data.currentX}px, ${data.currentY}px)`;
				popup.style.left = "0px";
				popup.style.top = "0px";
			}
		}
	}, [handleMouseMove]);

	const handleDragStart = React.useCallback(
		(e: React.MouseEvent) => {
			if (
				(e.target as HTMLElement).closest(".resize-handle") ||
				(e.target as HTMLElement).closest("textarea") ||
				(e.target as HTMLElement).closest("input") ||
				(e.target as HTMLElement).closest(
					'button:not([aria-label="Drag to move window"])',
				)
			) {
				return;
			}

			e.preventDefault();
			const data = dragDataRef.current;

			data.isDragging = true;
			data.startMouseX = e.clientX;
			data.startMouseY = e.clientY;
			data.startX = data.currentX;
			data.startY = data.currentY;

			document.body.style.userSelect = "none";
			document.body.style.cursor = "grabbing";

			// Use passive listeners for better performance
			document.addEventListener("mousemove", handleMouseMove, { passive: true });
			document.addEventListener("mouseup", handleMouseUp);
		},
		[handleMouseMove, handleMouseUp],
	);

	const handleResizeStart = React.useCallback(
		(e: React.MouseEvent) => {
			e.preventDefault();
			e.stopPropagation();

			const data = dragDataRef.current;

			data.isResizing = true;
			data.startMouseX = e.clientX;
			data.startMouseY = e.clientY;
			data.startWidth = data.currentWidth;
			data.startHeight = data.currentHeight;

			document.body.style.userSelect = "none";
			document.body.style.cursor = "nw-resize";

			document.addEventListener("mousemove", handleMouseMove, { passive: true });
			document.addEventListener("mouseup", handleMouseUp);
		},
		[handleMouseMove, handleMouseUp],
	);

	const initializePosition = React.useCallback(() => {
		if (popupRef.current && isOpen) {
			const data = dragDataRef.current;
			const centerX = Math.max(0, (window.innerWidth - data.currentWidth) / 2);
			const centerY = Math.max(0, (window.innerHeight - data.currentHeight) / 2);

			// Apply initial offset for staggered positioning
			const finalX = Math.max(
				0,
				Math.min(
					window.innerWidth - data.currentWidth,
					centerX + initialOffset.x,
				),
			);
			const finalY = Math.max(
				0,
				Math.min(
					window.innerHeight - data.currentHeight,
					centerY + initialOffset.y,
				),
			);

			data.currentX = finalX;
			data.currentY = finalY;

			const popup = popupRef.current;
			popup.style.left = "0px";
			popup.style.top = "0px";
			popup.style.transform = `translate(${finalX}px, ${finalY}px)`;
			popup.style.width = `${data.currentWidth}px`;
			popup.style.height = `${data.currentHeight}px`;
		}
	}, [isOpen, initialOffset.x, initialOffset.y]);

	React.useEffect(() => {
		if (isOpen) {
			// Small delay to ensure the popup is mounted
			requestAnimationFrame(initializePosition);
		}
	}, [isOpen, initializePosition]);

	// Cleanup
	React.useEffect(() => {
		return () => {
			document.removeEventListener("mousemove", handleMouseMove);
			document.removeEventListener("mouseup", handleMouseUp);
			document.body.style.userSelect = "";
			document.body.style.cursor = "";
		};
	}, [handleMouseMove, handleMouseUp]);

	return (
		<Dialog.Root
			open={isOpen}
			onOpenChange={onOpenChange}
			modal={false}
			dismissible={false}
		>
			<Dialog.Portal>
				<Dialog.Popup
					ref={popupRef}
					className={cn(
						"bg-background data-[open]:animate-in data-[open]:fade-in-0 data-[open]:zoom-in-95 data-[closed]:animate-out data-[closed]:fade-out-0 data-[closed]:zoom-out-95 fixed z-50 flex flex-col gap-4 rounded-lg border p-0 shadow-lg duration-200 overflow-hidden",
						className,
					)}
					style={{
						left: "0px",
						top: "0px",
						width: `${defaultWidth}px`,
						height: `${defaultHeight}px`,
						minWidth: `${minWidth}px`,
						minHeight: `${minHeight}px`,
						willChange: "transform",
						transform: `translate(${dragDataRef.current.currentX}px, ${dragDataRef.current.currentY}px)`,
						transition: "opacity 200ms, transform 200ms",
					}}
				>
					{/* Header */}
					<div
						className={cn(
							"flex cursor-grab select-none items-center justify-between border-b px-6 py-4 active:cursor-grabbing gap-2",
						)}
						onMouseDown={handleDragStart}
						role="button"
						aria-label="Drag to move window"
						tabIndex={0}
						onKeyDown={(e) => {
							if (e.key === "Enter" || e.key === " ") {
								e.preventDefault();
							}
						}}
					>
						<Dialog.Title
							className={cn("text-lg leading-none font-semibold")}
						>
							{title}
						</Dialog.Title>
						<Dialog.Close
							className={cn(
								"ring-offset-background focus:ring-ring data-[open]:bg-accent data-[open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
							)}
						>
							<XIcon />
							<span className="sr-only">Close</span>
						</Dialog.Close>
					</div>

					{/* Content */}
					<main className={cn("flex-1 overflow-auto p-6", contentClassName)}>
						{children}
					</main>

					{/* Resize handle */}
					<button
						type="button"
						className="resize-handle absolute bottom-0 right-0 h-4 w-4 cursor-nw-resize opacity-60 hover:opacity-100 transition-opacity border-0 bg-transparent p-0"
						onMouseDown={handleResizeStart}
						aria-label="Resize window"
						title="Drag to resize"
						style={{
							background: `
                linear-gradient(135deg, 
                  transparent 0%, 
                  transparent 40%, 
                  #94a3b8 40%, 
                  #94a3b8 45%, 
                  transparent 45%, 
                  transparent 55%, 
                  #94a3b8 55%, 
                  #94a3b8 60%, 
                  transparent 60%, 
                  transparent 70%, 
                  #94a3b8 70%, 
                  #94a3b8 75%, 
                  transparent 75%
                )
              `,
						}}
					/>
				</Dialog.Popup>
			</Dialog.Portal>
		</Dialog.Root>
	);
};

export default DraggableWindow;
</file>

<file path="src/components/entity-view.tsx">
import { Menu, Pencil, Pin, Trash2 } from "lucide-react";
import { Button } from "./ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuPositioner,
	DropdownMenuTrigger,
} from "./ui/dropdown-menu";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/tabs";

type EntityTab = {
	id: string;
	label: string;
	content: React.ReactNode;
};

interface EntityViewProps {
	name: string;
	badges?: React.ReactNode;
	onEdit?: () => void;
	onDelete?: () => void;
	pinned?: boolean;
	onTogglePin?: () => void;
	tabs: EntityTab[];
}

export function EntityView({
	name,
	badges,
	onEdit,
	onDelete,
	pinned,
	onTogglePin,
	tabs,
}: EntityViewProps) {
	return (
		<div className="space-y-10 mt-2">
			<EntityTabs tabs={tabs}>
				<EntityViewHeader
					name={name}
					badges={badges}
					onEdit={onEdit}
					onDelete={onDelete}
					pinned={pinned}
					onTogglePin={onTogglePin}
				/>
			</EntityTabs>
		</div>
	);
}

export function EntityViewHeader({
	name,
	badges,
	onEdit,
	onDelete,
	pinned,
	onTogglePin,
}: Omit<EntityViewProps, "tabs">) {
	return (
		<div className="space-y-2 mb-4">
			<div className="flex items-center gap-3">
				<h1 className="text-3xl font-bold">{name}</h1>
				<EntityControls
					onEdit={onEdit}
					onDelete={onDelete}
					pinned={pinned}
					onTogglePin={onTogglePin}
				/>
			</div>
			{badges && <div className="mt-1">{badges}</div>}
		</div>
	);
}

interface EntityControlsProps {
	onEdit?: () => void;
	onDelete?: () => void;
	pinned?: boolean;
	onTogglePin?: () => void;
}

export function EntityControls({
	onEdit,
	onDelete,
	pinned,
	onTogglePin,
}: EntityControlsProps) {
	return (
		<DropdownMenu>
			<DropdownMenuTrigger render={<Button size={"icon"} variant={"ghost"} />}>
				<Menu className="h-4 w-4" />
			</DropdownMenuTrigger>
			<DropdownMenuPositioner side="right" align="start" alignOffset={10}>
				<DropdownMenuContent>
					<DropdownMenuItem onClick={onEdit}>
						<Pencil />
						Edit
					</DropdownMenuItem>
					<DropdownMenuItem onClick={onTogglePin}>
						<Pin />
						{pinned ? "Unpin" : "Pin"}
					</DropdownMenuItem>
					<DropdownMenuItem onClick={onDelete}>
						<Trash2 />
						Delete
					</DropdownMenuItem>
				</DropdownMenuContent>
			</DropdownMenuPositioner>
		</DropdownMenu>
	);
}

interface EntityTabsProps {
	tabs: EntityTab[];
	children: React.ReactNode;
}

export function EntityTabs({ tabs, children }: EntityTabsProps) {
	if (!tabs.length) {
		return null;
	}

	return (
		<Tabs defaultValue={tabs[0].id}>
			<TabsList className="mb-6">
				{tabs.map((tab) => (
					<TabsTrigger key={tab.id} value={tab.id}>
						{tab.label}
					</TabsTrigger>
				))}
			</TabsList>
			{children}
			{tabs.map((tab) => (
				<TabsContent key={tab.id} value={tab.id}>
					{tab.content}
				</TabsContent>
			))}
		</Tabs>
	);
}
</file>

<file path="src/components/login.tsx">
import { useRouter } from "@tanstack/react-router";
import { createServerFn, useServerFn } from "@tanstack/react-start";
import { loginUser } from "~/api";
import { signupFn } from "~/routes/signup";
import { getAppSession } from "~/utils/session";
import { useMutationLite } from "../hooks/useMutationLite";
import { Auth } from "./auth";
import { Button } from "./ui/button";

export const loginFn = createServerFn({ method: "POST" })
	.inputValidator((d: { email: string; password: string }) => d)
	.handler(async ({ data }) => {
		const { data: loginData, error } = await loginUser({ body: data });

		if (error) {
			return {
				error: true,
				message: "There was an error",
				userNotFound: true,
			};
		}

		// Create a session
		const session = await getAppSession();

		// Store the user's email in the session
		await session.update({
			user: loginData.user,
			token: loginData.token,
		});
	});

export function Login() {
	const router = useRouter();

	const loginMutation = useMutationLite({
		fn: loginFn,
		onSuccess: async (ctx) => {
			if (!ctx.data?.error) {
				await router.invalidate();
				router.navigate({ to: "/" });
				return;
			}
		},
	});

	const signupMutation = useMutationLite({
		fn: useServerFn(signupFn),
	});

	return (
		<Auth
			actionText="Login"
			status={loginMutation.status}
			onSubmit={(e) => {
				const formData = new FormData(e.target as HTMLFormElement);

				loginMutation.mutate({
					data: {
						email: formData.get("email") as string,
						password: formData.get("password") as string,
					},
				});
			}}
			afterSubmit={
				loginMutation.data ? (
					<>
						<div className="text-red-400">{loginMutation.data.message}</div>
						{loginMutation.data.userNotFound ? (
							<div>
								<Button
									onClick={(e) => {
										const formData = new FormData(
											(e.target as HTMLButtonElement).form!,
										);

										signupMutation.mutate({
											data: {
												email: formData.get("email") as string,
												password: formData.get(
													"password",
												) as string,
											},
										});
									}}
									type="button"
								>
									Sign up instead?
								</Button>
							</div>
						) : null}
					</>
				) : null
			}
		/>
	);
}
</file>

<file path="src/components/page-header.tsx">
import { Button } from "./ui/button";

interface PageHeaderProps {
	title: string;
	description?: string;
	handleCreate?: () => void;
}

export function PageHeader({ title, description, handleCreate }: PageHeaderProps) {
	return (
		<div className="mb-8">
			<div className="flex items-start justify-between">
				<div>
					<h1 className="text-3xl font-bold">{title}</h1>
					{description && (
						<p className="text-muted-foreground mt-2">{description}</p>
					)}
				</div>
				{handleCreate && (
					<div className="flex items-center gap-2">
						<Button onClick={handleCreate}>Create</Button>
					</div>
				)}
			</div>
		</div>
	);
}
</file>

<file path="src/queries/characters.ts">
import { useMutation, useQueryClient, useSuspenseQuery } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import {
	deleteCharacterMutation,
	getCharacterLinksQueryKey,
	getCharacterOptions,
	getCharacterQueryKey,
	listCharactersQueryKey,
	setCharacterPrimaryFactionMutation,
	updateCharacterMutation,
} from "~/api/@tanstack/react-query.gen";

////////////////////////////////////////////////////////////////////////////////
//                                SUSPENSE
////////////////////////////////////////////////////////////////////////////////

export const useGetCharacterSuspenseQuery = (gameId: string, id: string) => {
	return useSuspenseQuery(getCharacterOptions({ path: { game_id: gameId, id } }));
};

////////////////////////////////////////////////////////////////////////////////
//                                MUTATIONS
////////////////////////////////////////////////////////////////////////////////

export const useDeleteCharacterMutation = (gameId: string) => {
	const navigate = useNavigate();
	const client = useQueryClient();
	return useMutation({
		...deleteCharacterMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: listCharactersQueryKey({
					path: { game_id: gameId },
				}),
			});
			navigate({ to: ".." });
		},
	});
};

export const useUpdateCharacterMutation = (gameId: string, characterId: string) => {
	const client = useQueryClient();
	return useMutation({
		...updateCharacterMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: getCharacterQueryKey({
					path: { game_id: gameId, id: characterId },
				}),
			});
		},
	});
};

export const useSetCharacterPrimaryFactionMutation = (
	gameId: string,
	characterId: string,
) => {
	const client = useQueryClient();
	return useMutation({
		...setCharacterPrimaryFactionMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: getCharacterLinksQueryKey({
					path: { game_id: gameId, character_id: characterId },
				}),
			});
			client.invalidateQueries({
				queryKey: getCharacterQueryKey({
					path: { game_id: gameId, id: characterId },
				}),
			});
		},
	});
};
</file>

<file path="src/queries/games.ts">
import { useSuspenseQuery } from "@tanstack/react-query";
import { getGameOptions, listGameEntitiesOptions } from "~/api/@tanstack/react-query.gen";

////////////////////////////////////////////////////////////////////////////////
//                                QUERIES
////////////////////////////////////////////////////////////////////////////////

export const useGetGameSuspenseQuery = ({ id }: { id: string }) => {
	return useSuspenseQuery(getGameOptions({ path: { id } }));
};

export const useGetGameLinksSuspenseQuery = ({ id }: { id: string }) => {
	return useSuspenseQuery(listGameEntitiesOptions({ path: { game_id: id } }));
};
</file>

<file path="src/queries/locations.ts">
import { useMutation, useQueryClient, useSuspenseQuery } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import {
	deleteLocationMutation,
	getLocationOptions,
	getLocationQueryKey,
	getLocationTreeOptions,
	listLocationsOptions,
	listLocationsQueryKey,
	updateLocationMutation,
} from "~/api/@tanstack/react-query.gen";

////////////////////////////////////////////////////////////////////////////////
//                                QUERIES
////////////////////////////////////////////////////////////////////////////////

export const useListLocationsSuspenseQuery = (gameId: string) => {
	return useSuspenseQuery(listLocationsOptions({ path: { game_id: gameId } }));
};

export const useLocationSuspenseQuery = (gameId: string, id: string) => {
	return useSuspenseQuery(getLocationOptions({ path: { game_id: gameId, id } }));
};

export const useGetLocationTreeSuspenseQuery = (gameId: string) => {
	return useSuspenseQuery(getLocationTreeOptions({ path: { game_id: gameId } }));
};

////////////////////////////////////////////////////////////////////////////////
//                                MUTATIONS
////////////////////////////////////////////////////////////////////////////////

export const useDeleteLocationMutation = (gameId: string) => {
	const navigate = useNavigate();
	const client = useQueryClient();
	return useMutation({
		...deleteLocationMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: listLocationsQueryKey({
					path: { game_id: gameId },
				}),
			});
			navigate({ to: ".." });
		},
	});
};

export const useUpdateLocationMutation = (gameId: string, locationId: string) => {
	const client = useQueryClient();
	return useMutation({
		...updateLocationMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: getLocationQueryKey({
					path: { game_id: gameId, id: locationId },
				}),
			});
		},
	});
};
</file>

<file path="src/queries/notes.ts">
import { useMutation, useQueryClient, useSuspenseQuery } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import {
	deleteNoteMutation,
	getNoteOptions,
	getNoteQueryKey,
	listNotesOptions,
	listNotesQueryKey,
	updateNoteMutation,
} from "~/api/@tanstack/react-query.gen";

////////////////////////////////////////////////////////////////////////////////
//                                QUERIES
////////////////////////////////////////////////////////////////////////////////

export const useListNotesSuspenseQuery = (gameId: string) => {
	return useSuspenseQuery(listNotesOptions({ path: { game_id: gameId } }));
};

export const useNoteSuspenseQuery = (gameId: string, id: string) => {
	return useSuspenseQuery(getNoteOptions({ path: { game_id: gameId, id } }));
};

////////////////////////////////////////////////////////////////////////////////
//                                MUTATIONS
////////////////////////////////////////////////////////////////////////////////

export const useDeleteNoteMutation = (gameId: string) => {
	const navigate = useNavigate();
	const client = useQueryClient();
	return useMutation({
		...deleteNoteMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: listNotesQueryKey({
					path: { game_id: gameId },
				}),
			});
			navigate({ to: ".." });
		},
	});
};

export const useUpdateNoteMutation = (gameId: string, noteId: string) => {
	const client = useQueryClient();
	return useMutation({
		...updateNoteMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: getNoteQueryKey({
					path: { game_id: gameId, id: noteId },
				}),
			});
		},
	});
};
</file>

<file path="src/routes/_auth/games/$gameId/characters/new.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { CreateCharacterForm } from "~/components/characters/create-character-form";

export const Route = createFileRoute("/_auth/games/$gameId/characters/new")({
	component: RouteComponent,
});

function RouteComponent() {
	return (
		<div>
			<CreateCharacterForm />
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/factions/$id/route.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import {
	getFactionLinksOptions,
	getFactionOptions,
} from "~/api/@tanstack/react-query.gen";
import { BasicErrorComponent } from "~/components/error";

export const Route = createFileRoute("/_auth/games/$gameId/factions/$id")({
	component: RouteComponent,
	loader: async ({ context, params }) => {
		await context.queryClient.ensureQueryData(
			getFactionOptions({
				path: { game_id: params.gameId, id: params.id },
			}),
		);
		context.queryClient.ensureQueryData(
			getFactionLinksOptions({
				path: { game_id: params.gameId, faction_id: params.id },
			}),
		);
	},
	errorComponent: BasicErrorComponent,
});

function RouteComponent() {
	return <Outlet />;
}
</file>

<file path="src/routes/_auth/games/$gameId/factions/new.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { CreateFactionForm } from "~/components/factions/create-faction-form";

export const Route = createFileRoute("/_auth/games/$gameId/factions/new")({
	component: RouteComponent,
});

function RouteComponent() {
	return (
		<div>
			<CreateFactionForm />
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/notes/$id/route.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import { getNoteLinksOptions, getNoteOptions } from "~/api/@tanstack/react-query.gen";
import { BasicErrorComponent } from "~/components/error";

export const Route = createFileRoute("/_auth/games/$gameId/notes/$id")({
	component: RouteComponent,
	loader: async ({ context, params }) => {
		await context.queryClient.ensureQueryData(
			getNoteOptions({
				path: {
					game_id: params.gameId,
					id: params.id,
				},
			}),
		);
		context.queryClient.ensureQueryData(
			getNoteLinksOptions({
				path: {
					game_id: params.gameId,
					note_id: params.id,
				},
			}),
		);
	},
	errorComponent: BasicErrorComponent,
});

function RouteComponent() {
	return <Outlet />;
}
</file>

<file path="src/routes/_auth/games/$gameId/quests/$id/route.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import { getQuestLinksOptions, getQuestOptions } from "~/api/@tanstack/react-query.gen";
import { BasicErrorComponent } from "~/components/error";

export const Route = createFileRoute("/_auth/games/$gameId/quests/$id")({
	component: RouteComponent,
	loader: async ({ context, params }) => {
		await context.queryClient.ensureQueryData(
			getQuestOptions({
				path: {
					game_id: params.gameId,
					id: params.id,
				},
			}),
		);
		context.queryClient.ensureQueryData(
			getQuestLinksOptions({
				path: {
					game_id: params.gameId,
					quest_id: params.id,
				},
			}),
		);
	},
	errorComponent: BasicErrorComponent,
});

function RouteComponent() {
	return <Outlet />;
}
</file>

<file path="src/routes/_auth/games/$gameId/edit.tsx">
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/_auth/games/$gameId/edit")({
	component: RouteComponent,
});

function RouteComponent() {
	return <div>Hello "/_auth/games/$id/edit"!</div>;
}
</file>

<file path="src/routes/login.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { Login } from "~/components/login";

export const Route = createFileRoute("/login")({
	component: LoginComp,
});

function LoginComp() {
	return <Login />;
}
</file>

<file path="src/types/index.ts">
const EntityTypes = ["character", "faction", "location", "note", "quest"] as const;
export type EntityType = (typeof EntityTypes)[number];

export type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;
</file>

<file path="src/utils/error-parser.ts">
import type { ErrorDetails } from "~/api/types.gen";

interface ParsedError {
	message: string;
	code?: string;
	statusCode?: number;
	field?: string;
	details?: Record<string, unknown>;
}

// TODO: Fix the parsing of errors, I think we mostly use the details field, which has nested errors for each field

export function parseApiError(errorDetails: ErrorDetails | undefined): ParsedError {
	if (!errorDetails) {
		return {
			message: "An unknown error occurred",
		};
	}
	// Common field names to check for error information
	const messageFields = ["message", "error", "description", "detail", "msg"];
	const codeFields = ["code", "errorCode", "error_code", "type"];
	const statusFields = ["status", "statusCode", "status_code", "httpStatus"];
	const fieldFields = ["field", "fieldName", "property", "param"];

	const getMessage = (): string => {
		for (const field of messageFields) {
			const value = errorDetails[field];
			if (typeof value === "string" && value.length > 0) {
				return value;
			}
		}
		return "An unknown error occurred";
	};

	const getCode = (): string | undefined => {
		for (const field of codeFields) {
			const value = errorDetails[field];
			if (typeof value === "string" || typeof value === "number") {
				return String(value);
			}
		}
		return undefined;
	};

	const getStatusCode = (): number | undefined => {
		for (const field of statusFields) {
			const value = errorDetails[field];
			if (typeof value === "number") {
				return value;
			}
		}
		return undefined;
	};

	const getField = (): string | undefined => {
		for (const field of fieldFields) {
			const value = errorDetails[field];
			if (typeof value === "string") {
				return value;
			}
		}
		return undefined;
	};

	return {
		message: getMessage(),
		code: getCode(),
		statusCode: getStatusCode(),
		field: getField(),
		details: errorDetails,
	};
}
</file>

<file path="src/utils/session.ts">
import { useSession } from "@tanstack/react-start/server";

type Session = {
	user: {
		id: number;
		email: string;
	};
	token: string;
};

export function getAppSession() {
	return useSession<Session>({
		password: "ChangeThisBeforeShippingToProdOrYouWillBeFired",
	});
}
</file>

<file path=".editorconfig">
[*.{jsx,tsx}]
indent_size = 2
indent_style = space

[*.{js,ts,json,css}]
indent_style = tab
indent_size = 4
</file>

<file path=".gitignore">
node_modules
.DS_Store
dist
dist-ssr
*.local
count.txt
.env
.nitro
.tanstack
.output
.vinxi
.wranger/**/*
todos.json
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

**Package Manager:** This project uses `pnpm` as the package manager.

**Development server:**
```bash
pnpm dev
# Runs on port 3000
```

**Build and test:**
```bash
pnpm build      # Build for production
pnpm test       # Run Vitest tests
pnpm serve      # Preview production build
```

**Code quality:**
```bash
pnpm lint       # Lint with Biome
pnpm format     # Format with Biome
pnpm check      # Combined lint and format check
```

**API code generation:**
```bash
pnpm codegen    # Generate API client from OpenAPI schema
```

## Project Architecture

This is a **TanStack Start** application - a full-stack React meta-framework with SSR capabilities.

### Core Technologies
- **React 19** with TypeScript
- **TanStack Router** - File-based routing with type safety
- **TanStack Query** - Server state management with SSR integration
- **TanStack Start** - Full-stack framework with SSR
- **Tailwind CSS 4** - Styling framework
- **React Aria Components** - Accessible UI components
- **Biome** - Linting and formatting

### Key Architectural Patterns

**API Integration:**
- Generated API client from OpenAPI schema at `src/api/`
- API client configured in `src/utils/api-client.ts` (base URL: http://localhost:4000)
- Authentication handled via Bearer tokens in API headers

**Routing Structure:**
- File-based routing in `src/routes/`
- Protected routes under `_auth/` layout
- Route tree auto-generated in `src/routeTree.gen.ts`
- Game management routes nested under `_auth/games/$id/`

**Authentication Flow:**
- Session management in `src/utils/session.ts`
- Auth components: `src/components/Auth.tsx`, `src/components/Login.tsx`
- Server-side session fetching in `__root.tsx`

**Game Master Features:**
The app appears to be a game master tool with resources for:
- Characters (`_auth/games/$id/characters/`)
- Factions (`_auth/games/$id/factions/`)
- Locations (`_auth/games/$id/locations/`)
- Notes (`_auth/games/$id/notes/`)
- Quests (`_auth/games/$id/quests/`)

### Important File Locations
- API client initialization: `src/utils/api-client.ts`
- Root layout and auth context: `src/routes/__root.tsx`
- Router configuration: `src/router.tsx`
- Session utilities: `src/utils/session.ts`
- OpenAPI configuration: `openapi-ts.config.ts`

### Development Notes
- Demo files (prefixed with `demo.`) can be safely deleted
- Route tree is auto-generated - do not edit `routeTree.gen.ts` directly
- API types are generated from `server/schema/swagger.json`
- The app uses dark mode by default (`className="dark"` in root layout)

<!-- BACKLOG.MD GUIDELINES START -->
# Instructions for the usage of Backlog.md CLI Tool

## Backlog.md: Comprehensive Project Management Tool via CLI

### Assistant Objective

Efficiently manage all project tasks, status, and documentation using the Backlog.md CLI, ensuring all project metadata
remains fully synchronized and up-to-date.

### Core Capabilities

- ‚úÖ **Task Management**: Create, edit, assign, prioritize, and track tasks with full metadata
- ‚úÖ **Acceptance Criteria**: Granular control with add/remove/check/uncheck by index
- ‚úÖ **Board Visualization**: Terminal-based Kanban board (`backlog board`) and web UI (`backlog browser`)
- ‚úÖ **Git Integration**: Automatic tracking of task states across branches
- ‚úÖ **Dependencies**: Task relationships and subtask hierarchies
- ‚úÖ **Documentation & Decisions**: Structured docs and architectural decision records
- ‚úÖ **Export & Reporting**: Generate markdown reports and board snapshots
- ‚úÖ **AI-Optimized**: `--plain` flag provides clean text output for AI processing

### Why This Matters to You (AI Agent)

1. **Comprehensive system** - Full project management capabilities through CLI
2. **The CLI is the interface** - All operations go through `backlog` commands
3. **Unified interaction model** - You can use CLI for both reading (`backlog task 1 --plain`) and writing (
   `backlog task edit 1`)
4. **Metadata stays synchronized** - The CLI handles all the complex relationships

### Key Understanding

- **Tasks** live in `backlog/tasks/` as `task-<id> - <title>.md` files
- **You interact via CLI only**: `backlog task create`, `backlog task edit`, etc.
- **Use `--plain` flag** for AI-friendly output when viewing/listing
- **Never bypass the CLI** - It handles Git, metadata, file naming, and relationships

---

# ‚ö†Ô∏è CRITICAL: NEVER EDIT TASK FILES DIRECTLY. Edit Only via CLI

**ALL task operations MUST use the Backlog.md CLI commands**

- ‚úÖ **DO**: Use `backlog task edit` and other CLI commands
- ‚úÖ **DO**: Use `backlog task create` to create new tasks
- ‚úÖ **DO**: Use `backlog task edit <id> --check-ac <index>` to mark acceptance criteria
- ‚ùå **DON'T**: Edit markdown files directly
- ‚ùå **DON'T**: Manually change checkboxes in files
- ‚ùå **DON'T**: Add or modify text in task files without using CLI

**Why?** Direct file editing breaks metadata synchronization, Git tracking, and task relationships.

---

## 1. Source of Truth & File Structure

### üìñ **UNDERSTANDING** (What you'll see when reading)

- Markdown task files live under **`backlog/tasks/`** (drafts under **`backlog/drafts/`**)
- Files are named: `task-<id> - <title>.md` (e.g., `task-42 - Add GraphQL resolver.md`)
- Project documentation is in **`backlog/docs/`**
- Project decisions are in **`backlog/decisions/`**

### üîß **ACTING** (How to change things)

- **All task operations MUST use the Backlog.md CLI tool**
- This ensures metadata is correctly updated and the project stays in sync
- **Always use `--plain` flag** when listing or viewing tasks for AI-friendly text output

---

## 2. Common Mistakes to Avoid

### ‚ùå **WRONG: Direct File Editing**

```markdown
# DON'T DO THIS:

1. Open backlog/tasks/task-7 - Feature.md in editor
2. Change "- [ ]" to "- [x]" manually
3. Add notes directly to the file
4. Save the file
```

### ‚úÖ **CORRECT: Using CLI Commands**

```bash
# DO THIS INSTEAD:
backlog task edit 7 --check-ac 1  # Mark AC #1 as complete
backlog task edit 7 --notes "Implementation complete"  # Add notes
backlog task edit 7 -s "In Progress" -a @agent-k  # Multiple commands: change status and assign the task when you start working on the task
```

---

## 3. Understanding Task Format (Read-Only Reference)

‚ö†Ô∏è **FORMAT REFERENCE ONLY** - The following sections show what you'll SEE in task files.
**Never edit these directly! Use CLI commands to make changes.**

### Task Structure You'll See

```markdown
---
id: task-42
title: Add GraphQL resolver
status: To Do
assignee: [@sara]
labels: [backend, api]
---

## Description

Brief explanation of the task purpose.

## Acceptance Criteria

<!-- AC:BEGIN -->

- [ ] #1 First criterion
- [x] #2 Second criterion (completed)
- [ ] #3 Third criterion

<!-- AC:END -->

## Implementation Plan

1. Research approach
2. Implement solution

## Implementation Notes

Summary of what was done.
```

### How to Modify Each Section

| What You Want to Change | CLI Command to Use                                       |
|-------------------------|----------------------------------------------------------|
| Title                   | `backlog task edit 42 -t "New Title"`                    |
| Status                  | `backlog task edit 42 -s "In Progress"`                  |
| Assignee                | `backlog task edit 42 -a @sara`                          |
| Labels                  | `backlog task edit 42 -l backend,api`                    |
| Description             | `backlog task edit 42 -d "New description"`              |
| Add AC                  | `backlog task edit 42 --ac "New criterion"`              |
| Check AC #1             | `backlog task edit 42 --check-ac 1`                      |
| Uncheck AC #2           | `backlog task edit 42 --uncheck-ac 2`                    |
| Remove AC #3            | `backlog task edit 42 --remove-ac 3`                     |
| Add Plan                | `backlog task edit 42 --plan "1. Step one\n2. Step two"` |
| Add Notes (replace)     | `backlog task edit 42 --notes "What I did"`              |
| Append Notes            | `backlog task edit 42 --append-notes "Another note"` |

---

## 4. Defining Tasks

### Creating New Tasks

**Always use CLI to create tasks:**

```bash
# Example
backlog task create "Task title" -d "Description" --ac "First criterion" --ac "Second criterion"
```

### Title (one liner)

Use a clear brief title that summarizes the task.

### Description (The "why")

Provide a concise summary of the task purpose and its goal. Explains the context without implementation details.

### Acceptance Criteria (The "what")

**Understanding the Format:**

- Acceptance criteria appear as numbered checkboxes in the markdown files
- Format: `- [ ] #1 Criterion text` (unchecked) or `- [x] #1 Criterion text` (checked)

**Managing Acceptance Criteria via CLI:**

‚ö†Ô∏è **IMPORTANT: How AC Commands Work**

- **Adding criteria (`--ac`)** accepts multiple flags: `--ac "First" --ac "Second"` ‚úÖ
- **Checking/unchecking/removing** accept multiple flags too: `--check-ac 1 --check-ac 2` ‚úÖ
- **Mixed operations** work in a single command: `--check-ac 1 --uncheck-ac 2 --remove-ac 3` ‚úÖ

```bash
# Examples

# Add new criteria (MULTIPLE values allowed)
backlog task edit 42 --ac "User can login" --ac "Session persists"

# Check specific criteria by index (MULTIPLE values supported)
backlog task edit 42 --check-ac 1 --check-ac 2 --check-ac 3  # Check multiple ACs
# Or check them individually if you prefer:
backlog task edit 42 --check-ac 1    # Mark #1 as complete
backlog task edit 42 --check-ac 2    # Mark #2 as complete

# Mixed operations in single command
backlog task edit 42 --check-ac 1 --uncheck-ac 2 --remove-ac 3

# ‚ùå STILL WRONG - These formats don't work:
# backlog task edit 42 --check-ac 1,2,3  # No comma-separated values
# backlog task edit 42 --check-ac 1-3    # No ranges
# backlog task edit 42 --check 1         # Wrong flag name

# Multiple operations of same type
backlog task edit 42 --uncheck-ac 1 --uncheck-ac 2  # Uncheck multiple ACs
backlog task edit 42 --remove-ac 2 --remove-ac 4    # Remove multiple ACs (processed high-to-low)
```

**Key Principles for Good ACs:**

- **Outcome-Oriented:** Focus on the result, not the method.
- **Testable/Verifiable:** Each criterion should be objectively testable
- **Clear and Concise:** Unambiguous language
- **Complete:** Collectively cover the task scope
- **User-Focused:** Frame from end-user or system behavior perspective

Good Examples:

- "User can successfully log in with valid credentials"
- "System processes 1000 requests per second without errors"
- "CLI preserves literal newlines in description/plan/notes; `\\n` sequences are not auto‚Äëconverted"

Bad Example (Implementation Step):

- "Add a new function handleLogin() in auth.ts"
- "Define expected behavior and document supported input patterns"

### Task Breakdown Strategy

1. Identify foundational components first
2. Create tasks in dependency order (foundations before features)
3. Ensure each task delivers value independently
4. Avoid creating tasks that block each other

### Task Requirements

- Tasks must be **atomic** and **testable** or **verifiable**
- Each task should represent a single unit of work for one PR
- **Never** reference future tasks (only tasks with id < current task id)
- Ensure tasks are **independent** and don't depend on future work

---

## 5. Implementing Tasks

### 5.1. First step when implementing a task

The very first things you must do when you take over a task are:

* set the task in progress
* assign it to yourself

```bash
# Example
backlog task edit 42 -s "In Progress" -a @{myself}
```

### 5.2. Create an Implementation Plan (The "how")

Previously created tasks contain the why and the what. Once you are familiar with that part you should think about a
plan on **HOW** to tackle the task and all its acceptance criteria. This is your **Implementation Plan**.
First do a quick check to see if all the tools that you are planning to use are available in the environment you are
working in.   
When you are ready, write it down in the task so that you can refer to it later.

```bash
# Example
backlog task edit 42 --plan "1. Research codebase for references\n2Research on internet for similar cases\n3. Implement\n4. Test"
```

## 5.3. Implementation

Once you have a plan, you can start implementing the task. This is where you write code, run tests, and make sure
everything works as expected. Follow the acceptance criteria one by one and MARK THEM AS COMPLETE as soon as you
finish them.

### 5.4 Implementation Notes (PR description)

When you are done implementing a tasks you need to prepare a PR description for it.
Because you cannot create PRs directly, write the PR as a clean description in the task notes.
Append notes progressively during implementation using `--append-notes`:

```
backlog task edit 42 --append-notes "Implemented X" --append-notes "Added tests"
```

```bash
# Example
backlog task edit 42 --notes "Implemented using pattern X because Reason Y, modified files Z and W"
```

**IMPORTANT**: Do NOT include an Implementation Plan when creating a task. The plan is added only after you start the
implementation.

- Creation phase: provide Title, Description, Acceptance Criteria, and optionally labels/priority/assignee.
- When you begin work, switch to edit, set the task in progress and assign to yourself
  `backlog task edit <id> -s "In Progress" -a "..."`.
- Think about how you would solve the task and add the plan: `backlog task edit <id> --plan "..."`.
- Add Implementation Notes only after completing the work: `backlog task edit <id> --notes "..."` (replace) or append progressively using `--append-notes`.

## Phase discipline: What goes where

- Creation: Title, Description, Acceptance Criteria, labels/priority/assignee.
- Implementation: Implementation Plan (after moving to In Progress and assigning to yourself).
- Wrap-up: Implementation Notes (Like a PR description), AC and Definition of Done checks.

**IMPORTANT**: Only implement what's in the Acceptance Criteria. If you need to do more, either:

1. Update the AC first: `backlog task edit 42 --ac "New requirement"`
2. Or create a new follow up task: `backlog task create "Additional feature"`

---

## 6. Typical Workflow

```bash
# 1. Identify work
backlog task list -s "To Do" --plain

# 2. Read task details
backlog task 42 --plain

# 3. Start work: assign yourself & change status
backlog task edit 42 -s "In Progress" -a @myself

# 4. Add implementation plan
backlog task edit 42 --plan "1. Analyze\n2. Refactor\n3. Test"

# 5. Work on the task (write code, test, etc.)

# 6. Mark acceptance criteria as complete (supports multiple in one command)
backlog task edit 42 --check-ac 1 --check-ac 2 --check-ac 3  # Check all at once
# Or check them individually if preferred:
# backlog task edit 42 --check-ac 1
# backlog task edit 42 --check-ac 2
# backlog task edit 42 --check-ac 3

# 7. Add implementation notes (PR Description)
backlog task edit 42 --notes "Refactored using strategy pattern, updated tests"

# 8. Mark task as done
backlog task edit 42 -s Done
```

---

## 7. Definition of Done (DoD)

A task is **Done** only when **ALL** of the following are complete:

### ‚úÖ Via CLI Commands:

1. **All acceptance criteria checked**: Use `backlog task edit <id> --check-ac <index>` for each
2. **Implementation notes added**: Use `backlog task edit <id> --notes "..."`
3. **Status set to Done**: Use `backlog task edit <id> -s Done`

### ‚úÖ Via Code/Testing:

4. **Tests pass**: Run test suite and linting
5. **Documentation updated**: Update relevant docs if needed
6. **Code reviewed**: Self-review your changes
7. **No regressions**: Performance, security checks pass

‚ö†Ô∏è **NEVER mark a task as Done without completing ALL items above**

---

## 8. Quick Reference: DO vs DON'T

### Viewing Tasks

| Task         | ‚úÖ DO                        | ‚ùå DON'T                         |
|--------------|-----------------------------|---------------------------------|
| View task    | `backlog task 42 --plain`   | Open and read .md file directly |
| List tasks   | `backlog task list --plain` | Browse backlog/tasks folder     |
| Check status | `backlog task 42 --plain`   | Look at file content            |

### Modifying Tasks

| Task          | ‚úÖ DO                                 | ‚ùå DON'T                           |
|---------------|--------------------------------------|-----------------------------------|
| Check AC      | `backlog task edit 42 --check-ac 1`  | Change `- [ ]` to `- [x]` in file |
| Add notes     | `backlog task edit 42 --notes "..."` | Type notes into .md file          |
| Change status | `backlog task edit 42 -s Done`       | Edit status in frontmatter        |
| Add AC        | `backlog task edit 42 --ac "New"`    | Add `- [ ] New` to file           |

---

## 9. Complete CLI Command Reference

### Task Creation

| Action           | Command                                                                             |
|------------------|-------------------------------------------------------------------------------------|
| Create task      | `backlog task create "Title"`                                                       |
| With description | `backlog task create "Title" -d "Description"`                                      |
| With AC          | `backlog task create "Title" --ac "Criterion 1" --ac "Criterion 2"`                 |
| With all options | `backlog task create "Title" -d "Desc" -a @sara -s "To Do" -l auth --priority high` |
| Create draft     | `backlog task create "Title" --draft`                                               |
| Create subtask   | `backlog task create "Title" -p 42`                                                 |

### Task Modification

| Action           | Command                                     |
|------------------|---------------------------------------------|
| Edit title       | `backlog task edit 42 -t "New Title"`       |
| Edit description | `backlog task edit 42 -d "New description"` |
| Change status    | `backlog task edit 42 -s "In Progress"`     |
| Assign           | `backlog task edit 42 -a @sara`             |
| Add labels       | `backlog task edit 42 -l backend,api`       |
| Set priority     | `backlog task edit 42 --priority high`      |

### Acceptance Criteria Management

| Action              | Command                                                                     |
|---------------------|-----------------------------------------------------------------------------|
| Add AC              | `backlog task edit 42 --ac "New criterion" --ac "Another"`                  |
| Remove AC #2        | `backlog task edit 42 --remove-ac 2`                                        |
| Remove multiple ACs | `backlog task edit 42 --remove-ac 2 --remove-ac 4`                          |
| Check AC #1         | `backlog task edit 42 --check-ac 1`                                         |
| Check multiple ACs  | `backlog task edit 42 --check-ac 1 --check-ac 3`                            |
| Uncheck AC #3       | `backlog task edit 42 --uncheck-ac 3`                                       |
| Mixed operations    | `backlog task edit 42 --check-ac 1 --uncheck-ac 2 --remove-ac 3 --ac "New"` |

### Task Content

| Action           | Command                                                  |
|------------------|----------------------------------------------------------|
| Add plan         | `backlog task edit 42 --plan "1. Step one\n2. Step two"` |
| Add notes        | `backlog task edit 42 --notes "Implementation details"`  |
| Add dependencies | `backlog task edit 42 --dep task-1 --dep task-2`         |

### Multi‚Äëline Input (Description/Plan/Notes)

The CLI preserves input literally. Shells do not convert `\n` inside normal quotes. Use one of the following to insert real newlines:

- Bash/Zsh (ANSI‚ÄëC quoting):
  - Description: `backlog task edit 42 --desc $'Line1\nLine2\n\nFinal'`
  - Plan: `backlog task edit 42 --plan $'1. A\n2. B'`
  - Notes: `backlog task edit 42 --notes $'Done A\nDoing B'`
  - Append notes: `backlog task edit 42 --append-notes $'Progress update line 1\nLine 2'`
- POSIX portable (printf):
  - `backlog task edit 42 --notes "$(printf 'Line1\nLine2')"`
- PowerShell (backtick n):
  - `backlog task edit 42 --notes "Line1`nLine2"`

Do not expect `"...\n..."` to become a newline. That passes the literal backslash + n to the CLI by design.

Descriptions support literal newlines; shell examples may show escaped `\\n`, but enter a single `\n` to create a newline.

### Task Operations

| Action             | Command                                      |
|--------------------|----------------------------------------------|
| View task          | `backlog task 42 --plain`                    |
| List tasks         | `backlog task list --plain`                  |
| Filter by status   | `backlog task list -s "In Progress" --plain` |
| Filter by assignee | `backlog task list -a @sara --plain`         |
| Archive task       | `backlog task archive 42`                    |
| Demote to draft    | `backlog task demote 42`                     |

---

## Common Issues

| Problem              | Solution                                                           |
|----------------------|--------------------------------------------------------------------|
| Task not found       | Check task ID with `backlog task list --plain`                     |
| AC won't check       | Use correct index: `backlog task 42 --plain` to see AC numbers     |
| Changes not saving   | Ensure you're using CLI, not editing files                         |
| Metadata out of sync | Re-edit via CLI to fix: `backlog task edit 42 -s <current-status>` |

---

## Remember: The Golden Rule

**üéØ If you want to change ANYTHING in a task, use the `backlog task edit` command.**
**üìñ Use CLI to read tasks, exceptionally READ task files directly, never WRITE to them.**

Full help available: `backlog --help`

<!-- BACKLOG.MD GUIDELINES END -->
</file>

<file path="tsconfig.json">
{
    "include": [
        "**/*.ts",
        "**/*.tsx"
    ],
    "compilerOptions": {
        "target": "ES2022",
        "jsx": "react-jsx",
        "module": "ESNext",
        "lib": [
            "ES2022",
            "DOM",
            "DOM.Iterable"
        ],
        "types": [
            "vite/client"
        ],
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "verbatimModuleSyntax": false,
        "noEmit": true,
        /* Linting */
        "skipLibCheck": true,
        "strict": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noFallthroughCasesInSwitch": true,
        "noUncheckedSideEffectImports": true,
        "baseUrl": ".",
        "paths": {
            "~/*": [
                "./src/*"
            ]
        }
    }
}
</file>

<file path="src/components/games/create-game-form.tsx">
import { useMutation } from "@tanstack/react-query";
import type { z } from "zod";
import { createGameMutation } from "~/api/@tanstack/react-query.gen";
import { zGameCreateParams } from "~/api/zod.gen";
import { Button } from "~/components/ui/button";
import { createFormHook } from "~/components/ui/form-tanstack";
import { Input } from "~/components/ui/input";
import { Textarea } from "~/components/ui/textarea";

const { useAppForm } = createFormHook();

type FormData = z.infer<typeof zGameCreateParams>;

export function CreateGameForm() {
	const createGame = useMutation(createGameMutation());

	const form = useAppForm({
		defaultValues: {
			name: "",
			content: "",
			setting: "",
		} as FormData,
		validators: {
			onChange: zGameCreateParams,
		},
		onSubmit: async ({ value }) => {
			try {
				await createGame.mutateAsync({
					body: {
						game: {
							name: value.name,
							content: value.content || undefined,
							setting: value.setting || undefined,
						},
					},
				});
				form.reset();
			} catch (error) {
				console.error("Failed to create game:", error);
			}
		},
	});

	return (
		<form.AppForm>
			<form
				onSubmit={(e) => {
					e.preventDefault();
					form.handleSubmit();
				}}
				className="space-y-6"
			>
				<form.AppField 
					name="name"
					validators={{
						onChange: ({ value }) => 
							!value || value.trim().length === 0 ? "Game name is required" : undefined,
					}}
				>
					{(field) => (
						<form.Item>
							<field.Label>Game Name</field.Label>
							<field.Control>
								<Input
									name={field.name}
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
									placeholder="Enter game name"
								/>
							</field.Control>
							<field.Message />
						</form.Item>
					)}
				</form.AppField>

				<form.AppField name="setting">
					{(field) => (
						<form.Item>
							<field.Label>Setting</field.Label>
							<field.Control>
								<Input
									name={field.name}
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
									placeholder="e.g., Fantasy, Sci-Fi, Modern"
								/>
							</field.Control>
							<field.Description>
								The genre or setting of your game
							</field.Description>
							<field.Message />
						</form.Item>
					)}
				</form.AppField>

				<form.AppField name="content">
					{(field) => (
						<form.Item>
							<field.Label>Description</field.Label>
							<field.Control>
								<Textarea
									name={field.name}
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
									placeholder="Describe your game world, campaign, or setting"
									rows={4}
								/>
							</field.Control>
							<field.Description>
								A detailed description of your game
							</field.Description>
							<field.Message />
						</form.Item>
					)}
				</form.AppField>

				<Button
					type="submit"
					disabled={createGame.isPending || !form.state.canSubmit}
				>
					{createGame.isPending ? "Creating..." : "Create Game"}
				</Button>
			</form>
		</form.AppForm>
	);
}
</file>

<file path="src/components/links/hooks/useCreateLink.ts">
import { useMutation, useQueryClient } from "@tanstack/react-query";
import {
	createCharacterLinkMutation,
	createFactionLinkMutation,
	createLocationLinkMutation,
	createNoteLinkMutation,
	createQuestLinkMutation,
} from "~/api/@tanstack/react-query.gen";
import type { LinkRequest } from "~/api/types.gen";
import type { CreateLinkParams } from "../types";

export function useCreateLink(onSuccess?: () => void, onError?: (error: Error) => void) {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async ({
			gameId,
			sourceType,
			sourceId,
			entity_type,
			entity_id,
			description,
			metadata,
			is_active,
			relationship_type,
			strength,
		}: CreateLinkParams) => {
			// Create the path parameter based on source entity type
			const pathParam = {
				game_id: gameId,
				[`${sourceType}_id`]: sourceId,
			};

			// Select the appropriate mutation based on source type
			const mutationMap = {
				character: createCharacterLinkMutation(),
				faction: createFactionLinkMutation(),
				location: createLocationLinkMutation(),
				note: createNoteLinkMutation(),
				quest: createQuestLinkMutation(),
			};

			const mutation = mutationMap[sourceType];
			if (!mutation.mutationFn) {
				throw new Error(`Unsupported entity type: ${sourceType}`);
			}

			return mutation.mutationFn({
				path: pathParam as any,
				body: {
					entity_type,
					entity_id,
					relationship_type,
					description,
					metadata,
					is_active,
					strength,
				} as LinkRequest,
			});
		},
		onSuccess: () => {
			// Invalidate relevant queries to refresh data
			queryClient.invalidateQueries({ queryKey: [{ _id: "listGameEntities" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getCharacterLinks" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getFactionLinks" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getLocationLinks" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getNoteLinks" }] });
			queryClient.invalidateQueries({ queryKey: [{ _id: "getQuestLinks" }] });
			onSuccess?.();
		},
		onError,
	});
}
</file>

<file path="src/components/links/hooks/useGameEntities.ts">
import { useMemo } from "react";
import { useGetGameLinksSuspenseQuery } from "~/queries/games";
import type { EntityType } from "~/types";
import type { EntityOption } from "../types";

export function useGameEntities(
	gameId: string,
	excludeTypes?: EntityType[],
	excludeIds?: string[],
) {
	const { data, isLoading, error } = useGetGameLinksSuspenseQuery({ id: gameId });

	const entities = useMemo(() => {
		if (!data?.data?.entities) {
			return {
				character: [],
				faction: [],
				location: [],
				note: [],
				quest: [],
			} as Record<EntityType, EntityOption[]>;
		}

		const entityGroups: Record<EntityType, EntityOption[]> = {
			character: [],
			faction: [],
			location: [],
			note: [],
			quest: [],
		};

		const rawEntities = data.data.entities;

		const transformers: Record<string, (items: any[]) => EntityOption[]> = {
			characters: (items) =>
				items?.map((item) => ({
					label: item.name,
					value: `character:${item.id}`,
					type: "character" as EntityType,
				})) ?? [],
			factions: (items) =>
				items?.map((item) => ({
					label: item.name,
					value: `faction:${item.id}`,
					type: "faction" as EntityType,
				})) ?? [],
			locations: (items) =>
				items?.map((item) => ({
					label: item.name,
					value: `location:${item.id}`,
					type: "location" as EntityType,
				})) ?? [],
			notes: (items) =>
				items?.map((item) => ({
					label: item.name,
					value: `note:${item.id}`,
					type: "note" as EntityType,
				})) ?? [],
			quests: (items) =>
				items?.map((item) => ({
					label: item.name,
					value: `quest:${item.id}`,
					type: "quest" as EntityType,
				})) ?? [],
		};

		const typeMapping: Record<string, EntityType> = {
			characters: "character",
			factions: "faction",
			locations: "location",
			notes: "note",
			quests: "quest",
		};

		Object.entries(transformers).forEach(([type, transformer]) => {
			const entityType = typeMapping[type];

			if (excludeTypes?.includes(entityType)) return;

			const items = rawEntities[type as keyof typeof rawEntities];
			if (items) {
				entityGroups[entityType] = transformer(items).filter(
					(item) => !excludeIds?.includes(item.value),
				);
			}
		});

		const result: Record<EntityType, EntityOption[]> = {
			character: entityGroups.character,
			faction: entityGroups.faction,
			location: entityGroups.location,
			note: entityGroups.note,
			quest: entityGroups.quest,
		};

		return result;
	}, [data, excludeTypes, excludeIds]);

	return {
		entities,
		isLoading,
		error,
		flatEntities: useMemo(() => Object.values(entities).flat(), [entities]),
	};
}
</file>

<file path="src/components/notes/create-note-sheet.tsx">
import type { EntityType } from "~/types";
import { Sheet, SheetContent } from "../ui/sheet";
import { CreateNoteForm } from "./create-note-form";

interface CreateNoteSheetProps {
	isOpen: boolean;
	setIsOpen: (isOpen: boolean) => void;
	parentId?: string;
	parentType?: EntityType;
}

export function CreateNoteSheet({
	isOpen,
	setIsOpen,
	parentId,
	parentType,
}: CreateNoteSheetProps) {
	return (
		<Sheet open={isOpen} onOpenChange={setIsOpen}>
			<SheetContent className="p-4 pt-10" width="lg">
				<CreateNoteForm parentId={parentId} parentType={parentType} />
			</SheetContent>
		</Sheet>
	);
}
</file>

<file path="src/components/quests/create-quest-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useParams } from "@tanstack/react-router";
import { toast } from "sonner";
import {
	createQuestMutation,
	getQuestTreeQueryKey,
	listQuestsQueryKey,
	useListQuestsQuery,
} from "~/api/@tanstack/react-query.gen";
import { Button } from "~/components/ui/button";
import { useSmartForm } from "../forms/smart-factory";
import { schemas } from "../forms/type-utils";
import { ParentQuestSelect } from "./parent-quest-select";

interface CreateQuestFormProps {
	container?: React.RefObject<HTMLElement | null>;
}

export function CreateQuestForm({ container }: CreateQuestFormProps) {
	const { gameId } = useParams({ from: "/_auth/games/$gameId" });
	const queryClient = useQueryClient();

	// Fetch existing quests for parent selection
	const { data: questsData, isLoading: questsLoading } = useListQuestsQuery({
		path: { game_id: gameId },
	});
	const quests = questsData?.data || [];

	const { form, mutation, renderSmartField } = useSmartForm({
		mutation: () => createQuestMutation({ path: { game_id: gameId } }),
		schema: schemas.quest,
		entityName: "quest",
		onSuccess: async () => {
			toast("Quest created successfully!");
			queryClient.invalidateQueries({
				queryKey: listQuestsQueryKey({
					path: { game_id: gameId },
				}),
			});
			queryClient.invalidateQueries({
				queryKey: getQuestTreeQueryKey({
					path: { game_id: gameId },
				}),
			});
		},
	});

	return (
		<div className="space-y-6">
			<form.AppForm>
				<form
					onSubmit={(e) => {
						e.preventDefault();
						form.handleSubmit();
					}}
				>
					<div className="space-y-6">
						{renderSmartField("name")}

						{/* Custom parent quest selector */}
						<form.AppField name="parent_id">
							{(field) => (
								<form.Item>
									<field.Label>Parent Quest</field.Label>
									<field.Control>
										{questsLoading ? (
											<div className="text-muted-foreground text-sm p-2">
												Loading quests...
											</div>
										) : (
											<ParentQuestSelect
												quests={quests}
												value={field.state.value}
												onChange={field.handleChange}
												placeholder="Select parent quest (optional)"
												container={container}
											/>
										)}
									</field.Control>
									<field.Description>
										Choose a parent quest to create a hierarchical
										quest structure. Leave empty for main quests.
									</field.Description>
									<field.Message />
								</form.Item>
							)}
						</form.AppField>

						{renderSmartField("tags")}
						{renderSmartField("content")}

						<div className="flex gap-2">
							<Button type="submit" disabled={mutation.isPending}>
								{mutation.isPending ? "Creating..." : "Create Quest"}
							</Button>

							<Button
								type="button"
								variant="outline"
								onClick={() => {
									if (
										form.state.isDirty &&
										!confirm(
											"Are you sure? All unsaved changes will be lost.",
										)
									) {
										return;
									}
									form.reset();
								}}
							>
								Reset
							</Button>
						</div>
					</div>
				</form>
			</form.AppForm>

			{mutation.isError && (
				<div className="mt-4 bg-destructive/10 border border-destructive/20 text-destructive px-4 py-3 rounded-md">
					<p className="text-sm">
						{(mutation.error as any)?.message || "Something went wrong"}
					</p>
				</div>
			)}
		</div>
	);
}
</file>

<file path="src/components/quests/edit-quest-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import type { QuestUpdateParams } from "~/api";
import {
	getQuestQueryKey,
	listQuestsQueryKey,
	updateQuestMutation,
} from "~/api/@tanstack/react-query.gen";
import { createSmartForm } from "../forms/smart-factory";
import { schemas } from "../forms/type-utils";

interface EditQuestFormProps {
	params: {
		gameId: string;
		id: string;
	};
	initialData?: Partial<QuestUpdateParams>;
}

export function EditQuestForm({ initialData, params }: EditQuestFormProps) {
	const { gameId, id } = params;
	const queryClient = useQueryClient();
	const navigate = useNavigate();

	const FormComponent = createSmartForm({
		mutation: () =>
			updateQuestMutation({
				path: {
					game_id: gameId,
					id,
				},
			}),
		onSuccess: async () => {
			toast("Quest updated successfully!");
			queryClient.invalidateQueries({
				queryKey: listQuestsQueryKey({
					path: { game_id: gameId },
				}),
			});
			queryClient.invalidateQueries({
				queryKey: getQuestQueryKey({
					path: {
						game_id: gameId,
						id: id,
					},
				}),
			});
			navigate({ to: ".." });
		},
		schema: schemas.quest,
		entityName: "quest",
		initialValues: {
			...initialData,
			image_url: initialData?.image_url || undefined,
		},
		fieldOverrides: {
			content: null,
		},
	});

	return <FormComponent />;
}
</file>

<file path="src/components/ui/editor/mention-extension-simple.tsx">
import { mergeAttributes, Node } from "@tiptap/core";
import { PluginKey } from "@tiptap/pm/state";
import { ReactNodeViewRenderer, ReactRenderer } from "@tiptap/react";
import { Suggestion } from "@tiptap/suggestion";
import tippy, { type Instance } from "tippy.js";
import { MentionComponent } from "./mention-component";
import { MentionList } from "./mention-list";

export interface MentionItem {
	id: string;
	label: string;
	type: "character" | "faction" | "location" | "note" | "quest";
	gameId: string;
}

export const SimpleMention = Node.create({
	name: "mention",

	addOptions() {
		return {
			HTMLAttributes: {},
			suggestion: {
				char: "@",
				pluginKey: new PluginKey("mention"),
				command: ({ editor, range, props }: any) => {
					editor
						.chain()
						.focus()
						.insertContentAt(range, [
							{
								type: this.name,
								attrs: props,
							},
							{ type: "text", text: " " },
						])
						.run();

					window.getSelection()?.collapseToEnd();
				},
				allow: ({ state, range }: any) => {
					const $from = state.doc.resolve(range.from);
					const type = state.schema.nodes[this.name];
					const allow = !!$from.parent.type.contentMatch.matchType(type);
					return allow;
				},
				render: () => {
					let component: ReactRenderer<any>;
					let popup: Instance[];

					return {
						onStart: (props: any) => {
							component = new ReactRenderer(MentionList, {
								props,
								editor: props.editor,
							});

							if (!props.clientRect) {
								return;
							}

							popup = tippy("body", {
								getReferenceClientRect: props.clientRect,
								appendTo: () => document.body,
								content: component.element,
								showOnCreate: true,
								interactive: true,
								trigger: "manual",
								placement: "bottom-start",
							});
						},

						onUpdate(props: any) {
							component?.updateProps(props);

							if (!props.clientRect || !popup?.length) {
								return;
							}

							popup[0].setProps({
								getReferenceClientRect: props.clientRect,
							});
						},

						onKeyDown(props: any) {
							if (props.event.key === "Escape") {
								if (popup?.length) {
									popup[0].hide();
								}
								return true;
							}

							return component?.ref?.onKeyDown(props);
						},

						onExit() {
							if (popup?.length) {
								popup.forEach((instance) => {
									if (!instance.state.isDestroyed) {
										instance.destroy();
									}
								});
							}
							component?.destroy();
						},
					};
				},
			},
		};
	},

	group: "inline",

	inline: true,

	selectable: false,

	atom: true,

	addAttributes() {
		return {
			id: {
				default: null,
				parseHTML: (element) => element.getAttribute("data-id"),
				renderHTML: (attributes) => ({
					"data-id": attributes.id,
				}),
			},
			label: {
				default: null,
				parseHTML: (element) => element.getAttribute("data-label"),
				renderHTML: (attributes) => ({
					"data-label": attributes.label,
				}),
			},
			type: {
				default: null,
				parseHTML: (element) => element.getAttribute("data-type"),
				renderHTML: (attributes) => ({
					"data-type": attributes.type,
				}),
			},
			gameId: {
				default: null,
				parseHTML: (element) => element.getAttribute("data-game-id"),
				renderHTML: (attributes) => ({
					"data-game-id": attributes.gameId,
				}),
			},
		};
	},

	parseHTML() {
		return [
			{
				tag: `span[data-type="${this.name}"]`,
			},
		];
	},

	renderHTML({ HTMLAttributes }) {
		return [
			"span",
			mergeAttributes(
				{ "data-type": this.name },
				this.options.HTMLAttributes,
				HTMLAttributes,
			),
		];
	},

	addNodeView() {
		return ReactNodeViewRenderer(MentionComponent, {
			stopEvent: (props: { event: Event }) => {
				// Allow click events on the mention component
				return props.event.type === "click" || props.event.type === "mousedown";
			},
			// Use React 18 concurrent rendering to avoid flushSync conflicts
			as: "span",
			className: "mention-wrapper",
		});
	},

	addProseMirrorPlugins() {
		return [
			Suggestion({
				editor: this.editor,
				...this.options.suggestion,
			}),
		];
	},
});
</file>

<file path="src/components/ui/editor/mention-list.tsx">
import * as React from "react";
import { cn } from "~/utils/cn";
import type { MentionItem } from "./mention-extension-simple";

interface MentionListProps {
	items: MentionItem[];
	command: (item: MentionItem) => void;
}

interface MentionListRef {
	onKeyDown: ({ event }: { event: KeyboardEvent }) => boolean;
}

export const MentionList = React.forwardRef<MentionListRef, MentionListProps>(
	(props, ref) => {
		const [selectedIndex, setSelectedIndex] = React.useState(0);
		const divRef = React.useRef<HTMLDivElement>(null);

		const selectItem = (index: number) => {
			const item = props.items[index];
			if (item) {
				props.command(item);
			}
		};

		const upHandler = () => {
			setSelectedIndex(
				(selectedIndex + props.items.length - 1) % props.items.length,
			);
		};

		const downHandler = () => {
			setSelectedIndex((selectedIndex + 1) % props.items.length);
		};

		const enterHandler = () => {
			selectItem(selectedIndex);
		};

		// biome-ignore lint/correctness/useExhaustiveDependencies: resets whenever items array changes in any way -> safest option
		React.useEffect(() => {
			setSelectedIndex(0);
		}, [props.items]);

		React.useImperativeHandle(ref, () => ({
			onKeyDown: ({ event }: { event: KeyboardEvent }) => {
				if (event.key === "ArrowUp") {
					upHandler();
					return true;
				}

				if (event.key === "ArrowDown") {
					downHandler();
					return true;
				}

				if (event.key === "Enter") {
					enterHandler();
					return true;
				}

				return false;
			},
		}));

		const getEntityIcon = (type: MentionItem["type"]) => {
			switch (type) {
				case "character":
					return "üë§";
				case "faction":
					return "‚öî";
				case "location":
					return "üó∫";
				case "note":
					return "üìù";
				case "quest":
					return "üéØ";
				default:
					return "üìÑ";
			}
		};

		const getEntityTypeLabel = (type: MentionItem["type"]) => {
			switch (type) {
				case "character":
					return "Character";
				case "faction":
					return "Faction";
				case "location":
					return "Location";
				case "note":
					return "Note";
				case "quest":
					return "Quest";
				default:
					return "Entity";
			}
		};

		return (
			<div
				ref={divRef}
				className="bg-popover border border-border rounded-lg shadow-md max-h-60 overflow-auto p-1"
			>
				{props.items.length ? (
					props.items.map((item, index) => (
						<button
							key={item.id}
							type="button"
							className={cn(
								"flex items-center gap-2 w-full px-2 py-1.5 text-left text-sm rounded hover:bg-accent",
								index === selectedIndex ? "bg-accent" : "transparent",
							)}
							onClick={() => selectItem(index)}
						>
							<span className="text-base">{getEntityIcon(item.type)}</span>
							<div className="flex-1 min-w-0">
								<div className="font-medium text-foreground truncate">
									{item.label}
								</div>
								<div className="text-xs text-muted-foreground">
									{getEntityTypeLabel(item.type)}
								</div>
							</div>
						</button>
					))
				) : (
					<div className="px-2 py-1.5 text-sm text-muted-foreground">
						No results found
					</div>
				)}
			</div>
		);
	},
);

MentionList.displayName = "MentionList";
</file>

<file path="src/components/ui/entity-table.tsx">
import { Link as RouterLink } from "@tanstack/react-router";
import {
	type ColumnDef,
	type ColumnFiltersState,
	flexRender,
	getCoreRowModel,
	getFilteredRowModel,
	getPaginationRowModel,
	getSortedRowModel,
	type SortingState,
	useReactTable,
	type VisibilityState,
} from "@tanstack/react-table";
import { ArrowUpDown, ChevronDown, MoreHorizontal } from "lucide-react";
import * as React from "react";
import { toast } from "sonner";

import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
	DropdownMenu,
	DropdownMenuCheckboxItem,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuPortal,
	DropdownMenuPositioner,
	DropdownMenuTrigger,
} from "~/components/ui/dropdown-menu";
import { Input } from "~/components/ui/input";
import { Link } from "~/components/ui/link";
import {
	Table,
	TableBody,
	TableCell,
	TableHead,
	TableHeader,
	TableRow,
} from "~/components/ui/table";

// ============================================================================
// REUSABLE CELL COMPONENTS
// ============================================================================

interface SortableHeaderProps {
	column: any;
	children: React.ReactNode;
}

export function SortableHeader({ column, children }: SortableHeaderProps) {
	return (
		<Button
			variant="ghost"
			onClick={() => column.toggleSorting(column.getIsSorted() === "asc")}
		>
			{children}
			<ArrowUpDown className="ml-2 h-4 w-4" />
		</Button>
	);
}

interface EntityLinkProps {
	entityType: string;
	gameId: string;
	entityId: string | number;
	name: string;
	className?: string;
}

export function EntityLink({
	entityType,
	gameId,
	entityId,
	name,
	className = "font-medium hover:underline truncate block",
}: EntityLinkProps) {
	return (
		<Link
			to={`/games/${gameId}/${entityType}s/${entityId}` as string}
			className={className}
		>
			{name}
		</Link>
	);
}

interface TagsDisplayProps {
	tags?: string[];
	maxVisible?: number;
}

export function TagsDisplay({ tags, maxVisible = 3 }: TagsDisplayProps) {
	if (!tags || tags.length === 0) {
		return <div className="text-sm text-muted-foreground">-</div>;
	}

	const visibleTags = tags.slice(0, maxVisible);
	const remainingCount = tags.length - maxVisible;

	return (
		<div className="flex flex-wrap gap-1">
			{visibleTags.map((tag) => (
				<Badge key={tag} variant="outline" className="text-xs">
					{tag}
				</Badge>
			))}
			{remainingCount > 0 && (
				<Badge variant="outline" className="text-xs">
					+{remainingCount}
				</Badge>
			)}
		</div>
	);
}

interface DateDisplayProps {
	date?: string;
	className?: string;
}

export function DateDisplay({ date, className = "text-sm" }: DateDisplayProps) {
	if (!date) {
		return <span className="text-muted-foreground">-</span>;
	}

	return <div className={className}>{new Date(date).toLocaleDateString()}</div>;
}

interface ContentDisplayProps {
	content?: string;
	maxWidth?: string;
	placeholder?: string;
}

export function ContentDisplay({
	content,
	maxWidth = "max-w-[300px]",
	placeholder = "No content",
}: ContentDisplayProps) {
	return (
		<div className={`${maxWidth} truncate text-sm`}>
			{content || (
				<span className="text-muted-foreground italic">{placeholder}</span>
			)}
		</div>
	);
}

interface ActionsDropdownProps {
	entityType: string;
	entityName: string;
	entity: { id: string | number };
	gameId: string;
	onDelete?: () => void;
	onEdit?: () => void;
	showDelete?: boolean;
}

export function ActionsDropdown({
	entityType,
	entityName,
	entity,
	gameId,
	onDelete,
	onEdit,
	showDelete = true,
}: ActionsDropdownProps) {
	const capitalizedType = entityType.charAt(0).toUpperCase() + entityType.slice(1);

	return (
		<DropdownMenu>
			<DropdownMenuTrigger
				render={
					<Button variant="ghost" className="h-8 w-8 p-0">
						<span className="sr-only">Open menu</span>
						<MoreHorizontal className="h-4 w-4" />
					</Button>
				}
			></DropdownMenuTrigger>
			<DropdownMenuPortal>
				<DropdownMenuPositioner>
					<DropdownMenuContent>
						<DropdownMenuItem
							onClick={() => {
								navigator.clipboard.writeText(entity.id.toString());
								toast(`${capitalizedType} ID copied to clipboard!`);
							}}
						>
							Copy {entityName} ID
						</DropdownMenuItem>
						<DropdownMenuItem
							render={
								<RouterLink
									to={
										`/games/${gameId}/${entityType}s/${entity.id}` as string
									}
								/>
							}
						>
							View {entityName}
						</DropdownMenuItem>
						<DropdownMenuItem onClick={onEdit}>
							Edit {entityName}
						</DropdownMenuItem>
						{showDelete && (
							<DropdownMenuItem variant="destructive" onClick={onDelete}>
								Delete {entityName}
							</DropdownMenuItem>
						)}
					</DropdownMenuContent>
				</DropdownMenuPositioner>
			</DropdownMenuPortal>
		</DropdownMenu>
	);
}

// ============================================================================
// ENTITY TABLE COMPONENT
// ============================================================================

interface EntityTableProps<TData, TValue> {
	columns: ColumnDef<TData, TValue>[];
	data: TData[];
	searchQuery: string;
	onSearchChange: (query: string) => void;
	tagFilter: string;
	onTagFilterChange: (tag: string) => void;
	entityName?: string; // e.g., "character", "faction", "quest"
	searchPlaceholder?: string;
	tagPlaceholder?: string;
	paginationSize?: number;
	enableColumnVisibility?: boolean;
}

export function EntityTable<TData, TValue>({
	columns,
	data,
	searchQuery,
	onSearchChange,
	tagFilter,
	onTagFilterChange,
	entityName = "entity",
	searchPlaceholder = "Filter names...",
	tagPlaceholder = "Filter tags...",
	paginationSize = 10,
	enableColumnVisibility = true,
}: EntityTableProps<TData, TValue>) {
	const [sorting, setSorting] = React.useState<SortingState>([]);
	const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([]);
	const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>({});

	const table = useReactTable({
		data,
		columns,
		onSortingChange: setSorting,
		onColumnFiltersChange: setColumnFilters,
		getCoreRowModel: getCoreRowModel(),
		getPaginationRowModel: getPaginationRowModel(),
		getSortedRowModel: getSortedRowModel(),
		getFilteredRowModel: getFilteredRowModel(),
		onColumnVisibilityChange: setColumnVisibility,
		state: {
			sorting,
			columnFilters,
			columnVisibility,
		},
		filterFns: {
			fuzzy: (row, columnId, value) => {
				const itemValue = row.getValue(columnId) as string | string[];
				if (Array.isArray(itemValue)) {
					return itemValue.some((item) =>
						item.toLowerCase().includes(value.toLowerCase()),
					);
				}
				return itemValue?.toLowerCase().includes(value.toLowerCase()) ?? false;
			},
		},
		initialState: {
			pagination: {
				pageSize: paginationSize,
			},
		},
	});

	React.useEffect(() => {
		table.getColumn("name")?.setFilterValue(searchQuery);
	}, [searchQuery, table]);

	React.useEffect(() => {
		const column = table.getColumn("tags");
		if (column) {
			column.setFilterValue(tagFilter);
		}
	}, [tagFilter, table]);

	return (
		<div className="w-full max-w-full">
			<div className="flex items-center gap-4 py-4">
				<Input
					placeholder={searchPlaceholder}
					value={searchQuery}
					onChange={(event) => onSearchChange(event.target.value)}
					className="max-w-sm"
				/>
				<Input
					placeholder={tagPlaceholder}
					value={tagFilter}
					onChange={(event) => onTagFilterChange(event.target.value)}
					className="max-w-sm"
				/>
				{enableColumnVisibility && (
					<DropdownMenu>
						<DropdownMenuTrigger
							render={
								<Button variant="outline" className="ml-auto">
									Columns <ChevronDown className="ml-2 h-4 w-4" />
								</Button>
							}
						></DropdownMenuTrigger>
						<DropdownMenuPortal>
							<DropdownMenuPositioner>
								<DropdownMenuContent>
									{table
										.getAllColumns()
										.filter((column) => column.getCanHide())
										.map((column) => {
											return (
												<DropdownMenuCheckboxItem
													key={column.id}
													className="capitalize"
													checked={column.getIsVisible()}
													onCheckedChange={(value) =>
														column.toggleVisibility(!!value)
													}
												>
													{column.id}
												</DropdownMenuCheckboxItem>
											);
										})}
								</DropdownMenuContent>
							</DropdownMenuPositioner>
						</DropdownMenuPortal>
					</DropdownMenu>
				)}
			</div>
			<div className="overflow-hidden rounded-md border">
				<div className="overflow-x-auto">
					<Table className="table-fixed w-full">
						<TableHeader>
							{table.getHeaderGroups().map((headerGroup) => (
								<TableRow key={headerGroup.id}>
									{headerGroup.headers.map((header) => {
										return (
											<TableHead
												key={header.id}
												style={{
													width:
														header.id === "actions"
															? header.getSize()
															: undefined,
												}}
											>
												{header.isPlaceholder
													? null
													: flexRender(
															header.column.columnDef
																.header,
															header.getContext(),
														)}
											</TableHead>
										);
									})}
								</TableRow>
							))}
						</TableHeader>
						<TableBody>
							{table.getRowModel().rows?.length ? (
								table.getRowModel().rows.map((row) => (
									<TableRow
										key={row.id}
										data-state={row.getIsSelected() && "selected"}
									>
										{row.getVisibleCells().map((cell) => (
											<TableCell key={cell.id}>
												{flexRender(
													cell.column.columnDef.cell,
													cell.getContext(),
												)}
											</TableCell>
										))}
									</TableRow>
								))
							) : (
								<TableRow>
									<TableCell
										colSpan={columns.length}
										className="h-24 text-center"
									>
										No results.
									</TableCell>
								</TableRow>
							)}
						</TableBody>
					</Table>
				</div>
			</div>
			<div className="flex items-center justify-end space-x-2 py-4">
				<div className="flex-1 text-sm text-muted-foreground">
					{table.getFilteredRowModel().rows.length} of {data.length}{" "}
					{entityName}(s) total.
				</div>
				<div className="space-x-2">
					<Button
						variant="outline"
						size="sm"
						onClick={() => table.previousPage()}
						disabled={!table.getCanPreviousPage()}
					>
						Previous
					</Button>
					<Button
						variant="outline"
						size="sm"
						onClick={() => table.nextPage()}
						disabled={!table.getCanNextPage()}
					>
						Next
					</Button>
				</div>
			</div>
		</div>
	);
}
</file>

<file path="src/components/ui/select.tsx">
import { Select as SelectPrimitive } from "@base-ui-components/react/select";
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react";
import type * as React from "react";
import { cn } from "~/utils/cn";

function Select<
	Value,
	Multiple extends boolean | undefined = false,
>({ ...props }: SelectPrimitive.Root.Props<Value, Multiple>) {
	return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({ ...props }: React.ComponentProps<typeof SelectPrimitive.Group>) {
	return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectPortal({ ...props }: React.ComponentProps<typeof SelectPrimitive.Portal>) {
	return <SelectPrimitive.Portal data-slot="select-portal" {...props} />;
}

function SelectValue({
	placeholder,
	...props
}: React.ComponentProps<typeof SelectPrimitive.Value> & {
	placeholder?: string;
}) {
	if (!placeholder) {
		return <SelectPrimitive.Value data-slot="select-value" {...props} />;
	}

	return (
		<SelectPrimitive.Value
			render={(_, { value }) => {
				if (value) {
					return <SelectPrimitive.Value data-slot="select-value" {...props} />;
				}

				// Placeholder
				return (
					<span data-slot="select-value" className="text-muted-foreground">
						{placeholder}
					</span>
				);
			}}
			{...props}
		/>
	);
}

function SelectTrigger({
	className,
	size = "default",
	children,
	...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
	size?: "sm" | "default";
}) {
	return (
		<SelectPrimitive.Trigger
			data-slot="select-trigger"
			data-size={size}
			className={cn(
				"border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				className,
			)}
			{...props}
		>
			{children}
			<SelectPrimitive.Icon
				render={<ChevronDownIcon className="size-4 opacity-50" />}
			/>
		</SelectPrimitive.Trigger>
	);
}

function SelectPositioner({
	...props
}: React.ComponentProps<typeof SelectPrimitive.Positioner>) {
	return (
		<SelectPrimitive.Positioner
			data-slot="select-positioner"
			alignItemWithTrigger={false}
			sideOffset={5}
			{...props}
		/>
	);
}

function SelectContent({
	className,
	children,
	...props
}: React.ComponentProps<typeof SelectPrimitive.Popup>) {
	return (
		<>
			<SelectScrollUpButton />
			<SelectPrimitive.Popup
				data-slot="select-content"
				className={cn(
					"p-1 bg-popover text-popover-foreground data-[open]:animate-in data-[closed]:animate-out data-[closed]:fade-out-0 data-[open]:fade-in-0 data-[closed]:zoom-out-95 data-[open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--available-height) min-w-(--anchor-width) origin-(--transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
					className,
				)}
				{...props}
			>
				{children}
			</SelectPrimitive.Popup>
			<SelectScrollDownButton />
		</>
	);
}

function SelectLabel({
	className,
	...props
}: React.ComponentProps<typeof SelectPrimitive.GroupLabel>) {
	return (
		<SelectPrimitive.GroupLabel
			data-slot="select-label"
			className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
			{...props}
		/>
	);
}

function SelectItem({
	className,
	children,
	...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
	return (
		<SelectPrimitive.Item
			data-slot="select-item"
			className={cn(
				"focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
				className,
			)}
			{...props}
		>
			<span className="absolute right-2 flex size-3.5 items-center justify-center">
				<SelectPrimitive.ItemIndicator>
					<CheckIcon className="size-4" />
				</SelectPrimitive.ItemIndicator>
			</span>
			<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
		</SelectPrimitive.Item>
	);
}

function SelectSeparator({
	className,
	...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
	return (
		<SelectPrimitive.Separator
			data-slot="select-separator"
			className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
			{...props}
		/>
	);
}

function SelectScrollUpButton({
	className,
	...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpArrow>) {
	return (
		<SelectPrimitive.ScrollUpArrow
			data-slot="select-scroll-up-button"
			className={cn(
				"w-full bg-popover z-51 text-center cursor-default h-6 flex items-center justify-center text-md border data-[direction=up]:border-b-0 data-[direction=down]:border-t-0 data-[direction=up]:rounded-t-md data-[direction=down]:rounded-b-md",
				"before:content-[''] before:absolute before:w-full before:h-full before:left-0 data-[direction=up]:before:top-full data-[direction=down]:bottom-0 data-[direction=down]:before:-bottom-full",
				className,
			)}
			{...props}
		>
			<ChevronUpIcon className="size-4" />
		</SelectPrimitive.ScrollUpArrow>
	);
}
function SelectScrollDownButton({
	className,
	...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownArrow>) {
	return (
		<SelectPrimitive.ScrollDownArrow
			data-slot="select-scroll-down-button"
			className={cn(
				"w-full bg-popover z-51 text-center cursor-default h-6 flex items-center justify-center text-md border data-[direction=up]:border-b-0 data-[direction=down]:border-t-0 data-[direction=up]:rounded-t-md data-[direction=down]:rounded-b-md",
				"before:content-[''] before:absolute before:w-full before:h-full before:left-0 data-[direction=up]:before:top-full data-[direction=down]:bottom-0 data-[direction=down]:before:-bottom-full",
				className,
			)}
			{...props}
		>
			<ChevronDownIcon className="size-4" />
		</SelectPrimitive.ScrollDownArrow>
	);
}

export {
	Select,
	SelectContent,
	SelectGroup,
	SelectPortal,
	SelectItem,
	SelectLabel,
	SelectSeparator,
	SelectTrigger,
	SelectValue,
	SelectPositioner,
};
</file>

<file path="src/components/ui/sheet.tsx">
import { Dialog as SheetPrimitive } from "@base-ui-components/react/dialog";
import { XIcon } from "lucide-react";
import * as React from "react";
import { cn } from "~/utils/cn";

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
	return <SheetPrimitive.Root data-slot="sheet" {...props} />;
}

function SheetTrigger({ ...props }: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
	return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />;
}

function SheetClose({ ...props }: React.ComponentProps<typeof SheetPrimitive.Close>) {
	return <SheetPrimitive.Close data-slot="sheet-close" {...props} />;
}

function SheetPortal({ ...props }: React.ComponentProps<typeof SheetPrimitive.Portal>) {
	return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />;
}

function SheetOverlay({
	className,
	...props
}: React.ComponentProps<typeof SheetPrimitive.Backdrop>) {
	return (
		<SheetPrimitive.Backdrop
			data-slot="sheet-overlay"
			className={cn(
				"data-[open]:animate-in data-[closed]:animate-out data-[closed]:fade-out-0 data-[closed]:animation-duration-[300ms] data-[open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
				className,
			)}
			{...props}
		/>
	);
}

function SheetContent({
	className,
	children,
	side = "right",
	width = "sm",
	ref,
	...props
}: React.ComponentProps<typeof SheetPrimitive.Popup> & {
	side?: "top" | "right" | "bottom" | "left";
	width?: "sm" | "md" | "lg" | "xl";
}) {
	return (
		<SheetPortal>
			<SheetOverlay />
			<SheetPrimitive.Popup
				ref={ref}
				data-slot="sheet-content"
				className={cn(
					"bg-background data-[open]:animate-in data-[closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[closed]:duration-300 data-[open]:duration-500",
					side === "right" && [
						"data-[closed]:slide-out-to-right data-[open]:slide-in-from-right inset-y-0 right-0 h-full border-l",
						width === "sm" && "w-3/4 sm:max-w-sm",
						width === "md" && "w-96",
						width === "lg" && "w-1/2",
						width === "xl" && "w-2/3",
					],
					side === "left" && [
						"data-[closed]:slide-out-to-left data-[open]:slide-in-from-left inset-y-0 left-0 h-full border-r",
						width === "sm" && "w-3/4 sm:max-w-sm",
						width === "md" && "w-96",
						width === "lg" && "w-1/2",
						width === "xl" && "w-2/3",
					],
					side === "top" &&
						"data-[closed]:slide-out-to-top data-[open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
					side === "bottom" &&
						"data-[closed]:slide-out-to-bottom data-[open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
					className,
				)}
				{...props}
			>
				{children}
				<SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
					<XIcon className="size-4" />
					<span className="sr-only">Close</span>
				</SheetPrimitive.Close>
			</SheetPrimitive.Popup>
		</SheetPortal>
	);
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sheet-header"
			className={cn("flex flex-col gap-1.5 p-4", className)}
			{...props}
		/>
	);
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="sheet-footer"
			className={cn("mt-auto flex flex-col gap-2 p-4", className)}
			{...props}
		/>
	);
}

function SheetTitle({
	className,
	...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
	return (
		<SheetPrimitive.Title
			data-slot="sheet-title"
			className={cn("text-foreground font-semibold", className)}
			{...props}
		/>
	);
}

function SheetDescription({
	className,
	...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
	return (
		<SheetPrimitive.Description
			data-slot="sheet-description"
			className={cn("text-muted-foreground text-sm", className)}
			{...props}
		/>
	);
}

export {
	Sheet,
	SheetTrigger,
	SheetClose,
	SheetContent,
	SheetHeader,
	SheetFooter,
	SheetTitle,
	SheetDescription,
};
</file>

<file path="src/components/entity-tabs.tsx">
import * as React from "react";
import type { Optional } from "~/types";
import { Button } from "./ui/button";
import { Link } from "./ui/link";

export interface Tab {
	data: {
		id: string;
		name: string;
	};
	entityType: string; // e.g., 'characters', 'factions', 'notes'
	gameId: string;
}

// Define the shape of the context's value
interface EntityTabsContextType {
	tabList: Tab[];
	addTab: (tab: Tab) => void;
	removeTab: (tabId: string) => void;
	clearAllTabs: () => void;
}

const EntityTabsContext = React.createContext<EntityTabsContextType | undefined>(
	undefined,
);

export const EntityTabsProvider = ({ children }: { children: React.ReactNode }) => {
	const [tabList, setTabList] = React.useState<Tab[]>([]);

	const addTab = React.useCallback((newTab: Tab) => {
		setTabList((prevTabs) => {
			// Check if a tab with the same ID already exists
			if (prevTabs.some((tab) => tab.data.id === newTab.data.id)) {
				return prevTabs; // If so, return the existing list
			}
			return [...prevTabs, newTab]; // Otherwise, add the new tab
		});
	}, []);

	const removeTab = React.useCallback((tabId: string) => {
		setTabList((prevTabs) => prevTabs.filter((t) => t.data.id !== tabId));
	}, []);

	const clearAllTabs = React.useCallback(() => {
		setTabList([]);
	}, []);

	const value = { tabList, addTab, removeTab, clearAllTabs };

	return (
		<EntityTabsContext.Provider value={value}>{children}</EntityTabsContext.Provider>
	);
};

export const useEntityTabs = () => {
	const context = React.useContext(EntityTabsContext);
	if (context === undefined) {
		throw new Error("useEntityTabs must be used within an EntityTabsProvider");
	}
	return context;
};

export const useAddTab = (tab: Optional<Tab, "data">) => {
	const { addTab } = useEntityTabs();
	React.useEffect(() => {
		if (tab.data) {
			addTab(tab as Tab);
		}
	}, [tab, addTab]);
};

export function EntityTabs() {
	const { tabList, removeTab, clearAllTabs } = useEntityTabs();
	// TODO: Add pin button
	// TODO: Add drag to reorder
	return (
		<nav className="sticky top-[73px] flex gap-2 flex-wrap w-full border-b px-1 items-center backdrop-blur-md bg-background/80 z-10">
			{tabList.map((tab) => {
				// Construct the path dynamically to prevent staleness
				const path = `/games/${tab.gameId}/${tab.entityType}/${tab.data.id}/`;
				const params = { gameId: tab.gameId, id: tab.data.id };

				return (
					<Link
						key={tab.data.id}
						to={path}
						params={params}
						variant={"ghost"}
						size={"sm"}
						className="mr-0 pr-0"
						activeProps={{
							variant: "outline",
						}}
					>
						{tab.data.name}
						<Button
							variant={"ghost"}
							size={"icon"}
							className="ml-auto mr-0"
							onClick={(e) => {
								e.preventDefault();
								e.stopPropagation();
								removeTab(tab.data.id);
							}}
						>
							&times;
						</Button>
					</Link>
				);
			})}
			{tabList.length > 0 && (
				<Button
					variant="ghost"
					size="sm"
					className="ml-auto text-muted-foreground hover:text-foreground"
					onClick={clearAllTabs}
					title="Clear all tabs"
				>
					Clear All
				</Button>
			)}
		</nav>
	);
}
</file>

<file path="src/queries/factions.ts">
import { useMutation, useQueryClient, useSuspenseQuery } from "@tanstack/react-query";
import {
	deleteFactionMutation,
	getFactionLinksOptions,
	getFactionOptions,
	getFactionQueryKey,
	listFactionsOptions,
	listFactionsQueryKey,
	updateFactionMutation,
} from "~/api/@tanstack/react-query.gen";

////////////////////////////////////////////////////////////////////////////////
//                                QUERIES
////////////////////////////////////////////////////////////////////////////////

export const useListFactionsSuspenseQuery = (gameId: string) => {
	return useSuspenseQuery(
		listFactionsOptions({
			path: { game_id: gameId },
		}),
	);
};

export const useFactionSuspenseQuery = (gameId: string, id: string) => {
	return useSuspenseQuery(
		getFactionOptions({
			path: { game_id: gameId, id },
		}),
	);
};

export const useGetFactionLinksSuspenseQuery = (gameId: string, factionId: string) => {
	return useSuspenseQuery(
		getFactionLinksOptions({
			path: { game_id: gameId, faction_id: factionId },
		}),
	);
};

////////////////////////////////////////////////////////////////////////////////
//                                MUTATIONS
////////////////////////////////////////////////////////////////////////////////

export const useUpdateFactionMutation = (gameId: string, factionId: string) => {
	const client = useQueryClient();
	return useMutation({
		...updateFactionMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: getFactionQueryKey({
					path: { game_id: gameId, id: factionId },
				}),
			});
		},
	});
};

export const useDeleteFactionMutation = (gameId: string) => {
	const client = useQueryClient();
	return useMutation({
		...deleteFactionMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: listFactionsQueryKey({
					path: { game_id: gameId },
				}),
			});
		},
	});
};
</file>

<file path="src/queries/quests.ts">
import { useMutation, useQueryClient, useSuspenseQuery } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import {
	deleteQuestMutation,
	getQuestOptions,
	getQuestQueryKey,
	getQuestTreeOptions,
	listPinnedEntitiesOptions,
	listQuestsOptions,
	listQuestsQueryKey,
	updateQuestMutation,
} from "~/api/@tanstack/react-query.gen";

////////////////////////////////////////////////////////////////////////////////
//                                QUERIES
////////////////////////////////////////////////////////////////////////////////

export const useListQuestsSuspenseQuery = (gameId: string) => {
	return useSuspenseQuery(listQuestsOptions({ path: { game_id: gameId } }));
};

export const useGetQuestSuspenseQuery = (gameId: string, id: string) => {
	return useSuspenseQuery(getQuestOptions({ path: { game_id: gameId, id } }));
};

export const useGetQuestTreeSuspenseQuery = (gameId: string) => {
	return useSuspenseQuery(getQuestTreeOptions({ path: { game_id: gameId } }));
};

export const useListPinnedEntitiesSuspenseQuery = (gameId: string) => {
	return useSuspenseQuery(listPinnedEntitiesOptions({ path: { game_id: gameId } }));
};

////////////////////////////////////////////////////////////////////////////////
//                                MUTATIONS
////////////////////////////////////////////////////////////////////////////////

export const useDeleteQuestMutation = (gameId: string) => {
	const navigate = useNavigate();
	const client = useQueryClient();
	return useMutation({
		...deleteQuestMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: listQuestsQueryKey({
					path: { game_id: gameId },
				}),
			});
			navigate({ to: ".." });
		},
	});
};

export const useUpdateQuestMutation = (gameId: string, questId: string) => {
	const client = useQueryClient();
	return useMutation({
		...updateQuestMutation(),
		onSuccess: () => {
			client.invalidateQueries({
				queryKey: getQuestQueryKey({
					path: { game_id: gameId, id: questId },
				}),
			});
		},
	});
};
</file>

<file path="src/routes/_auth/games/$gameId/characters/$id/route.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import {
	getCharacterLinksOptions,
	getCharacterNotesTreeOptions,
	getCharacterOptions,
} from "~/api/@tanstack/react-query.gen";
import { BasicErrorComponent } from "~/components/error";

export const Route = createFileRoute("/_auth/games/$gameId/characters/$id")({
	component: RouteComponent,
	loader: async ({ context, params }) => {
		await context.queryClient.ensureQueryData(
			getCharacterOptions({
				path: { game_id: params.gameId, id: params.id },
			}),
		);
		context.queryClient.ensureQueryData(
			getCharacterNotesTreeOptions({
				path: { game_id: params.gameId, id: params.id },
			}),
		);
		context.queryClient.ensureQueryData(
			getCharacterLinksOptions({
				path: { game_id: params.gameId, character_id: params.id },
			}),
		);
	},
	errorComponent: BasicErrorComponent,
});

function RouteComponent() {
	return <Outlet />;
}
</file>

<file path="src/routes/_auth/games/$gameId/locations/new.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { CreateLocationForm } from "~/components/locations/create-location-form";

export const Route = createFileRoute("/_auth/games/$gameId/locations/new")({
	component: RouteComponent,
});

function RouteComponent() {
	return (
		<div>
			<CreateLocationForm />
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/notes/new.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { CreateNoteForm } from "~/components/notes/create-note-form";

export const Route = createFileRoute("/_auth/games/$gameId/notes/new")({
	component: RouteComponent,
});

function RouteComponent() {
	return (
		<div>
			<CreateNoteForm />
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/quests/new.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { CreateQuestForm } from "~/components/quests/create-quest-form";

export const Route = createFileRoute("/_auth/games/$gameId/quests/new")({
	component: RouteComponent,
});

function RouteComponent() {
	return (
		<div>
			<CreateQuestForm />
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/index.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { listGamesOptions } from "~/api/@tanstack/react-query.gen";
import { AuthenticatedLayout } from "~/components/authenticated-layout";
import { GamesList } from "~/components/games-list";

export const Route = createFileRoute("/_auth/games/")({
	component: RouteComponent,
	loader: ({ context }) =>
		context.queryClient.ensureQueryData({ ...listGamesOptions() }),
});

function RouteComponent() {
	const { user } = Route.useRouteContext();

	return (
		<AuthenticatedLayout user={user!}>
			<GamesList />
		</AuthenticatedLayout>
	);
}
</file>

<file path="src/routes/index.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { AuthenticatedLayout } from "~/components/authenticated-layout";
import { Login } from "~/components/login";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "~/components/ui/card";
import { Link } from "~/components/ui/link";

export const Route = createFileRoute("/")({
	component: App,
});

function App() {
	const { user, token } = Route.useRouteContext();

	if (!token || !user) {
		return (
			<div className="min-h-screen flex flex-col items-center justify-center">
				<div className="max-w-md w-full">
					<div className="text-center mb-8">
						<h1 className="text-3xl font-bold mb-2">Game Master</h1>
						<p>Login to see your games</p>
					</div>
					<Login />
				</div>
			</div>
		);
	}

	return (
		<AuthenticatedLayout user={user}>
			<div className="w-1/2 mx-auto">
				<Card>
					<CardHeader>
						<CardTitle>Welcome back, {user.email.split("@")[0]}!</CardTitle>
						<CardDescription>Ready to manage your campaigns?</CardDescription>
					</CardHeader>
					<CardContent>
						<Link to="/games" variant="default">
							Go to Games
						</Link>
					</CardContent>
				</Card>
			</div>
		</AuthenticatedLayout>
	);
}
</file>

<file path="src/routes/logout.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { createServerFn } from "@tanstack/react-start";
import { useEffect } from "react";
import { getAppSession } from "~/utils/session";

const logoutFn = createServerFn({ method: "POST" }).handler(async () => {
	const session = await getAppSession();
	await session.clear();
});

export const Route = createFileRoute("/logout")({
	component: RouteComponent,
});

function RouteComponent() {
	useEffect(() => {
		const logout = async () => {
			await logoutFn();
			window.location.href = "/";
		};
		logout();
	}, []);

	return <div>Logging out...</div>;
}
</file>

<file path="src/router.tsx">
import { createRouter as createTanstackRouter } from "@tanstack/react-router";
import { setupRouterSsrQueryIntegration } from "@tanstack/react-router-ssr-query";
import * as TanstackQuery from "./integrations/tanstack-query/root-provider";

// Import the generated route tree
import { routeTree } from "./routeTree.gen";

export function getRouter() {
	return createRouter();
}

// Create a new router instance
export const createRouter = () => {
	const rqContext = TanstackQuery.getContext();

	const router = createTanstackRouter({
		routeTree,
		context: { ...rqContext },
		defaultPreload: "intent",
		Wrap: (props: { children: React.ReactNode }) => {
			return (
				<TanstackQuery.Provider {...rqContext}>
					{props.children}
				</TanstackQuery.Provider>
			);
		},
	});

	setupRouterSsrQueryIntegration({ router, queryClient: rqContext.queryClient });

	return router;
};

// Register the router instance for type safety
declare module "@tanstack/react-router" {
	interface Register {
		router: ReturnType<typeof createRouter>;
	}
}
</file>

<file path="src/components/characters/character-table.tsx">
import type { ColumnDef } from "@tanstack/react-table";
import * as React from "react";

import type { Character } from "~/api/types.gen";
import {
	ActionsDropdown,
	ContentDisplay,
	DateDisplay,
	EntityLink,
	EntityTable,
	SortableHeader,
	TagsDisplay,
} from "~/components/ui/entity-table";
import { useDeleteCharacterMutation } from "~/queries/characters";
import { Badge } from "../ui/badge";
import { EditCharacterDialog } from "./edit-character-dialog";

interface CharacterTableProps {
	data: Character[];
	searchQuery: string;
	onSearchChange: (query: string) => void;
	tagFilter: string;
	onTagFilterChange: (tag: string) => void;
	gameId: string;
}

function createCharacterColumns(gameId: string): ColumnDef<Character>[] {
	return [
		{
			accessorKey: "name",
			header: ({ column }) => <SortableHeader column={column}>Name</SortableHeader>,
			cell: ({ row }) => (
				<EntityLink
					entityType="character"
					gameId={gameId}
					entityId={row.original.id}
					name={row.getValue("name")}
				/>
			),
		},
		{
			accessorKey: "class",
			header: "Class",
			cell: ({ row }) => (
				<Badge variant="secondary" className="capitalize">
					{row.getValue("class")}
				</Badge>
			),
		},
		{
			accessorKey: "level",
			header: ({ column }) => (
				<SortableHeader column={column}>Level</SortableHeader>
			),
			cell: ({ row }) => <div className="text-center">{row.getValue("level")}</div>,
			maxSize: 50,
		},
		{
			accessorKey: "content_plain_text",
			header: "Content",
			cell: ({ row }) => (
				<ContentDisplay
					content={row.getValue("content_plain_text")}
					maxWidth="max-w-xs"
					placeholder="No content"
				/>
			),
		},
		{
			accessorKey: "tags",
			header: "Tags",
			filterFn: (row, columnId, value) => {
				if (!value) return true;
				const tags = row.getValue(columnId) as string[];
				return (
					tags?.some((tag) =>
						tag.toLowerCase().includes(value.toLowerCase()),
					) ?? false
				);
			},
			cell: ({ row }) => <TagsDisplay tags={row.getValue("tags")} />,
		},
		{
			accessorKey: "created_at",
			header: ({ column }) => (
				<SortableHeader column={column}>Created</SortableHeader>
			),
			cell: ({ row }) => <DateDisplay date={row.getValue("created_at")} />,
		},
		{
			id: "actions",
			maxSize: 60,
			enableHiding: false,
			cell: ({ row }) => {
				const character = row.original;
				const deleteCharacter = useDeleteCharacterMutation(gameId);
				const [editModalOpen, setEditModalOpen] = React.useState(false);

				return (
					<>
						<ActionsDropdown
							entityType="character"
							entityName="character"
							entity={character}
							gameId={gameId}
							onDelete={() => {
								deleteCharacter.mutate({
									path: { id: character.id, game_id: gameId },
								});
							}}
							onEdit={() => setEditModalOpen(true)}
						/>
						<EditCharacterDialog
							isOpen={editModalOpen}
							setIsOpen={setEditModalOpen}
							character={character}
						/>
					</>
				);
			},
		},
	];
}

export function CharacterTable({
	data,
	searchQuery,
	onSearchChange,
	tagFilter,
	onTagFilterChange,
	gameId,
}: CharacterTableProps) {
	const columns = createCharacterColumns(gameId);

	return (
		<EntityTable
			columns={columns}
			data={data}
			searchQuery={searchQuery}
			onSearchChange={onSearchChange}
			tagFilter={tagFilter}
			onTagFilterChange={onTagFilterChange}
			entityName="character"
			searchPlaceholder="Filter names..."
			tagPlaceholder="Filter tags..."
		/>
	);
}
</file>

<file path="src/components/factions/factions-table.tsx">
import type { ColumnDef } from "@tanstack/react-table";
import * as React from "react";

import type { Faction } from "~/api/types.gen";
import {
	ActionsDropdown,
	DateDisplay,
	EntityLink,
	EntityTable,
	SortableHeader,
	TagsDisplay,
} from "~/components/ui/entity-table";
import { useDeleteFactionMutation } from "~/queries/factions";
import { EditFactionDialog } from "./edit-faction-dialog";

interface FactionsTableProps {
	data: Faction[];
	searchQuery: string;
	onSearchChange: (query: string) => void;
	tagFilter: string;
	onTagFilterChange: (tag: string) => void;
	gameId: string;
}

function createFactionColumns(gameId: string): ColumnDef<Faction>[] {
	return [
		{
			accessorKey: "name",
			header: ({ column }) => <SortableHeader column={column}>Name</SortableHeader>,
			cell: ({ row }) => (
				<EntityLink
					entityType="faction"
					gameId={gameId}
					entityId={row.original.id}
					name={row.getValue("name")}
				/>
			),
		},
		{
			accessorKey: "tags",
			header: "Tags",
			filterFn: (row, columnId, value) => {
				if (!value) return true;
				const tags = row.getValue(columnId) as string[];
				return (
					tags?.some((tag) =>
						tag.toLowerCase().includes(value.toLowerCase()),
					) ?? false
				);
			},
			cell: ({ row }) => <TagsDisplay tags={row.getValue("tags")} />,
		},
		{
			accessorKey: "created_at",
			header: ({ column }) => (
				<SortableHeader column={column}>Created</SortableHeader>
			),
			cell: ({ row }) => <DateDisplay date={row.getValue("created_at")} />,
		},
		{
			id: "actions",
			enableHiding: false,
			maxSize: 80,
			cell: ({ row }) => {
				const faction = row.original;
				const deleteFaction = useDeleteFactionMutation(gameId);
				const [editDialogOpen, setEditDialogOpen] = React.useState(false);

				return (
					<>
						<ActionsDropdown
							entityType="faction"
							entityName="faction"
							entity={faction}
							gameId={gameId}
							onEdit={() => setEditDialogOpen(true)}
							onDelete={() => {
								deleteFaction.mutate({
									path: { game_id: gameId, id: faction.id },
								});
							}}
						/>
						<EditFactionDialog
							isOpen={editDialogOpen}
							setIsOpen={setEditDialogOpen}
							faction={faction}
						/>
					</>
				);
			},
		},
	];
}

export function FactionsTable({
	data,
	searchQuery,
	onSearchChange,
	tagFilter,
	onTagFilterChange,
	gameId,
}: FactionsTableProps) {
	const columns = createFactionColumns(gameId);

	return (
		<EntityTable
			columns={columns}
			data={data}
			searchQuery={searchQuery}
			onSearchChange={onSearchChange}
			tagFilter={tagFilter}
			onTagFilterChange={onTagFilterChange}
			entityName="faction"
			searchPlaceholder="Filter names..."
			tagPlaceholder="Filter tags..."
		/>
	);
}
</file>

<file path="src/components/forms/factory-v2.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: factory component */

import type { UseMutationOptions } from "@tanstack/react-query";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { CheckCircle, XCircle } from "lucide-react";
import type * as React from "react";
import { z } from "zod";
import type { TDataShape } from "~/api/client/types.gen";
import type { Options } from "~/api/sdk.gen";
import { Button } from "~/components/ui/button";
import { Checkbox } from "~/components/ui/checkbox";
import { TagInput } from "~/components/ui/composite/tag-input";
import { createFormHook } from "~/components/ui/form-tanstack";
import { Input } from "~/components/ui/input";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectPositioner,
	SelectTrigger,
	SelectValue,
} from "~/components/ui/select";
import { Textarea } from "~/components/ui/textarea";
import { Tiptap } from "../ui/editor";

// Create form hook outside component
const { useAppForm } = createFormHook();

// ===================================
// TYPES
// ===================================

export interface FormFactoryOptions<
	TData,
	TError,
	TMutationData extends TDataShape,
	TFormData = Record<string, any>,
> {
	mutationOptions: () => UseMutationOptions<TData, TError, Options<TMutationData>>;
	schema: z.ZodSchema<TFormData>;
	fields: FieldConfig[];
	onSuccess?: (data: TData) => void;
	defaultValues?: Partial<TFormData>;
	className?: string;
	entityName?: string;
}

export interface FieldConfig {
	name: string;
	label: string;
	type:
		| "text"
		| "number"
		| "textarea"
		| "editor"
		| "select"
		| "checkbox"
		| "email"
		| "password"
		| "date"
		| "tags";
	placeholder?: string;
	required?: boolean;
	options?: { value: string; label: string }[];
	description?: string;
	disabled?: boolean;
	className?: string;
	validation?: {
		min?: number;
		max?: number;
		minLength?: number;
		maxLength?: number;
		pattern?: RegExp;
	};
}

// Error interface for better type safety
export interface ApiError {
	message: string;
	fields?: Record<string, string[]>;
	code?: string;
}

// ===================================
// COMPONENTS
// ===================================

// Extract field control outside component to prevent recreation on each render
export const FormFieldControl: React.FC<{ field: FieldConfig; fieldApi: any }> = ({
	field,
	fieldApi,
}) => {
	const hasErrors = fieldApi.state?.meta?.errors?.length > 0;

	const commonProps = {
		name: fieldApi.name,
		value: fieldApi.state?.value ?? "",
		onBlur: fieldApi.handleBlur,
		disabled: field.disabled,
		required: field.required,
		"aria-invalid": hasErrors,
		className: field.className,
	};

	switch (field.type) {
		case "textarea":
			return (
				<Textarea
					{...commonProps}
					placeholder={field.placeholder}
					onChange={(e) => fieldApi.handleChange(e.target.value)}
					rows={4}
				/>
			);

		case "editor":
			return (
				<Tiptap
					content={fieldApi.state?.value ?? null}
					onChange={fieldApi.handleChange}
					placeholder={field.placeholder}
					editable={!field.disabled}
					className={field.className}
				/>
			);

		case "select":
			return (
				<Select
					value={fieldApi.state?.value ?? ""}
					onValueChange={(value) => {
						fieldApi.handleChange(value);
					}}
					disabled={field.disabled}
					required={field.required}
				>
					<SelectTrigger className="w-full" aria-invalid={hasErrors}>
						<SelectValue
							placeholder={field.placeholder || `Select ${field.label}`}
						/>
					</SelectTrigger>
					<SelectPositioner>
						<SelectContent>
							{field.options?.map((option) => (
								<SelectItem key={option.value} value={option.value}>
									{option.label}
								</SelectItem>
							))}
						</SelectContent>
					</SelectPositioner>
				</Select>
			);

		case "checkbox":
			return (
				<Checkbox
					checked={fieldApi.state?.value ?? false}
					onCheckedChange={(checked) => fieldApi.handleChange(checked)}
					disabled={field.disabled}
					required={field.required}
					aria-invalid={hasErrors}
				/>
			);

		case "number":
			return (
				<Input
					{...commonProps}
					type="number"
					placeholder={field.placeholder}
					onChange={(e) => {
						const value = e.target.value;
						if (value === "") {
							fieldApi.handleChange(undefined);
						} else {
							const numValue = e.target.valueAsNumber;
							if (!Number.isNaN(numValue)) {
								fieldApi.handleChange(numValue);
							}
							// For invalid input, don't update the form value yet
						}
					}}
					min={field.validation?.min}
					max={field.validation?.max}
				/>
			);

		case "date":
			return (
				<Input
					{...commonProps}
					type="date"
					onChange={(e) => fieldApi.handleChange(e.target.value)}
				/>
			);

		case "tags":
			return (
				<TagInput
					value={fieldApi.state?.value ?? []}
					onChange={fieldApi.handleChange}
					placeholder={field.placeholder}
					disabled={field.disabled}
				/>
			);

		default:
			return (
				<Input
					{...commonProps}
					type={field.type}
					placeholder={field.placeholder}
					onChange={(e) => fieldApi.handleChange(e.target.value)}
					minLength={field.validation?.minLength}
					maxLength={field.validation?.maxLength}
					pattern={field.validation?.pattern?.source}
				/>
			);
	}
};

// ===================================
// FACTORIES
// ===================================

export function createFormComponent<
	TData,
	TError,
	TMutationData extends TDataShape,
	TFormData = Record<string, any>,
>({
	mutationOptions,
	schema,
	fields,
	onSuccess,
	defaultValues = {},
	className = "space-y-6",
	entityName = "game",
}: FormFactoryOptions<TData, TError, TMutationData, TFormData>) {
	return function FormComponent() {
		const queryClient = useQueryClient();

		const mutationInstance = useMutation({
			...mutationOptions(),
			onSuccess: (data) => {
				queryClient.invalidateQueries();
				onSuccess?.(data);
			},
		});

		const form = useAppForm({
			defaultValues,
			onSubmit: async ({ value }) => {
				try {
					const validatedData = schema.parse(value);
					const fullData = {
						body: { [entityName]: validatedData },
					} as unknown as Options<TMutationData>;

					await mutationInstance.mutateAsync(fullData);
				} catch (error) {
					if (error instanceof z.ZodError) {
						console.error("Validation error:", error.issues);
						// Set field-specific validation errors
						error.issues.forEach((issue) => {
							if (issue.path.length > 0) {
								const fieldName = issue.path[0] as string;
								form.setFieldMeta(fieldName, (prev) => ({
									...prev,
									errors: [issue.message],
								}));
							}
						});
					}

					// Handle API field errors
					const apiError = error as ApiError;
					if (apiError.fields) {
						Object.entries(apiError.fields).forEach(
							([fieldName, messages]) => {
								form.setFieldMeta(fieldName, (prev) => ({
									...prev,
									errors: messages,
								}));
							},
						);
					}
					throw error;
				}
			},
		});

		return (
			<div className={className}>
				<form.AppForm>
					<form
						onSubmit={(e) => {
							e.preventDefault();
							form.handleSubmit();
						}}
					>
						{fields.map((fieldConfig) => (
							<form.AppField
								key={fieldConfig.name}
								name={fieldConfig.name}
								validators={{
									onChange: ({ value }) => {
										if (fieldConfig.required && !value) {
											return `${fieldConfig.label} is required`;
										}
										return undefined;
									},
								}}
							>
								{(field) => (
									<form.Item>
										<field.Label>
											{fieldConfig.label}
											{fieldConfig.required && (
												<span className="text-destructive ml-1">
													*
												</span>
											)}
										</field.Label>

										<field.Control>
											<FormFieldControl
												field={fieldConfig}
												fieldApi={field}
											/>
										</field.Control>

										{fieldConfig.description && (
											<field.Description>
												{fieldConfig.description}
											</field.Description>
										)}

										<field.Message />
									</form.Item>
								)}
							</form.AppField>
						))}

						<div className="flex gap-2">
							<Button type="submit" disabled={mutationInstance.isPending}>
								{mutationInstance.isPending ? "Submitting..." : "Submit"}
							</Button>

							<Button
								type="button"
								variant="outline"
								onClick={() => {
									if (
										form.state.isDirty &&
										!confirm(
											"Are you sure? All unsaved changes will be lost.",
										)
									) {
										return;
									}
									form.reset();
								}}
							>
								Reset
							</Button>
						</div>
					</form>
				</form.AppForm>

				{mutationInstance.isSuccess && (
					<div className="mt-4 bg-green-50 dark:bg-green-950/50 border border-green-200 dark:border-green-800 text-green-700 dark:text-green-300 px-4 py-3 rounded-md">
						<div className="flex items-center">
							<div className="flex-shrink-0">
								<CheckCircle className="h-5 w-5 text-green-600 dark:text-green-400" />
							</div>
							<div className="ml-3">
								<p className="text-sm font-medium">Success!</p>
								<p className="text-sm">
									{entityName} saved successfully!
								</p>
							</div>
						</div>
					</div>
				)}

				{mutationInstance.isError && (
					<div className="mt-4 bg-destructive/10 border border-destructive/20 text-destructive px-4 py-3 rounded-md">
						<div className="flex items-center">
							<div className="flex-shrink-0">
								<XCircle className="h-5 w-5 text-destructive" />
							</div>
							<div className="ml-3">
								<p className="text-sm font-medium">Error</p>
								<p className="text-sm">
									{(mutationInstance.error as ApiError)?.message ||
										"Something went wrong"}
								</p>
							</div>
						</div>
					</div>
				)}
			</div>
		);
	};
}

export function useFormWithMutation<
	TData,
	TError,
	TMutationData extends TDataShape,
	TFormData = Record<string, any>,
>({
	mutationOptions,
	schema,
	onSuccess,
	defaultValues = {},
	entityName = "game",
}: {
	mutationOptions: () => UseMutationOptions<TData, TError, Options<TMutationData>>;
	schema: z.ZodSchema<TFormData>;
	onSuccess?: (data: TData) => void;
	defaultValues?: Partial<TFormData>;
	entityName?: string;
}) {
	const queryClient = useQueryClient();

	const mutation = useMutation({
		...mutationOptions(),
		onSuccess: (data) => {
			queryClient.invalidateQueries();
			onSuccess?.(data);
		},
	});

	const form = useAppForm({
		defaultValues,
		onSubmit: async ({ value }) => {
			try {
				const validatedData = schema.parse(value);
				const fullData = {
					body: { [entityName]: validatedData },
				} as unknown as Options<TMutationData>;

				await mutation.mutateAsync(fullData);
			} catch (error) {
				if (error instanceof z.ZodError) {
					console.error("Validation error:", error.issues);
					// Set field-specific validation errors
					error.issues.forEach((issue) => {
						if (issue.path.length > 0) {
							const fieldName = issue.path[0] as string;
							form.setFieldMeta(fieldName, (prev) => ({
								...prev,
								errors: [issue.message],
							}));
						}
					});
				}

				// Handle API field errors
				const apiError = error as ApiError;
				if (apiError.fields) {
					Object.entries(apiError.fields).forEach(([fieldName, messages]) => {
						form.setFieldMeta(fieldName, (prev) => ({
							...prev,
							errors: messages,
						}));
					});
				}
				throw error;
			}
		},
	});

	return {
		form,
		mutation,
		// Helper to render form fields with proper UI components
		renderField: (fieldConfig: FieldConfig) => (
			<form.AppField
				key={fieldConfig.name}
				name={fieldConfig.name}
				validators={{
					onChange: ({ value }) => {
						if (fieldConfig.required && !value) {
							return `${fieldConfig.label} is required`;
						}
						return undefined;
					},
				}}
			>
				{(field) => (
					<form.Item>
						<field.Label>
							{fieldConfig.label}
							{fieldConfig.required && (
								<span className="text-destructive ml-1">*</span>
							)}
						</field.Label>

						<field.Control>
							<FormFieldControl field={fieldConfig} fieldApi={field} />
						</field.Control>

						{fieldConfig.description && (
							<field.Description>
								{fieldConfig.description}
							</field.Description>
						)}

						<field.Message />
					</form.Item>
				)}
			</form.AppField>
		),
	};
}

// ===================================
// EXPORTS
// ===================================

// Export the form hook for direct usage
export { useAppForm };
</file>

<file path="src/components/forms/type-utils.ts">
/** biome-ignore-all lint/suspicious/noExplicitAny: Zod internal types */
import { z } from "zod";
import type { FieldConfig } from "./factory-v2";

/**
 * Extract default values from a Zod schema
 */
export function extractDefaultValues<T extends z.ZodRawShape>(
	schema: z.ZodObject<T>,
): Partial<z.infer<typeof schema>> {
	const defaults: Record<string, unknown> = {};

	for (const [key, zodType] of Object.entries(schema.shape)) {
		const def = (zodType as { _def?: { defaultValue?: unknown } })._def;

		if (def?.defaultValue !== undefined) {
			defaults[key] =
				typeof def.defaultValue === "function"
					? def.defaultValue()
					: def.defaultValue;
		} else if (!(zodType instanceof z.ZodOptional)) {
			// Infer sensible defaults based on type (skip optional fields)
			if (zodType instanceof z.ZodString) {
				defaults[key] = "";
			} else if (zodType instanceof z.ZodNumber) {
				defaults[key] =
					(
						def as { checks?: Array<{ kind: string; value: number }> }
					)?.checks?.find((c) => c.kind === "min")?.value ?? 0;
			} else if (zodType instanceof z.ZodBoolean) {
				defaults[key] = false;
			} else if (zodType instanceof z.ZodArray) {
				defaults[key] = [];
			} else if (zodType instanceof z.ZodEnum) {
				// For enum fields (selects), default to empty string to maintain controlled state
				defaults[key] = "";
			}
		}
	}

	return defaults as Partial<z.infer<typeof schema>>;
}

/**
 * Generate field configurations from a Zod schema with smart type detection
 */
export function generateFieldsFromSchema<T extends z.ZodRawShape>(
	schema: z.ZodObject<T>,
	overrides: Partial<Record<keyof T, Partial<FieldConfig> | null>> = {},
): FieldConfig[] {
	const fields: FieldConfig[] = [];

	for (const [key, zodType] of Object.entries(schema.shape)) {
		const fieldName = key as keyof T;
		
		// Skip field if override is null (excludes the field)
		if (overrides[fieldName] === null) {
			continue;
		}

		const field: FieldConfig = {
			name: key,
			label: titleCase(key),
			type: "text",
			required: !(zodType instanceof z.ZodOptional),
			...overrides[fieldName],
		};

		// Detect field type from Zod type
		const actualType =
			zodType instanceof z.ZodOptional ? (zodType as any)._def.innerType : zodType;

		if (actualType instanceof z.ZodString) {
			const checks = (actualType as any)._def?.checks || [];

			// Check for email
			if (checks.some((c: { kind: string }) => c.kind === "email")) {
				field.type = "email";
			}
			// Check for URL
			else if (checks.some((c: { kind: string }) => c.kind === "url")) {
				field.type = "text";
				field.placeholder = "https://example.com";
			}
			// Check for rich text editor fields (complex content)
			else if (
				key.includes("content") ||
				key.includes("description") ||
				key.includes("notes") ||
				key.includes("body") ||
				key.includes("message")
			) {
				field.type = "editor";
			}
			// Check for password fields
			else if (key.includes("password")) {
				field.type = "password";
			}

			// Add string validation
			const minCheck = checks.find(
				(c: { kind: string; value?: number }) => c.kind === "min",
			);
			const maxCheck = checks.find(
				(c: { kind: string; value?: number }) => c.kind === "max",
			);
			if (minCheck || maxCheck) {
				field.validation = {
					minLength: minCheck?.value,
					maxLength: maxCheck?.value,
				};
			}
		} else if (actualType instanceof z.ZodNumber) {
			field.type = "number";

			const checks = (actualType as any)._def?.checks || [];
			const minCheck = checks.find(
				(c: { kind: string; value?: number }) => c.kind === "min",
			);
			const maxCheck = checks.find(
				(c: { kind: string; value?: number }) => c.kind === "max",
			);

			if (minCheck || maxCheck) {
				field.validation = {
					min: minCheck?.value,
					max: maxCheck?.value,
				};
			}
		} else if (actualType instanceof z.ZodBoolean) {
			field.type = "checkbox";
		} else if (actualType instanceof z.ZodEnum) {
			field.type = "select";
			const enumValues = actualType.options || [];
			field.options = enumValues.map((value) => ({
				value: String(value),
				label: titleCase(String(value)),
			}));
		} else if (actualType instanceof z.ZodDate) {
			field.type = "date";
		} else if (actualType instanceof z.ZodArray) {
			// Check if it's an array of strings, likely for tags
			const elementType = (actualType as any)._def?.element;
			if (elementType instanceof z.ZodString) {
				field.type = "tags";
			}
		}

		fields.push(field);
	}

	return fields;
}

/**
 * Convert snake_case or camelCase to Title Case
 */
function titleCase(str: string): string {
	return str
		.replace(/([a-z])([A-Z])/g, "$1 $2") // camelCase to spaces
		.replace(/[_-]/g, " ") // snake_case or kebab-case to spaces
		.replace(/\b\w/g, (char) => char.toUpperCase()) // capitalize words
		.trim();
}

/**
 * Create a Zod schema from TypeScript types (manual helper for now)
 * In the future, this could be generated from OpenAPI
 */
export function createSchemaFor() {
	return {
		character: z.object({
			name: z.string().min(1, "Character name is required"),
			class: z.string().min(1, "Character class is required"),
			level: z.coerce
				.number()
				.min(1, "Level must be at least 1")
				.max(100, "Level cannot exceed 100"),
			image_url: z.union([z.url(), z.literal("")]).optional(),
			tags: z.array(z.string()).optional(),
			content: z.string().optional(),
		}),

		faction: z.object({
			name: z.string().min(1, "Faction name is required"),
			tags: z.array(z.string()).optional(),
			content: z.string(),
		}),

		// Add more schemas as needed
		game: z.object({
			name: z.string().min(1, "Game name is required"),
			setting: z.string().optional(),
			content: z.string().optional(),
		}),

		note: z.object({
			name: z.string().min(1, "Note name is required"),
			tags: z.array(z.string()).optional(),
			parent_id: z.string().optional(),
			parent_type: z
				.enum(["note", "quest", "location", "character", "faction"])
				.optional(),
			content: z.string().min(1, "Note content is required"),
		}),

		quest: z.object({
			name: z.string().min(1, "Quest name is required"),
			parent_id: z.string().optional(),
			tags: z.array(z.string()).optional(),
			content: z.string().min(1, "Quest content is required"),
		}),

		location: z.object({
			name: z.string().min(1, "Location name is required"),
			type: z.enum([
				"continent",
				"nation",
				"region",
				"city",
				"settlement",
				"building",
				"complex",
			]),
			parent_id: z.string().optional(),
			tags: z.array(z.string()).optional(),
			content: z.string().optional(),
		}),
	};
}

export const schemas = createSchemaFor();
</file>

<file path="src/components/layout/game-sidebar.tsx">
import { useParams } from "@tanstack/react-router";
import {
	BookOpen,
	Gem,
	Globe,
	Home,
	MapPin,
	Moon,
	Network,
	Plus,
	Scroll,
	Sun,
	Users,
} from "lucide-react";
import { useTheme } from "next-themes";
import * as React from "react";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
	Sidebar,
	SidebarContent,
	SidebarGroup,
	SidebarGroupContent,
	SidebarGroupLabel,
	SidebarHeader,
	SidebarMenu,
	SidebarMenuButton,
	SidebarMenuItem,
	SidebarMenuLink,
} from "~/components/ui/sidebar";
import { useGetGameLinksSuspenseQuery } from "~/queries/games";
import { useGetLocationTreeSuspenseQuery } from "~/queries/locations";
import {
	useGetQuestTreeSuspenseQuery,
	useListPinnedEntitiesSuspenseQuery,
} from "~/queries/quests";
import { SidebarTree } from "./tree";
import { NavUser } from "./user-sidebar";

interface GameSidebarProps {
	setNewCharSheetOpen: (isOpen: boolean) => void;
	setNewFactionSheetOpen: (isOpen: boolean) => void;
	setNewLocationSheetOpen: (isOpen: boolean) => void;
	setNewNoteSheetOpen: (isOpen: boolean) => void;
	setNewQuestSheetOpen: (isOpen: boolean) => void;
}

export function GameSidebar({
	setNewCharSheetOpen,
	setNewFactionSheetOpen,
	setNewLocationSheetOpen,
	setNewNoteSheetOpen,
	setNewQuestSheetOpen,
}: GameSidebarProps) {
	const { theme, setTheme } = useTheme();
	const [mounted, setMounted] = React.useState(false);

	const params = useParams({ from: "/_auth/games/$gameId" });
	const gameId = params.gameId;

	// TODO: This needs to be cleaned up, and probably extracted to a hook / function
	const { data: links } = useGetGameLinksSuspenseQuery({ id: gameId });
	const characters = resolveEntityArray(links?.data?.entities?.characters);
	const factions = resolveEntityArray(links?.data?.entities?.factions);
	const locations = resolveEntityArray(links?.data?.entities?.locations);
	const notes = resolveEntityArray(links?.data?.entities?.notes);
	const quests = resolveEntityArray(links?.data?.entities?.quests);

	const { data: locationTree } = useGetLocationTreeSuspenseQuery(gameId);
	const { data: questTree } = useGetQuestTreeSuspenseQuery(gameId);
	const { data: pinnedEntities } = useListPinnedEntitiesSuspenseQuery(gameId);

	React.useEffect(() => {
		setMounted(true);
	}, []);

	const totalEntityCount =
		(characters?.length || 0) +
		(factions?.length || 0) +
		(locations?.length || 0) +
		(notes?.length || 0) +
		(quests?.length || 0);

	return (
		<Sidebar>
			<SidebarHeader className="border-b p-4">
				<div className="flex items-center justify-between">
					<div className="flex items-center gap-2">
						<BookOpen className="w-6 h-6" />
						<span className="font-bold">DM Editor</span>
					</div>
					<Button
						variant="ghost"
						size="icon"
						onClick={() => setTheme(theme === "dark" ? "light" : "dark")}
					>
						{mounted ? (
							theme === "dark" ? (
								<Sun className="w-4 h-4" />
							) : (
								<Moon className="w-4 h-4" />
							)
						) : (
							<div className="w-4 h-4" />
						)}
					</Button>
				</div>
			</SidebarHeader>
			<SidebarContent className="p-4 flex flex-col">
				<SidebarMenu>
					<SidebarMenuItem>
						<SidebarMenuLink to="/games/$gameId" params={params}>
							<Home className="w-4 h-4" />
							Dashboard
						</SidebarMenuLink>
					</SidebarMenuItem>
					<SidebarMenuItem>
						<SidebarMenuButton>
							<Network className="w-4 h-4" />
							Relationship Graph
						</SidebarMenuButton>
					</SidebarMenuItem>
				</SidebarMenu>
				<div className="mt-6">
					<div className="flex items-center justify-between mb-3">
						<h3 className="text-sm font-semibold text-muted-foreground uppercase tracking-wide">
							Entities
						</h3>
					</div>

					<SidebarMenu>
						<SidebarMenuItem>
							<SidebarMenuLink
								to={"/games/$gameId/all"}
								params={params}
								activeProps={{
									className: "bg-secondary text-secondary-foreground",
								}}
							>
								<Globe className="w-4 h-4" />
								All
								<Badge variant="secondary" className="ml-auto">
									{totalEntityCount.toString()}
								</Badge>
							</SidebarMenuLink>
						</SidebarMenuItem>
						<SidebarMenuItem>
							<SidebarMenuLink
								to="/games/$gameId/characters"
								params={params}
								activeProps={{
									className: "bg-secondary text-secondary-foreground",
								}}
							>
								<Users className="w-4 h-4" />
								Characters
								<Badge variant="secondary" className="ml-auto">
									{characters?.length.toString() || "0"}
								</Badge>
							</SidebarMenuLink>
						</SidebarMenuItem>

						<SidebarMenuItem>
							<SidebarMenuLink
								to="/games/$gameId/factions"
								params={params}
								activeProps={{
									className: "bg-secondary text-secondary-foreground",
								}}
							>
								<div className="w-4 h-4 flex items-center justify-center text-sm">
									‚öî
								</div>
								Factions
								<Badge variant="secondary" className="ml-auto">
									{factions?.length.toString() || "0"}
								</Badge>
							</SidebarMenuLink>
						</SidebarMenuItem>

						<SidebarMenuLink
							to="/games/$gameId/locations"
							params={params}
							activeProps={{
								className: "bg-secondary text-secondary-foreground",
							}}
						>
							<MapPin className="w-4 h-4" />
							Locations
							<Badge variant="secondary" className="ml-auto">
								{locations?.length.toString() || "0"}
							</Badge>
						</SidebarMenuLink>
						<SidebarMenuItem>
							<SidebarMenuLink
								to="/games/$gameId/quests"
								params={params}
								activeProps={{
									className: "bg-secondary text-secondary-foreground",
								}}
							>
								<Gem className="w-4 h-4" />
								Quests
								<Badge variant="secondary" className="ml-auto">
									{quests?.length.toString() || "0"}
								</Badge>
							</SidebarMenuLink>
						</SidebarMenuItem>

						<SidebarMenuItem>
							<SidebarMenuLink
								to="/games/$gameId/notes"
								params={params}
								activeProps={{
									className: "bg-secondary text-secondary-foreground",
								}}
							>
								<Scroll className="w-4 h-4" />
								Notes
								<Badge variant="secondary" className="ml-auto">
									{notes?.length.toString() || "0"}
								</Badge>
							</SidebarMenuLink>
						</SidebarMenuItem>
					</SidebarMenu>

					<SidebarGroup>
						<SidebarGroupLabel>Locations</SidebarGroupLabel>
						<SidebarGroupContent>
							<SidebarMenu>
								{locationTree?.data?.map((item) => (
									<SidebarTree
										gameId={gameId}
										key={item.id}
										parentNode={item}
									/>
								))}
							</SidebarMenu>
						</SidebarGroupContent>
					</SidebarGroup>
					<SidebarGroup>
						<SidebarGroupLabel>Quests</SidebarGroupLabel>
						<SidebarGroupContent>
							<SidebarMenu>
								{questTree?.data?.map((item) => (
									<SidebarTree
										gameId={gameId}
										key={item.id}
										parentNode={item}
									/>
								))}
							</SidebarMenu>
						</SidebarGroupContent>
					</SidebarGroup>

					<SidebarGroup>
						<SidebarGroupLabel>Pinned Entities</SidebarGroupLabel>
						<SidebarGroupContent>
							<SidebarMenu>
								{pinnedEntities.data?.pinned_entities.notes?.map(
									(item) => (
										<SidebarMenuLink
											to={"/games/$gameId/notes/$id"}
											params={{ gameId, id: item.id }}
											key={item.id}
										>
											{item.name}
										</SidebarMenuLink>
									),
								)}
								{pinnedEntities.data?.pinned_entities.characters?.map(
									(item) => (
										<SidebarMenuLink
											to={"/games/$gameId/characters/$id"}
											params={{ gameId, id: item.id }}
											key={item.id}
										>
											{item.name}
										</SidebarMenuLink>
									),
								)}
							</SidebarMenu>
						</SidebarGroupContent>
					</SidebarGroup>

					<div className="mt-4 space-y-2">
						<Button
							onClick={() => setNewNoteSheetOpen(true)}
							size="sm"
							variant="outline"
							className="w-full justify-start"
						>
							<Plus className="w-4 h-4 mr-2" />
							New Note
						</Button>
						<Button
							onClick={() => setNewCharSheetOpen(true)}
							size="sm"
							variant="outline"
							className="w-full justify-start"
						>
							<Plus className="w-4 h-4 mr-2" />
							New Character
						</Button>
						<Button
							onClick={() => setNewFactionSheetOpen(true)}
							size="sm"
							variant="outline"
							className="w-full justify-start"
						>
							<Plus className="w-4 h-4 mr-2" />
							New Faction
						</Button>
						<Button
							onClick={() => setNewLocationSheetOpen(true)}
							size="sm"
							variant="outline"
							className="w-full justify-start"
						>
							<Plus className="w-4 h-4 mr-2" />
							New Location
						</Button>
						<Button
							onClick={() => setNewQuestSheetOpen(true)}
							size="sm"
							variant="outline"
							className="w-full justify-start"
						>
							<Plus className="w-4 h-4 mr-2" />
							New Quest
						</Button>
					</div>
				</div>
				<div className="flex-1" />
				<SidebarMenu>
					<SidebarMenuItem>
						<NavUser
							user={{
								name: "Callum",
								email: "callum@example.com",
								avatar: "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fimages-wixmp-ed30a86b8c4ca887773594c2.wixmp.com%2Ff%2Fc3f6f733-7289-4186-bc20-1a811747f37f%2Fdj8mxhn-ad79f500-0b82-4a44-9545-b7b3c345971f.jpg%2Fv1%2Ffill%2Fw_894%2Ch_894%2Cq_70%2Cstrp%2Fbilbo_baggins_in_the_civil_war_by_houndhobbit_dj8mxhn-pre.jpg%3Ftoken%3DeyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTAyNCIsInBhdGgiOiJcL2ZcL2MzZjZmNzMzLTcyODktNDE4Ni1iYzIwLTFhODExNzQ3ZjM3ZlwvZGo4bXhobi1hZDc5ZjUwMC0wYjgyLTRhNDQtOTU0NS1iN2IzYzM0NTk3MWYuanBnIiwid2lkdGgiOiI8PTEwMjQifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.daP_x5eECE26Uo4ui9uvt-de5gOkOQbwAj0W3oxvj7c&f=1&nofb=1&ipt=e47750affbcaf6d843dee0e65f5a2f9499b02d76adc2352d92c0c6c02c21b495",
							}}
						/>
					</SidebarMenuItem>
				</SidebarMenu>
			</SidebarContent>
		</Sidebar>
	);
}

function resolveEntityArray<T>(entityArray: T[] | undefined): T[] {
	if (!entityArray) {
		return [];
	}

	return entityArray;
}
</file>

<file path="src/components/links/index.ts">
export { CreateLinkForm } from "./create-link";
export { useCreateLink } from "./hooks/useCreateLink";
export { useGameEntities } from "./hooks/useGameEntities";
export type { EntityOption } from "./types";
</file>

<file path="src/components/links/types.ts">
import type { LinkRequest } from "~/api/types.gen";
import type { EntityType } from "~/types";

export interface EntityOption {
	label: string;
	value: string;
	type: EntityType;
}

export interface CreateLinkParams extends LinkRequest {
	gameId: string;
	sourceType: EntityType;
	sourceId: string;
}

export interface DeleteLinkParams {
	gameId: string;
	sourceType: EntityType;
	sourceId: string;
	targetType: EntityType;
	targetId: string;
}
</file>

<file path="src/components/locations/edit-location-form.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import type { LocationUpdateParams } from "~/api";
import {
	getLocationQueryKey,
	listLocationsQueryKey,
	updateLocationMutation,
} from "~/api/@tanstack/react-query.gen";
import { createSmartForm } from "../forms/smart-factory";
import { schemas } from "../forms/type-utils";

interface EditLocationFormProps {
	params: {
		gameId: string;
		id: string;
	};
	initialData?: Partial<LocationUpdateParams>;
}

export function EditLocationForm({ initialData, params }: EditLocationFormProps) {
	const { gameId, id } = params;
	const queryClient = useQueryClient();
	const navigate = useNavigate();

	const FormComponent = createSmartForm({
		mutation: () =>
			updateLocationMutation({
				path: {
					game_id: gameId,
					id: id,
				},
			}),
		onSuccess: async () => {
			toast("Location updated successfully!");
			queryClient.invalidateQueries({
				queryKey: listLocationsQueryKey({
					path: { game_id: gameId },
				}),
			});
			queryClient.invalidateQueries({
				queryKey: getLocationQueryKey({
					path: {
						game_id: gameId,
						id: id,
					},
				}),
			});
			navigate({ to: ".." });
		},
		schema: schemas.location,
		entityName: "location",
		initialValues: {
			...initialData,
			image_url: initialData?.image_url || undefined,
		},
		fieldOverrides: {
			content: null,
		},
	});

	return <FormComponent />;
}
</file>

<file path="src/components/locations/locations-table.tsx">
import type { ColumnDef } from "@tanstack/react-table";
import * as React from "react";

import type { Location } from "~/api/types.gen";
import {
	ActionsDropdown,
	DateDisplay,
	EntityLink,
	EntityTable,
	SortableHeader,
	TagsDisplay,
} from "~/components/ui/entity-table";
import { Badge } from "../ui/badge";
import { EditLocationDialog } from "./edit-location-dialog";

interface LocationsTableProps {
	data: Location[];
	searchQuery: string;
	onSearchChange: (query: string) => void;
	tagFilter: string;
	onTagFilterChange: (tag: string) => void;
	gameId: string;
}

function createLocationColumns(gameId: string): ColumnDef<Location>[] {
	return [
		{
			accessorKey: "name",
			header: ({ column }) => <SortableHeader column={column}>Name</SortableHeader>,
			cell: ({ row }) => (
				<EntityLink
					entityType="location"
					gameId={gameId}
					entityId={row.original.id}
					name={row.getValue("name")}
				/>
			),
		},
		{
			accessorKey: "type",
			header: "Type",
			cell: ({ row }) => (
				<Badge variant="secondary" className="capitalize">
					{row.getValue("type")}
				</Badge>
			),
		},
		{
			accessorKey: "tags",
			header: "Tags",
			filterFn: (row, columnId, value) => {
				if (!value) return true;
				const tags = row.getValue(columnId) as string[];
				return (
					tags?.some((tag) =>
						tag.toLowerCase().includes(value.toLowerCase()),
					) ?? false
				);
			},
			cell: ({ row }) => <TagsDisplay tags={row.getValue("tags")} />,
		},
		{
			accessorKey: "created_at",
			header: ({ column }) => (
				<SortableHeader column={column}>Created</SortableHeader>
			),
			cell: ({ row }) => <DateDisplay date={row.getValue("created_at")} />,
		},
		{
			id: "actions",
			maxSize: 80,
			enableHiding: false,
			cell: ({ row }) => {
				const location = row.original;
				const [editModalOpen, setEditModalOpen] = React.useState(false);

				return (
					<>
						<ActionsDropdown
							entityType="location"
							entityName="location"
							entity={location}
							gameId={gameId}
							onEdit={() => setEditModalOpen(true)}
							showDelete={false}
						/>
						<EditLocationDialog
							isOpen={editModalOpen}
							setIsOpen={setEditModalOpen}
							location={location}
						/>
					</>
				);
			},
		},
	];
}

export function LocationsTable({
	data,
	searchQuery,
	onSearchChange,
	tagFilter,
	onTagFilterChange,
	gameId,
}: LocationsTableProps) {
	const columns = createLocationColumns(gameId);

	return (
		<EntityTable
			columns={columns}
			data={data}
			searchQuery={searchQuery}
			onSearchChange={onSearchChange}
			tagFilter={tagFilter}
			onTagFilterChange={onTagFilterChange}
			entityName="location"
			searchPlaceholder="Filter names..."
			tagPlaceholder="Filter tags..."
		/>
	);
}
</file>

<file path="src/components/notes/notes-table.tsx">
import type { ColumnDef } from "@tanstack/react-table";
import * as React from "react";

import type { Note } from "~/api/types.gen";
import {
	ActionsDropdown,
	DateDisplay,
	EntityLink,
	EntityTable,
	SortableHeader,
	TagsDisplay,
} from "~/components/ui/entity-table";
import { EditNoteDialog } from "./edit-note-dialog";

interface NotesTableProps {
	data: Note[];
	searchQuery: string;
	onSearchChange: (query: string) => void;
	tagFilter: string;
	onTagFilterChange: (tag: string) => void;
	gameId: string;
}

function createNoteColumns(gameId: string): ColumnDef<Note>[] {
	return [
		{
			accessorKey: "name",
			header: ({ column }) => <SortableHeader column={column}>Name</SortableHeader>,
			cell: ({ row }) => (
				<EntityLink
					entityType="note"
					gameId={gameId}
					entityId={row.original.id}
					name={row.getValue("name")}
				/>
			),
		},
		{
			accessorKey: "tags",
			header: "Tags",
			filterFn: (row, columnId, value) => {
				if (!value) return true;
				const tags = row.getValue(columnId) as string[];
				return (
					tags?.some((tag) =>
						tag.toLowerCase().includes(value.toLowerCase()),
					) ?? false
				);
			},
			cell: ({ row }) => <TagsDisplay tags={row.getValue("tags")} />,
		},
		{
			accessorKey: "created_at",
			header: ({ column }) => (
				<SortableHeader column={column}>Created</SortableHeader>
			),
			cell: ({ row }) => <DateDisplay date={row.getValue("created_at")} />,
		},
		{
			id: "actions",
			maxSize: 60,
			enableHiding: false,
			cell: ({ row }) => {
				const note = row.original;
				const [editModalOpen, setEditModalOpen] = React.useState(false);

				return (
					<>
						<ActionsDropdown
							entityType="note"
							entityName="note"
							entity={note}
							gameId={gameId}
							onEdit={() => setEditModalOpen(true)}
							showDelete={false}
						/>
						<EditNoteDialog
							isOpen={editModalOpen}
							setIsOpen={setEditModalOpen}
							note={note}
						/>
					</>
				);
			},
		},
	];
}

export function NotesTable({
	data,
	searchQuery,
	onSearchChange,
	tagFilter,
	onTagFilterChange,
	gameId,
}: NotesTableProps) {
	const columns = createNoteColumns(gameId);

	return (
		<EntityTable
			columns={columns}
			data={data}
			searchQuery={searchQuery}
			onSearchChange={onSearchChange}
			tagFilter={tagFilter}
			onTagFilterChange={onTagFilterChange}
			entityName="note"
			searchPlaceholder="Filter names..."
			tagPlaceholder="Filter tags..."
		/>
	);
}
</file>

<file path="src/components/quests/quests-table.tsx">
import type { ColumnDef } from "@tanstack/react-table";
import * as React from "react";

import type { Quest } from "~/api/types.gen";
import {
	EntityTable,
	SortableHeader,
	EntityLink,
	TagsDisplay,
	DateDisplay,
	ContentDisplay,
	ActionsDropdown,
} from "~/components/ui/entity-table";
import { EditQuestDialog } from "./edit-quest-dialog";

interface QuestsTableProps {
	data: Quest[];
	searchQuery: string;
	onSearchChange: (query: string) => void;
	tagFilter: string;
	onTagFilterChange: (tag: string) => void;
	gameId: string;
}

function createQuestColumns(gameId: string): ColumnDef<Quest>[] {
	return [
		{
			accessorKey: "name",
			header: ({ column }) => <SortableHeader column={column}>Name</SortableHeader>,
			cell: ({ row }) => (
				<EntityLink
					entityType="quest"
					gameId={gameId}
					entityId={row.original.id}
					name={row.getValue("name")}
				/>
			),
		},
		{
			accessorKey: "content_plain_text",
			header: "Content",
			cell: ({ row }) => (
				<ContentDisplay
					content={row.getValue("content_plain_text")}
					maxWidth="max-w-[300px]"
					placeholder="No content"
				/>
			),
		},
		{
			accessorKey: "tags",
			header: "Tags",
			filterFn: (row, columnId, value) => {
				if (!value) return true;
				const tags = row.getValue(columnId) as string[];
				return (
					tags?.some((tag) =>
						tag.toLowerCase().includes(value.toLowerCase()),
					) ?? false
				);
			},
			cell: ({ row }) => <TagsDisplay tags={row.getValue("tags")} />,
		},
		{
			accessorKey: "created_at",
			header: ({ column }) => (
				<SortableHeader column={column}>Created</SortableHeader>
			),
			cell: ({ row }) => <DateDisplay date={row.getValue("created_at")} />,
		},
		{
			id: "actions",
			maxSize: 80,
			enableHiding: false,
			cell: ({ row }) => {
				const quest = row.original;
				const [editModalOpen, setEditModalOpen] = React.useState(false);

				return (
					<>
						<ActionsDropdown
							entityType="quest"
							entityName="quest"
							entity={quest}
							gameId={gameId}
							onEdit={() => setEditModalOpen(true)}
							showDelete={false}
						/>
						<EditQuestDialog
							isOpen={editModalOpen}
							setIsOpen={setEditModalOpen}
							quest={quest}
						/>
					</>
				);
			},
		},
	];
}

export function QuestsTable({
	data,
	searchQuery,
	onSearchChange,
	tagFilter,
	onTagFilterChange,
	gameId,
}: QuestsTableProps) {
	const columns = createQuestColumns(gameId);

	return (
		<EntityTable
			columns={columns}
			data={data}
			searchQuery={searchQuery}
			onSearchChange={onSearchChange}
			tagFilter={tagFilter}
			onTagFilterChange={onTagFilterChange}
			entityName="quest"
			searchPlaceholder="Filter names..."
			tagPlaceholder="Filter tags..."
		/>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/characters/$id/index.tsx">
import { useQuery } from "@tanstack/react-query";
import { createFileRoute, Navigate } from "@tanstack/react-router";
import { useMemo } from "react";
import type { Character } from "~/api";
import {
	getFactionOptions,
	listPinnedEntitiesQueryKey,
	useGetCharacterLinksQuery,
	useListFactionsQuery,
} from "~/api/@tanstack/react-query.gen";
import { CharacterNotesView } from "~/components/characters/character-note-view";
import { CreateCharacterLink } from "~/components/characters/create-character-link";
import { SelectFactionCombobox } from "~/components/characters/select-faction-combobox";
import { useAddTab } from "~/components/entity-tabs";
import { EntityView } from "~/components/entity-view";
import { Badge } from "~/components/ui/badge";
import { EntityEditor } from "~/components/ui/editor/entity-editor";
import { EntityLinksTable } from "~/components/ui/entity-links-table";
import {
	useGetCharacterSuspenseQuery,
	useUpdateCharacterMutation,
} from "~/queries/characters";
import { flattenLinksForTable, type GenericLinksResponse } from "~/utils/linkHelpers";

export const Route = createFileRoute("/_auth/games/$gameId/characters/$id/")({
	component: RouteComponent,
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data } = useGetCharacterSuspenseQuery(gameId, id);
	const character = data?.data;

	useAddTab({
		data: character,
		entityType: "characters",
		gameId,
	});

	if (!character) {
		return <Navigate to=".." />;
	}

	return <CharacterView character={character} gameId={gameId} />;
}

// MAIN VIEW COMPONENT

interface CharacterViewProps {
	character: Character;
	gameId: string;
}
function CharacterView({ character, gameId }: CharacterViewProps) {
	const {
		data: linksResponse,
		isLoading: linksLoading,
		isError: linksError,
		error: linksQueryError,
	} = useGetCharacterLinksQuery({
		path: { game_id: gameId, character_id: character.id },
	});

	const context = Route.useRouteContext();
	const updateCharacter = useUpdateCharacterMutation(gameId, character.id);

	const handleSave = async (payload: {
		content: string;
		content_plain_text: string;
	}) => {
		updateCharacter.mutateAsync({
			body: { character: payload },
			path: { game_id: gameId, id: character.id },
		});
	};

	// We also have pinCharacterMutation, but since the character mutation is already
	// being used, we can just use it for both actions.
	const handleTogglePin = async () => {
		updateCharacter.mutateAsync(
			{
				body: { character: { pinned: !character.pinned } },
				path: { game_id: gameId, id: character.id },
			},
			{
				onSuccess: () => {
					context.queryClient.invalidateQueries({
						queryKey: listPinnedEntitiesQueryKey({
							path: { game_id: gameId },
						}),
					});
				},
			},
		);
	};

	const badges = (
		<div className="flex flex-wrap gap-2">
			<Badge>{character.class}</Badge>
			<Badge>Level: {character.level}</Badge>
			{character.tags && character.tags.length > 0 && (
				<div className="flex flex-wrap gap-2">
					{character.tags.map((tag) => (
						<Badge key={tag} variant="secondary">
							{tag}
						</Badge>
					))}
				</div>
			)}
		</div>
	);

	const contentTab = (
		<EntityEditor
			content={character.content}
			gameId={gameId}
			entityType="character"
			entityId={character.id}
			onSave={handleSave}
			isSaving={updateCharacter.isPending}
		/>
	);

	const linksTab = (
		<div className="space-y-4">
			<CreateCharacterLink gameId={gameId} characterId={character.id} />
			{linksLoading && (
				<div className="text-muted-foreground">Loading links...</div>
			)}
			{linksError && (
				<div className="text-destructive">
					Error loading links: {linksQueryError?.message}
				</div>
			)}
			{!linksLoading && !linksError && linksResponse && (
				<EntityLinksTable
					links={flattenLinksForTable(linksResponse as GenericLinksResponse)}
					gameId={gameId}
					sourceType="character"
					sourceId={character.id}
				/>
			)}
		</div>
	);

	const tabs = [
		{
			id: "content",
			label: "Content",
			content: contentTab,
		},
		{
			id: "links",
			label: "Links",
			content: linksTab,
		},
		{
			id: "notes",
			label: "Notes",
			content: <CharacterNotesView gameId={gameId} characterId={character.id} />,
		},
		{
			id: "faction",
			label: "Faction",
			content: <CharacterFactionView gameId={gameId} characterId={character.id} />,
		},
	];

	const navigate = Route.useNavigate();

	return (
		<>
			<div>{character.member_of_faction_id || "no faction"}</div>
			<EntityView
				name={character.name}
				badges={badges}
				tabs={tabs}
				pinned={character.pinned}
				onEdit={() => navigate({ to: "edit" })}
				onTogglePin={handleTogglePin}
			/>
		</>
	);
}

interface CharacterFactionViewProps {
	gameId: string;
	characterId: string;
	primaryFactionId?: string;
}
function CharacterFactionView({
	gameId,
	characterId,
	primaryFactionId,
}: CharacterFactionViewProps) {
	// Fetch the primary faction if it exists
	const { data: factionData, isEnabled } = useQuery({
		...getFactionOptions({ path: { game_id: gameId, id: primaryFactionId! } }),
		enabled: !!primaryFactionId,
	});

	const faction = factionData?.data;

	// Fetch faction list for switcher
	const { data: factionList, isLoading: isFactionListLoading } = useListFactionsQuery({
		path: { game_id: gameId },
	});

	const factions = useMemo(() => factionList?.data ?? [], [factionList?.data]);

	if (!isEnabled) {
		return (
			<div>
				<h2>Faction View</h2>
				{isFactionListLoading ? (
					<div>Loading factions...</div>
				) : (
					<SelectFactionCombobox
						gameId={gameId}
						characterId={characterId}
						factions={factions}
					/>
				)}
			</div>
		);
	}

	return (
		<div>
			<h2>Faction View</h2>
			{faction && (
				<div className="flex flex-col gap-2">
					<div className="flex items-center gap-2">
						<div className="text-muted-foreground">Primary Faction</div>
						<div className="text-muted-foreground">{faction.name}</div>
					</div>
					<div className="flex items-center gap-2">
						<div className="text-muted-foreground">Secondary Faction</div>
						<div className="text-muted-foreground">{faction.name}</div>
					</div>
				</div>
			)}
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/characters/index.tsx">
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useState } from "react";
import {
	listCharactersOptions,
	useListCharactersQuery,
} from "~/api/@tanstack/react-query.gen";
import { CharacterTable } from "~/components/characters/character-table";
import { PageHeader } from "~/components/page-header";

export const Route = createFileRoute("/_auth/games/$gameId/characters/")({
	component: RouteComponent,
	loader: ({ params, context }) => {
		return context.queryClient.ensureQueryData(
			listCharactersOptions({ path: { game_id: params.gameId } }),
		);
	},
});

function RouteComponent() {
	const { gameId } = Route.useParams();
	const { data, isLoading } = useListCharactersQuery({ path: { game_id: gameId } });
	const characters = data?.data || [];
	const [searchQuery, setSearchQuery] = useState("");
	const [tagFilter, setTagFilter] = useState("");
	const navigate = useNavigate();

	if (isLoading) {
		return <div className="text-muted-foreground">Loading characters...</div>;
	}

	const handleCreate = () => {
		navigate({ to: "/games/$gameId/characters/new", params: { gameId } });
	};

	return (
		<div className="container mx-auto py-8">
			<PageHeader
				title="All Characters"
				description="Browse all characters in your game."
				handleCreate={handleCreate}
			/>
			<CharacterTable
				gameId={gameId}
				data={characters}
				searchQuery={searchQuery}
				onSearchChange={setSearchQuery}
				tagFilter={tagFilter}
				onTagFilterChange={setTagFilter}
			/>
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/factions/$id/index.tsx">
import { createFileRoute, Navigate } from "@tanstack/react-router";
import * as React from "react";
import type { Faction } from "~/api";
import {
	useGetFactionLinksQuery,
	useGetFactionMembersQuery,
} from "~/api/@tanstack/react-query.gen";
import { CharacterTable } from "~/components/characters/character-table";
import { useAddTab } from "~/components/entity-tabs";
import { EntityView } from "~/components/entity-view";
import { CreateFactionLink } from "~/components/factions/create-faction-link";
import { Badge } from "~/components/ui/badge";
import { EntityEditor } from "~/components/ui/editor/entity-editor";
import { EntityLinksTable } from "~/components/ui/entity-links-table";
import { useFactionSuspenseQuery, useUpdateFactionMutation } from "~/queries/factions";
import { flattenLinksForTable, type GenericLinksResponse } from "~/utils/linkHelpers";

export const Route = createFileRoute("/_auth/games/$gameId/factions/$id/")({
	component: RouteComponent,
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data } = useFactionSuspenseQuery(gameId, id);
	const faction = data?.data;

	useAddTab({
		data: faction,
		entityType: "factions",
		gameId,
	});

	if (!faction) {
		return <Navigate to=".." />;
	}

	return <FactionView faction={faction} gameId={gameId} />;
}

// MAIN VIEW COMPONENT

interface FactionViewProps {
	faction: Faction;
	gameId: string;
}

function FactionView({ faction, gameId }: FactionViewProps) {
	const {
		data: linksResponse,
		isLoading: linksLoading,
		isError: linksError,
		error: linksQueryError,
	} = useGetFactionLinksQuery({ path: { game_id: gameId, faction_id: faction.id } });

	const updateFaction = useUpdateFactionMutation(gameId, faction.id);

	const handleSave = async (payload: {
		content: string;
		content_plain_text: string;
	}) => {
		updateFaction.mutate({
			body: { faction: payload },
			path: { game_id: gameId, id: faction.id },
		});
	};

	const badges = faction.tags && faction.tags.length > 0 && (
		<div className="flex flex-wrap gap-2">
			{faction.tags.map((tag) => (
				<Badge key={tag} variant="secondary">
					{tag}
				</Badge>
			))}
		</div>
	);

	const contentTab = (
		<EntityEditor
			content={faction.content}
			gameId={gameId}
			entityType="faction"
			entityId={faction.id}
			onSave={handleSave}
			isSaving={updateFaction.isPending}
		/>
	);

	const linksTab = (
		<div className="space-y-4">
			<CreateFactionLink gameId={gameId} factionId={faction.id} />
			{linksLoading && (
				<div className="text-muted-foreground">Loading links...</div>
			)}
			{linksError && (
				<div className="text-destructive">
					Error loading links: {linksQueryError?.message}
				</div>
			)}
			{!linksLoading && !linksError && linksResponse && (
				<EntityLinksTable
					links={flattenLinksForTable(linksResponse as GenericLinksResponse)}
					gameId={gameId}
					sourceId={faction.id}
					sourceType={"faction"}
				/>
			)}
		</div>
	);

	const tabs = [
		{
			id: "content",
			label: "Content",
			content: contentTab,
		},
		{
			id: "links",
			label: "Links",
			content: linksTab,
		},
		{
			id: "notes",
			label: "Notes",
			content: <div>Notes tabs tbc</div>,
		},
		{
			id: "members",
			label: "Members",
			content: <MembersView factionId={faction.id} gameId={gameId} />,
		},
	];

	const navigate = Route.useNavigate();

	return (
		<EntityView
			name={faction.name}
			badges={badges}
			tabs={tabs}
			onEdit={() => navigate({ to: "edit" })}
		/>
	);
}

interface FactionMembersViewProps {
	factionId: string;
	gameId: string;
}
function MembersView({ factionId, gameId }: FactionMembersViewProps) {
	const { data: memberData } = useGetFactionMembersQuery({
		path: { game_id: gameId, faction_id: factionId },
	});
	const members = memberData?.data?.members || [];
	const [searchQuery, setSearchQuery] = React.useState("");
	const [tagFilter, setTagFilter] = React.useState("");

	return (
		<CharacterTable
			gameId={gameId}
			data={members}
			searchQuery={searchQuery}
			onSearchChange={setSearchQuery}
			tagFilter={tagFilter}
			onTagFilterChange={setTagFilter}
		/>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/factions/index.tsx">
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useState } from "react";
import { listFactionsOptions } from "~/api/@tanstack/react-query.gen";
import { FactionsTable } from "~/components/factions/factions-table";
import { PageHeader } from "~/components/page-header";
import { useListFactionsSuspenseQuery } from "~/queries/factions";

export const Route = createFileRoute("/_auth/games/$gameId/factions/")({
	component: RouteComponent,
	loader: async ({ context, params }) => {
		await context.queryClient.ensureQueryData(
			listFactionsOptions({ path: { game_id: params.gameId } }),
		);
	},
});

function RouteComponent() {
	const { gameId } = Route.useParams();
	const { data, isLoading } = useListFactionsSuspenseQuery(gameId);
	const [searchQuery, setSearchQuery] = useState("");
	const [tagFilter, setTagFilter] = useState("");
	const navigate = useNavigate();

	const factions = data?.data || [];

	if (isLoading) {
		return <div className="text-muted-foreground">Loading factions...</div>;
	}

	const handleCreate = () => {
		navigate({ to: "/games/$gameId/factions/new", params: { gameId } });
	};

	return (
		<div className="container mx-auto py-8">
			<PageHeader
				title="All Factions"
				description="Browse all factions in your game."
				handleCreate={handleCreate}
			/>
			<FactionsTable
				gameId={gameId}
				data={factions}
				searchQuery={searchQuery}
				onSearchChange={setSearchQuery}
				tagFilter={tagFilter}
				onTagFilterChange={setTagFilter}
			/>
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/locations/$id/edit.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { getLocationOptions, useGetLocationQuery } from "~/api/@tanstack/react-query.gen";
import { EditLocationForm } from "~/components/locations/edit-location-form";

export const Route = createFileRoute("/_auth/games/$gameId/locations/$id/edit")({
	component: RouteComponent,
	loader: ({ context, params }) => {
		context.queryClient.ensureQueryData(
			getLocationOptions({
				path: { game_id: params.gameId, id: params.id },
			}),
		);
	},
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data, isLoading, isSuccess } = useGetLocationQuery({
		path: { game_id: gameId, id: id },
	});

	if (isLoading) {
		return <div>Loading...</div>;
	}

	return (
		<div>
			{isSuccess && <EditLocationForm initialData={data.data} params={params} />}
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/locations/index.tsx">
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useState } from "react";
import { listLocationsOptions } from "~/api/@tanstack/react-query.gen";
import { LocationsTable } from "~/components/locations/locations-table";
import { PageHeader } from "~/components/page-header";
import { useListLocationsSuspenseQuery } from "~/queries/locations";

export const Route = createFileRoute("/_auth/games/$gameId/locations/")({
	component: RouteComponent,
	loader: async ({ context, params }) => {
		await context.queryClient.ensureQueryData(
			listLocationsOptions({ path: { game_id: params.gameId } }),
		);
	},
});

function RouteComponent() {
	const { gameId } = Route.useParams();
	const { data } = useListLocationsSuspenseQuery(gameId);
	const [searchQuery, setSearchQuery] = useState("");
	const [tagFilter, setTagFilter] = useState("");
	const navigate = useNavigate();

	const locations = data?.data || [];

	const handleCreate = () => {
		navigate({ to: "/games/$gameId/locations/new", params: { gameId } });
	};

	return (
		<div className="container mx-auto py-8">
			<PageHeader
				title="All Locations"
				description="Browse all locations in your game."
				handleCreate={handleCreate}
			/>
			<LocationsTable
				gameId={gameId}
				data={locations}
				searchQuery={searchQuery}
				onSearchChange={setSearchQuery}
				tagFilter={tagFilter}
				onTagFilterChange={setTagFilter}
			/>
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/notes/$id/edit.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { getNoteOptions, useGetNoteQuery } from "~/api/@tanstack/react-query.gen";
import { EditNoteForm } from "~/components/notes/edit-note-form";

export const Route = createFileRoute("/_auth/games/$gameId/notes/$id/edit")({
	component: RouteComponent,
	loader: ({ context, params }) => {
		context.queryClient.ensureQueryData(
			getNoteOptions({
				path: { game_id: params.gameId, id: params.id },
			}),
		);
	},
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data, isLoading, isSuccess } = useGetNoteQuery({
		path: { game_id: gameId, id: id },
	});

	if (isLoading) {
		return <div>Loading...</div>;
	}

	return (
		<div>
			{isSuccess && <EditNoteForm initialData={data.data} params={params} />}
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/notes/index.tsx">
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useState } from "react";
import { listNotesOptions } from "~/api/@tanstack/react-query.gen";
import { NotesTable } from "~/components/notes/notes-table";
import { PageHeader } from "~/components/page-header";
import { useListNotesSuspenseQuery } from "~/queries/notes";

export const Route = createFileRoute("/_auth/games/$gameId/notes/")({
	component: RouteComponent,
	loader: ({ params, context }) => {
		return context.queryClient.ensureQueryData(
			listNotesOptions({ path: { game_id: params.gameId } }),
		);
	},
});

function RouteComponent() {
	const { gameId } = Route.useParams();
	const { data, isLoading } = useListNotesSuspenseQuery(gameId);
	const [searchQuery, setSearchQuery] = useState("");
	const [tagFilter, setTagFilter] = useState("");
	const navigate = useNavigate();

	const notes = data?.data || [];

	if (isLoading) {
		return <div className="text-muted-foreground">Loading notes...</div>;
	}

	const handleCreate = () => {
		navigate({ to: "/games/$gameId/notes/new", params: { gameId } });
	};

	return (
		<div className="container mx-auto py-8">
			<PageHeader
				title="All Notes"
				description="Browse all notes in your game."
				handleCreate={handleCreate}
			/>
			<NotesTable
				gameId={gameId}
				data={notes}
				searchQuery={searchQuery}
				onSearchChange={setSearchQuery}
				tagFilter={tagFilter}
				onTagFilterChange={setTagFilter}
			/>
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/quests/$id/edit.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { getQuestOptions, useGetQuestQuery } from "~/api/@tanstack/react-query.gen";
import { EditQuestForm } from "~/components/quests/edit-quest-form";

export const Route = createFileRoute("/_auth/games/$gameId/quests/$id/edit")({
	component: RouteComponent,
	loader: ({ context, params }) => {
		context.queryClient.ensureQueryData(
			getQuestOptions({
				path: { game_id: params.gameId, id: params.id },
			}),
		);
	},
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data, isLoading, isSuccess } = useGetQuestQuery({
		path: { game_id: gameId, id: id },
	});

	if (isLoading) {
		return <div>Loading...</div>;
	}

	return (
		<div>
			{isSuccess && <EditQuestForm initialData={data.data} params={params} />}
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/quests/index.tsx">
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useState } from "react";
import { listQuestsOptions } from "~/api/@tanstack/react-query.gen";
import { PageHeader } from "~/components/page-header";
import { QuestsTable } from "~/components/quests/quests-table";
import { useListQuestsSuspenseQuery } from "~/queries/quests";

export const Route = createFileRoute("/_auth/games/$gameId/quests/")({
	component: RouteComponent,
	loader: ({ params, context }) => {
		return context.queryClient.ensureQueryData(
			listQuestsOptions({ path: { game_id: params.gameId } }),
		);
	},
});

function RouteComponent() {
	const { gameId } = Route.useParams();
	const { data, isLoading } = useListQuestsSuspenseQuery(gameId);
	const [searchQuery, setSearchQuery] = useState("");
	const [tagFilter, setTagFilter] = useState("");
	const navigate = useNavigate();

	const quests = data?.data || [];

	if (isLoading) {
		return <div className="text-muted-foreground">Loading quests...</div>;
	}

	const handleCreate = () => {
		navigate({ to: "/games/$gameId/quests/new", params: { gameId } });
	};

	return (
		<div className="container mx-auto py-8">
			<PageHeader
				title="All Quests"
				description="Browse all quests in your game."
				handleCreate={handleCreate}
			/>
			<QuestsTable
				gameId={gameId}
				data={quests}
				searchQuery={searchQuery}
				onSearchChange={setSearchQuery}
				tagFilter={tagFilter}
				onTagFilterChange={setTagFilter}
			/>
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/new.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { CreateGameForm } from "~/components/games/create-game-form";

export const Route = createFileRoute("/_auth/games/new")({
	component: RouteComponent,
});

function RouteComponent() {
	return (
		<div className="max-w-2xl mx-auto bg-card p-6 mt-20 rounded-lg shadow-md">
			<CreateGameForm />
		</div>
	);
}
</file>

<file path="src/routes/signup.tsx">
import { createFileRoute, redirect } from "@tanstack/react-router";
import { createServerFn, useServerFn } from "@tanstack/react-start";
import { signupUser } from "~/api";
import { Auth } from "~/components/auth";
import { useMutationLite } from "~/hooks/useMutationLite";
import { parseApiError } from "~/utils/error-parser";
import { getAppSession } from "~/utils/session";

export const signupFn = createServerFn({ method: "POST" })
	.inputValidator((d: { email: string; password: string; redirectUrl?: string }) => d)
	.handler(async ({ data }) => {
		const { data: signupData, error } = await signupUser({ body: data });

		if (error?.errors) {
			const parsedError = parseApiError(error.errors);
			console.log(parsedError);
			return {
				error: true,
				message: parsedError.message,
				userExists:
					parsedError.field === "email" &&
					parsedError.message === "has already been taken",
			};
		}

		// Create a session
		const session = await getAppSession();

		if (signupData) {
			// Store the user's email in the session
			await session.update({
				user: signupData.user,
				token: signupData.token,
			});

			// Redirect to the prev page stored in the "redirect" search param
			throw redirect({
				href: data.redirectUrl || "/",
			});
		}

		// Redirect to the prev page stored in the "redirect" search param
		throw redirect({
			href: data.redirectUrl || "/",
		});
	});

export const Route = createFileRoute("/signup")({
	component: SignupComp,
});

function SignupComp() {
	const signupMutation = useMutationLite({
		fn: useServerFn(signupFn),
	});

	return (
		<Auth
			actionText="Sign Up"
			status={signupMutation.status}
			onSubmit={(e) => {
				const formData = new FormData(e.target as HTMLFormElement);

				signupMutation.mutate({
					data: {
						email: formData.get("email") as string,
						password: formData.get("password") as string,
					},
				});
			}}
			afterSubmit={
				signupMutation.data?.error ? (
					<div className="text-red-400">{signupMutation.data.message}</div>
				) : null
			}
		/>
	);
}
</file>

<file path="src/utils/linkHelpers.ts">
import type {
	LinkedCharacter,
	LinkedFaction,
	LinkedLocation,
	LinkedNote,
	LinkedQuest,
} from "~/api/types.gen";
import type { EntityType } from "~/types";

export interface EntityLink {
	id: string;
	name: string;
	type: EntityType;
	content?: string;
	content_plain_text?: string;
	relationship_type?: string;
	is_active?: boolean;
	description_meta?: string;
	metadata?: {
		[key: string]: unknown;
	};
	strength?: number;
	tags?: Array<unknown>;
}

export interface GenericLinksResponse {
	data: {
		links: {
			characters: LinkedCharacter[];
			factions: LinkedFaction[];
			notes: LinkedNote[];
			locations: LinkedLocation[];
			quests: LinkedQuest[];
		};
	};
}

export function flattenLinksForTable(linksResponse: GenericLinksResponse): EntityLink[] {
	const { links } = linksResponse.data;
	const flattenedLinks: EntityLink[] = [];

	Object.entries(links).forEach(([type, entities]) => {
		entities.forEach((entity) => {
			flattenedLinks.push({
				id: entity.id,
				name: entity.name,
				type: type.slice(0, -1) as EntityType, // Remove 's' from plural (factions -> faction)
				relationship_type: entity.relationship_type,
				content:
					"content" in entity && typeof entity.content === "string"
						? entity.content
						: undefined,
				content_plain_text:
					"content_plain_text" in entity &&
					typeof entity.content_plain_text === "string"
						? entity.content_plain_text
						: undefined,
				is_active: entity.is_active,
				metadata: entity.metadata,
				strength: entity.strength,
				tags: entity.tags,
				description_meta: entity.description_meta,
			});
		});
	});

	return flattenedLinks;
}
</file>

<file path="src/styles.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

:root {
	--background: oklch(1 0 0);
	--foreground: oklch(0.145 0 0);
	--card: oklch(1 0 0);
	--card-foreground: oklch(0.145 0 0);
	--popover: oklch(1 0 0);
	--popover-foreground: oklch(0.145 0 0);
	--primary: oklch(0.5198 0.1956 24.7048);
	--primary-foreground: oklch(1 0 0);
	--secondary: oklch(0.97 0 0);
	--secondary-foreground: oklch(0.205 0 0);
	--muted: oklch(0.97 0 0);
	--muted-foreground: oklch(0.556 0 0);
	--accent: oklch(0.97 0 0);
	--accent-foreground: oklch(0.205 0 0);
	--destructive: oklch(0.577 0.245 27.325);
	--destructive-foreground: oklch(1 0 0);
	--border: oklch(0.922 0 0);
	--input: oklch(0.922 0 0);
	--ring: oklch(0.708 0 0);
	--chart-1: oklch(0.81 0.1 252);
	--chart-2: oklch(0.62 0.19 260);
	--chart-3: oklch(0.55 0.22 263);
	--chart-4: oklch(0.49 0.22 264);
	--chart-5: oklch(0.42 0.18 266);
	--sidebar: oklch(0.985 0 0);
	--sidebar-foreground: oklch(0.145 0 0);
	--sidebar-primary: oklch(0.205 0 0);
	--sidebar-primary-foreground: oklch(0.985 0 0);
	--sidebar-accent: oklch(0.97 0 0);
	--sidebar-accent-foreground: oklch(0.205 0 0);
	--sidebar-border: oklch(0.922 0 0);
	--sidebar-ring: oklch(0.708 0 0);
	--font-sans:
		ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
	--font-serif: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
	--font-mono:
		ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
		"Courier New", monospace;
	--radius: 0.225rem;
	--shadow-2xs: 0 1px 2px 0px hsl(0 0% 0% / 0.03);
	--shadow-xs: 0 1px 2px 0px hsl(0 0% 0% / 0.04);
	--shadow-sm: 0 1px 2px 0px hsl(0 0% 0% / 0.05), 0 1px 1px -1px hsl(0 0% 0% / 0.05);
	--shadow: 0 1px 3px 0px hsl(0 0% 0% / 0.06), 0 1px 2px -1px hsl(0 0% 0% / 0.06);
	--shadow-md: 0 2px 4px 0px hsl(0 0% 0% / 0.07), 0 1px 2px -1px hsl(0 0% 0% / 0.07);
	--shadow-lg: 0 3px 6px 0px hsl(0 0% 0% / 0.08), 0 2px 4px -1px hsl(0 0% 0% / 0.08);
	--shadow-xl: 0 6px 10px 0px hsl(0 0% 0% / 0.09), 0 4px 6px -1px hsl(0 0% 0% / 0.09);
	--shadow-2xl: 0 10px 15px 0px hsl(0 0% 0% / 0.12);
	--tracking-normal: 0em;
	--spacing: 0.25rem;

	/* Editor-specific variables */
	--editor-text-brown: hsl(25 95% 53%);
	--editor-text-orange: hsl(24 95% 53%);
	--editor-text-yellow: hsl(48 96% 53%);
	--editor-text-green: hsl(142 71% 45%);
	--editor-text-purple: hsl(269 97% 85%);
	--editor-text-pink: hsl(336 80% 58%);

	--editor-highlight-brown: hsl(43 96% 96%);
	--editor-highlight-orange: hsl(33 100% 96%);
	--editor-highlight-yellow: hsl(54 100% 96%);
	--editor-highlight-green: hsl(142 71% 96%);
	--editor-highlight-blue: hsl(217 91% 96%);
	--editor-highlight-purple: hsl(269 97% 96%);
	--editor-highlight-pink: hsl(336 80% 96%);
	--editor-highlight-red: hsl(0 84% 96%);

	--editor-spacing-1: 0.25rem;
	--editor-spacing-2: 0.5rem;
	--editor-spacing-3: 0.75rem;
	--editor-spacing-4: 1rem;
	--editor-spacing-6: 1.5rem;
	--editor-spacing-8: 2rem;
	--editor-spacing-12: 3rem;
	--editor-spacing-16: 4rem;

	--editor-transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
	--editor-transition-normal: 200ms cubic-bezier(0.4, 0, 0.2, 1);
	--editor-transition-slow: 300ms cubic-bezier(0.4, 0, 0.2, 1);
}

.dark {
	--background: oklch(0.145 0 0);
	--foreground: oklch(0.985 0 0);
	--card: oklch(0.205 0 0);
	--card-foreground: oklch(0.985 0 0);
	--popover: oklch(0.22 0 0);
	--popover-foreground: oklch(0.985 0 0);
	--primary: oklch(0.5198 0.1956 24.7048);
	--primary-foreground: oklch(1 0 0);
	--secondary: oklch(0.269 0 0);
	--secondary-foreground: oklch(0.985 0 0);
	--muted: oklch(0.18 0 0);
	--muted-foreground: oklch(0.708 0 0);
	--accent: oklch(0.371 0 0);
	--accent-foreground: oklch(0.985 0 0);
	--destructive: oklch(0.704 0.191 22.216);
	--destructive-foreground: oklch(0.985 0 0);
	--border: oklch(0.275 0 0);
	--input: oklch(0.325 0 0);
	--ring: oklch(0.556 0 0);
	--chart-1: oklch(0.81 0.1 252);
	--chart-2: oklch(0.62 0.19 260);
	--chart-3: oklch(0.55 0.22 263);
	--chart-4: oklch(0.49 0.22 264);
	--chart-5: oklch(0.42 0.18 266);
	--sidebar: oklch(0.205 0 0);
	--sidebar-foreground: oklch(0.985 0 0);
	--sidebar-primary: oklch(0.488 0.243 264.376);
	--sidebar-primary-foreground: oklch(0.985 0 0);
	--sidebar-accent: oklch(0.269 0 0);
	--sidebar-accent-foreground: oklch(0.985 0 0);
	--sidebar-border: oklch(0.275 0 0);
	--sidebar-ring: oklch(0.439 0 0);
	--font-sans:
		ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
	--font-serif: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
	--font-mono:
		ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
		"Courier New", monospace;
	--radius: 0.225rem;
	--shadow-2xs: 0 1px 3px 0px hsl(0 0% 0% / 0.05);
	--shadow-xs: 0 1px 3px 0px hsl(0 0% 0% / 0.05);
	--shadow-sm: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 1px 2px -1px hsl(0 0% 0% / 0.1);
	--shadow: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 1px 2px -1px hsl(0 0% 0% / 0.1);
	--shadow-md: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 2px 4px -1px hsl(0 0% 0% / 0.1);
	--shadow-lg: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 4px 6px -1px hsl(0 0% 0% / 0.1);
	--shadow-xl: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 8px 10px -1px hsl(0 0% 0% / 0.1);
	--shadow-2xl: 0 1px 3px 0px hsl(0 0% 0% / 0.25);

	/* Editor-specific dark mode variables */
	--editor-highlight-brown: hsl(43 96% 10%);
	--editor-highlight-orange: hsl(33 100% 10%);
	--editor-highlight-yellow: hsl(54 100% 10%);
	--editor-highlight-green: hsl(142 71% 10%);
	--editor-highlight-blue: hsl(217 91% 10%);
	--editor-highlight-purple: hsl(269 97% 10%);
	--editor-highlight-pink: hsl(336 80% 10%);
	--editor-highlight-red: hsl(0 84% 10%);
}

@theme inline {
	--color-background: var(--background);
	--color-foreground: var(--foreground);
	--color-card: var(--card);
	--color-card-foreground: var(--card-foreground);
	--color-popover: var(--popover);
	--color-popover-foreground: var(--popover-foreground);
	--color-primary: var(--primary);
	--color-primary-foreground: var(--primary-foreground);
	--color-secondary: var(--secondary);
	--color-secondary-foreground: var(--secondary-foreground);
	--color-muted: var(--muted);
	--color-muted-foreground: var(--muted-foreground);
	--color-accent: var(--accent);
	--color-accent-foreground: var(--accent-foreground);
	--color-destructive: var(--destructive);
	--color-destructive-foreground: var(--destructive-foreground);
	--color-border: var(--border);
	--color-input: var(--input);
	--color-ring: var(--ring);
	--color-chart-1: var(--chart-1);
	--color-chart-2: var(--chart-2);
	--color-chart-3: var(--chart-3);
	--color-chart-4: var(--chart-4);
	--color-chart-5: var(--chart-5);
	--color-sidebar: var(--sidebar);
	--color-sidebar-foreground: var(--sidebar-foreground);
	--color-sidebar-primary: var(--sidebar-primary);
	--color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
	--color-sidebar-accent: var(--sidebar-accent);
	--color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
	--color-sidebar-border: var(--sidebar-border);
	--color-sidebar-ring: var(--sidebar-ring);

	--font-sans: var(--font-sans);
	--font-mono: var(--font-mono);
	--font-serif: var(--font-serif);

	--radius-sm: calc(var(--radius) - 4px);
	--radius-md: calc(var(--radius) - 2px);
	--radius-lg: var(--radius);
	--radius-xl: calc(var(--radius) + 4px);

	--shadow-2xs: var(--shadow-2xs);
	--shadow-xs: var(--shadow-xs);
	--shadow-sm: var(--shadow-sm);
	--shadow: var(--shadow);
	--shadow-md: var(--shadow-md);
	--shadow-lg: var(--shadow-lg);
	--shadow-xl: var(--shadow-xl);
	--shadow-2xl: var(--shadow-2xl);
}

@layer base {
	* {
		@apply border-border outline-ring/50;
	}
	body {
		@apply bg-background text-foreground;
	}
}
</file>

<file path="biome.json">
{
	"$schema": "https://biomejs.dev/schemas/2.2.3/schema.json",
	"vcs": {
		"enabled": false,
		"clientKind": "git",
		"useIgnoreFile": false
	},
	"files": {
		"ignoreUnknown": false,
		"includes": [
			"src/**/*",
			"!src/api/**/*",
			"!src/routeTree.gen.ts",
			"vite.config.ts",
			"server/*",
			"index.html"
		]
	},
	"assist": {
		"enabled": true,
		"actions": {
			"source": {
				"organizeImports": "on"
			}
		}
	},
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true,
			"correctness": {
				"useExhaustiveDependencies": "warn",
				"useUniqueElementIds": "off",
				"noUnusedVariables": "off"
			},
			"security": {
				"noDangerouslySetInnerHtml": "warn"
			},
			"style": {
				"noNonNullAssertion": "off",
				"noInferrableTypes": "off"
			},
			"suspicious": {
				"noUnknownAtRules": "off"
			}
		}
	},
	"formatter": {
		"enabled": true,
		"formatWithErrors": true,
		"indentStyle": "tab",
		"indentWidth": 4,
		"lineWidth": 90,
		"lineEnding": "lf"
	},
	"css": {
		"formatter": {
			"enabled": true
		}
	},
	"overrides": [
		{
			"includes": ["*.jsx", "*.tsx"],
			"formatter": {
				"indentWidth": 2,
				"indentStyle": "space"
			}
		}
	],
	"javascript": {
		"formatter": {
			"quoteStyle": "double"
		}
	}
}
</file>

<file path="openapi-ts.config.ts">
import { defineConfig } from "@hey-api/openapi-ts";

export default defineConfig({
	input: "./server/schema/swagger.json",
	output: "src/api",
	
	plugins: [
		{ 
			name: "@tanstack/react-query",
			queryOptions: true,
			useQuery: true,
		},
		"zod"
	],
});
</file>

<file path="vite.config.ts">
import { cloudflare } from "@cloudflare/vite-plugin";
import tailwindcss from "@tailwindcss/vite";
import { tanstackStart } from "@tanstack/react-start/plugin/vite";
import viteReact from "@vitejs/plugin-react";
import { defineConfig } from "vite";
import viteTsConfigPaths from "vite-tsconfig-paths";

const config = defineConfig({
	server: {
		port: 3000,
	},
	plugins: [
		// this is the plugin that enables path aliases
		viteTsConfigPaths({
			projects: ["./tsconfig.json"],
		}),
		cloudflare({ viteEnvironment: { name: "ssr" } }),
		tailwindcss(),
		tanstackStart(),
		viteReact(),
	],
});

export default config;
</file>

<file path="wrangler.jsonc">
{
    "$schema": "node_modules/wrangler/config-schema.json",
    "name": "game-master-web",
    "compatibility_date": "2025-09-02",
    "compatibility_flags": [
        "nodejs_compat"
    ],
    "main": "@tanstack/react-start/server-entry",
    "observability": {
        "enabled": true,
    },
    "routes": [
        {
            "pattern": "gamemaster.callumkloos.dev",
            "custom_domain": true
        }
    ]
}
</file>

<file path="src/components/commander.tsx">
import { useNavigate } from "@tanstack/react-router";
import { User } from "lucide-react";
import * as React from "react";

import {
	CommandDialog,
	CommandEmpty,
	CommandGroup,
	CommandInput,
	CommandItem,
	CommandList,
	CommandSeparator,
	CommandShortcut,
} from "~/components/ui/command";
import { useGetGameLinksSuspenseQuery } from "~/queries/games";

export function Commander({
	gameId,
	isOpen,
	setIsOpen,
}: {
	gameId: string;
	isOpen: boolean;
	setIsOpen: (open: boolean) => void;
}) {
	const navigate = useNavigate();

	const { data: links, isLoading: linksLoading } = useGetGameLinksSuspenseQuery({
		id: gameId,
	});
	const characters = links?.data?.entities?.characters;
	const factions = links?.data?.entities?.factions;
	const locations = links?.data?.entities?.locations;
	const notes = links?.data?.entities?.notes;
	const quests = links?.data?.entities?.quests;

	// biome-ignore lint/correctness/useExhaustiveDependencies: Intent is to set up a global keyboard shortcut
	React.useEffect(() => {
		const down = (e: KeyboardEvent) => {
			if (e.key === "j" && (e.metaKey || e.ctrlKey)) {
				e.preventDefault();
				setIsOpen(!isOpen);
			}
		};

		document.addEventListener("keydown", down);
		return () => document.removeEventListener("keydown", down);
	}, []);

	return (
		<CommandDialog open={isOpen} onOpenChange={setIsOpen}>
			<CommandInput placeholder="Type a command or search..." />
			<CommandList>
				<CommandEmpty>No results found.</CommandEmpty>
				{linksLoading ? (
					<CommandGroup heading="Loading...">
						<CommandItem disabled>
							<span>Loading entities...</span>
						</CommandItem>
					</CommandGroup>
				) : (
					<>
						<CommandGroup heading="Characters">
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/characters",
										params: { gameId },
									});
								}}
							>
								<User />
								<span className="font-semibold">All Characters</span>
							</CommandItem>
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/characters/new",
										params: { gameId },
									});
								}}
							>
								<User />
								<span>New Character</span>
								<CommandShortcut>‚åòC</CommandShortcut>
							</CommandItem>
							{characters?.map((character) => (
								<CommandItem
									key={character.id}
									onSelect={() => {
										setIsOpen(false);
										navigate({
											to: "/games/$gameId/characters/$id",
											params: { gameId, id: character.id },
										});
									}}
								>
									<User />
									<span>{character.name}</span>
								</CommandItem>
							))}
						</CommandGroup>
						<CommandSeparator />
						<CommandGroup heading="Factions">
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/factions",
										params: { gameId },
									});
								}}
							>
								<User />
								<span className="font-semibold">All Factions</span>
							</CommandItem>
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/factions/new",
										params: { gameId },
									});
								}}
							>
								<User />
								<span>New Faction</span>
								<CommandShortcut>‚åòF</CommandShortcut>
							</CommandItem>
							{factions?.map((faction) => (
								<CommandItem
									key={faction.id}
									onSelect={() => {
										setIsOpen(false);
										navigate({
											to: "/games/$gameId/factions/$id",
											params: { gameId, id: faction.id },
										});
									}}
								>
									<User />
									<span>{faction.name}</span>
								</CommandItem>
							))}
						</CommandGroup>
						<CommandSeparator />
						<CommandGroup heading="Locations">
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/locations",
										params: { gameId },
									});
								}}
							>
								<User />
								<span className="font-semibold">All Locations</span>
							</CommandItem>
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/locations/new",
										params: { gameId },
									});
								}}
							>
								<User />
								<span>New Location</span>
								<CommandShortcut>‚åòL</CommandShortcut>
							</CommandItem>
							{locations?.map((location) => (
								<CommandItem
									key={location.id}
									onSelect={() => {
										setIsOpen(false);
										navigate({
											to: "/games/$gameId/locations/$id",
											params: { gameId, id: location.id },
										});
									}}
								>
									<User />
									<span>{location.name}</span>
								</CommandItem>
							))}
						</CommandGroup>
						<CommandSeparator />
						<CommandGroup heading="Notes">
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/notes",
										params: { gameId },
									});
								}}
							>
								<User />
								<span className="font-semibold">All Notes</span>
							</CommandItem>
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/notes/new",
										params: { gameId },
									});
								}}
							>
								<User />
								<span>New Note</span>
								<CommandShortcut>‚åòN</CommandShortcut>
							</CommandItem>
							{notes?.map((note) => (
								<CommandItem
									key={note.id}
									onSelect={() => {
										setIsOpen(false);
										navigate({
											to: "/games/$gameId/notes/$id",
											params: { gameId, id: note.id },
										});
									}}
								>
									<User />
									<span>{note.name}</span>
								</CommandItem>
							))}
						</CommandGroup>
						<CommandSeparator />
						<CommandGroup heading="Quests">
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/quests",
										params: { gameId },
									});
								}}
							>
								<User />
								<span className="font-semibold">All Quests</span>
							</CommandItem>
							<CommandItem
								onSelect={() => {
									setIsOpen(false);
									navigate({
										to: "/games/$gameId/quests/new",
										params: { gameId },
									});
								}}
							>
								<User />
								<span>New Quest</span>
								<CommandShortcut>‚åòQ</CommandShortcut>
							</CommandItem>
							{quests?.map((quest) => (
								<CommandItem
									key={quest.id}
									onSelect={() => {
										setIsOpen(false);
										navigate({
											to: "/games/$gameId/quests/$id",
											params: { gameId, id: quest.id },
										});
									}}
								>
									<User />
									<span>{quest.name}</span>
								</CommandItem>
							))}
						</CommandGroup>
					</>
				)}
			</CommandList>
		</CommandDialog>
	);
}
</file>

<file path="src/integrations/tanstack-query/root-provider.tsx">
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

export function getContext() {
	const queryClient = new QueryClient({
		defaultOptions: {
			queries: {
				staleTime: 5 * 60 * 1000,
			},
		},
	});
	return {
		queryClient,
	};
}

export function Provider({
	children,
	queryClient,
}: {
	children: React.ReactNode;
	queryClient: QueryClient;
}) {
	return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
}
</file>

<file path="src/routes/_auth/games/$gameId/characters/$id/edit.tsx">
import { createFileRoute } from "@tanstack/react-router";
import {
	getCharacterOptions,
	useGetCharacterQuery,
} from "~/api/@tanstack/react-query.gen";
import { EditCharacterForm } from "~/components/characters/edit-character-form";

export const Route = createFileRoute("/_auth/games/$gameId/characters/$id/edit")({
	component: RouteComponent,
	loader: ({ context, params }) => {
		context.queryClient.ensureQueryData(
			getCharacterOptions({
				path: { game_id: params.gameId, id: params.id },
			}),
		);
	},
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data, isLoading, isSuccess } = useGetCharacterQuery({
		path: { game_id: gameId, id: id },
	});

	if (isLoading) {
		return <div>Loading...</div>;
	}

	return (
		<div>
			{isSuccess && <EditCharacterForm initialData={data.data} params={params} />}
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/factions/$id/edit.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { getFactionOptions, useGetFactionQuery } from "~/api/@tanstack/react-query.gen";
import { EditFactionForm } from "~/components/factions/edit-faction-form";

export const Route = createFileRoute("/_auth/games/$gameId/factions/$id/edit")({
	component: RouteComponent,
	loader: ({ context, params }) => {
		context.queryClient.ensureQueryData(
			getFactionOptions({
				path: { game_id: params.gameId, id: params.id },
			}),
		);
	},
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data, isLoading, isSuccess } = useGetFactionQuery({
		path: { game_id: gameId, id: id },
	});

	if (isLoading) {
		return <div>Loading...</div>;
	}

	return (
		<div>
			{isSuccess && <EditFactionForm initialData={data.data} params={params} />}
		</div>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/locations/$id/index.tsx">
import { createFileRoute, Navigate } from "@tanstack/react-router";
import type { Location } from "~/api";
import { useGetLocationLinksQuery } from "~/api/@tanstack/react-query.gen";
import { useAddTab } from "~/components/entity-tabs";
import { EntityView } from "~/components/entity-view";
import { CreateLocationLink } from "~/components/locations/create-location-link";
import { Badge } from "~/components/ui/badge";
import { EntityEditor } from "~/components/ui/editor/entity-editor";
import { EntityLinksTable } from "~/components/ui/entity-links-table";
import { useLocationSuspenseQuery, useUpdateLocationMutation } from "~/queries/locations";
import { flattenLinksForTable, type GenericLinksResponse } from "~/utils/linkHelpers";

export const Route = createFileRoute("/_auth/games/$gameId/locations/$id/")({
	component: RouteComponent,
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data } = useLocationSuspenseQuery(gameId, id);
	const location = data?.data;

	useAddTab({
		data: location,
		entityType: "locations",
		gameId,
	});

	if (!location) {
		return <Navigate to=".." />;
	}

	return <LocationView location={location} gameId={gameId} />;
}

// MAIN VIEW COMPONENT

interface LocationViewProps {
	location: Location;
	gameId: string;
}

function LocationView({ location, gameId }: LocationViewProps) {
	const {
		data: linksResponse,
		isLoading: linksLoading,
		isError: linksError,
		error: linksQueryError,
	} = useGetLocationLinksQuery({
		path: { game_id: gameId, location_id: location.id },
	});

	const updateLocation = useUpdateLocationMutation(gameId, location.id);

	const handleSave = async (payload: {
		content: string;
		content_plain_text: string;
	}) => {
		updateLocation.mutate({
			body: { location: payload },
			path: { game_id: gameId, id: location.id },
		});
	};

	const badges = (
		<div className="flex flex-wrap gap-2">
			<Badge>{formatType(location.type)}</Badge>
			{location.tags && location.tags.length > 0 && (
				<div className="flex flex-wrap gap-2">
					{location.tags.map((tag) => (
						<Badge key={tag} variant="secondary">
							{tag}
						</Badge>
					))}
				</div>
			)}
		</div>
	);

	const contentTab = (
		<EntityEditor
			content={location.content}
			gameId={gameId}
			entityType="location"
			entityId={location.id}
			onSave={handleSave}
			isSaving={updateLocation.isPending}
		/>
	);

	const linksTab = (
		<div className="space-y-4">
			<CreateLocationLink gameId={gameId} locationId={location.id} />
			{linksLoading && (
				<div className="text-muted-foreground">Loading links...</div>
			)}
			{linksError && (
				<div className="text-destructive">
					Error loading links: {linksQueryError?.message}
				</div>
			)}
			{!linksLoading && !linksError && linksResponse && (
				<EntityLinksTable
					links={flattenLinksForTable(linksResponse as GenericLinksResponse)}
					gameId={gameId}
					sourceId={location.id}
					sourceType="location"
				/>
			)}
		</div>
	);

	const tabs = [
		{
			id: "content",
			label: "Content",
			content: contentTab,
		},
		{
			id: "links",
			label: "Links",
			content: linksTab,
		},
		{
			id: "notes",
			label: "Notes",
			content: <div>Notes tabs tbc</div>,
		},
		{
			id: "npcs",
			label: "NPCs",
			content: <div>NPCs tabs tbc</div>,
		},
	];

	const navigate = Route.useNavigate();

	return (
		<EntityView
			name={location.name}
			badges={badges}
			tabs={tabs}
			onEdit={() => navigate({ to: "edit" })}
		/>
	);
}

const formatType = (type: string) => {
	return type.charAt(0).toUpperCase() + type.slice(1);
};
</file>

<file path="src/routes/_auth/games/$gameId/notes/$id/index.tsx">
import { createFileRoute, Navigate } from "@tanstack/react-router";
import type { Note } from "~/api";
import { useGetNoteLinksQuery } from "~/api/@tanstack/react-query.gen";
import { useAddTab } from "~/components/entity-tabs";
import { EntityView } from "~/components/entity-view";
import { NoteLinksPopover } from "~/components/notes/note-links-popover";
import { Badge } from "~/components/ui/badge";
import { EntityEditor } from "~/components/ui/editor/entity-editor";
import { EntityLinksTable } from "~/components/ui/entity-links-table";
import { useNoteSuspenseQuery, useUpdateNoteMutation } from "~/queries/notes";
import { flattenLinksForTable, type GenericLinksResponse } from "~/utils/linkHelpers";

export const Route = createFileRoute("/_auth/games/$gameId/notes/$id/")({
	component: RouteComponent,
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data } = useNoteSuspenseQuery(gameId, id);
	const note = data?.data;

	useAddTab({
		data: note,
		entityType: "notes",
		gameId,
	});

	if (!note) {
		return <Navigate to=".." />;
	}

	return <NoteView note={note} gameId={gameId} />;
}

// MAIN VIEW COMPONENT

interface NoteViewProps {
	note: Note;
	gameId: string;
}

function NoteView({ note, gameId }: NoteViewProps) {
	const {
		data: linksResponse,
		isLoading: linksLoading,
		isError: linksError,
		error: linksQueryError,
	} = useGetNoteLinksQuery({
		path: { game_id: gameId, note_id: note.id },
	});

	const updateNote = useUpdateNoteMutation(gameId, note.id);

	const handleSave = async (payload: {
		content: string;
		content_plain_text: string;
	}) => {
		updateNote.mutate({
			body: { note: payload },
			path: { game_id: gameId, id: note.id },
		});
	};

	const badges = note.tags && note.tags.length > 0 && (
		<div className="flex flex-wrap gap-2">
			{note.tags.map((tag) => (
				<Badge key={tag} variant="secondary">
					{tag}
				</Badge>
			))}
		</div>
	);

	const contentTab = (
		<EntityEditor
			content={note.content}
			gameId={gameId}
			entityType="note"
			entityId={note.id}
			onSave={handleSave}
			isSaving={updateNote.isPending}
		/>
	);

	const linksTab = (
		<div className="space-y-4">
			<NoteLinksPopover gameId={gameId} noteId={note.id} />
			{linksLoading && (
				<div className="text-muted-foreground">Loading links...</div>
			)}
			{linksError && (
				<div className="text-destructive">
					Error loading links: {linksQueryError?.message}
				</div>
			)}
			{!linksLoading && !linksError && linksResponse && (
				<EntityLinksTable
					links={flattenLinksForTable(linksResponse as GenericLinksResponse)}
					gameId={gameId}
					sourceId={note.id}
					sourceType="note"
				/>
			)}
		</div>
	);

	const tabs = [
		{
			id: "content",
			label: "Content",
			content: contentTab,
		},
		{
			id: "links",
			label: "Links",
			content: linksTab,
		},
		{
			id: "notes",
			label: "Notes",
			content: <div>Notes tabs tbc</div>,
		},
	];

	const navigate = Route.useNavigate();

	return (
		<EntityView
			name={note.name}
			badges={badges}
			tabs={tabs}
			onEdit={() => navigate({ to: "edit" })}
		/>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/quests/$id/index.tsx">
import { createFileRoute, Navigate } from "@tanstack/react-router";
import type { Quest } from "~/api";
import { useGetQuestLinksQuery } from "~/api/@tanstack/react-query.gen";
import { useAddTab } from "~/components/entity-tabs";
import { EntityView } from "~/components/entity-view";
import { QuestLinksPopover } from "~/components/quests/quest-links-popover";
import { Badge } from "~/components/ui/badge";
import { EntityEditor } from "~/components/ui/editor/entity-editor";
import { EntityLinksTable } from "~/components/ui/entity-links-table";
import { useGetQuestSuspenseQuery, useUpdateQuestMutation } from "~/queries/quests";
import { flattenLinksForTable, type GenericLinksResponse } from "~/utils/linkHelpers";

export const Route = createFileRoute("/_auth/games/$gameId/quests/$id/")({
	component: RouteComponent,
});

function RouteComponent() {
	const params = Route.useParams();
	const { gameId, id } = params;
	const { data } = useGetQuestSuspenseQuery(gameId, id);
	const quest = data?.data;

	useAddTab({
		data: quest,
		entityType: "quests",
		gameId,
	});

	if (!quest) {
		return <Navigate to=".." />;
	}

	return <QuestView quest={quest} gameId={gameId} />;
}

// MAIN VIEW COMPONENT

interface QuestViewProps {
	quest: Quest;
	gameId: string;
}

function QuestView({ quest, gameId }: QuestViewProps) {
	const {
		data: linksResponse,
		isLoading: linksLoading,
		isError: linksError,
		error: linksQueryError,
	} = useGetQuestLinksQuery({
		path: { game_id: gameId, quest_id: quest.id },
	});

	const updateQuest = useUpdateQuestMutation(gameId, quest.id);

	const handleSave = async (payload: {
		content: string;
		content_plain_text: string;
	}) => {
		updateQuest.mutate({
			body: { quest: payload },
			path: { game_id: gameId, id: quest.id },
		});
	};

	const badges = quest.tags && quest.tags.length > 0 && (
		<div className="flex flex-wrap gap-2">
			{quest.tags.map((tag) => (
				<Badge key={tag} variant="secondary">
					{tag}
				</Badge>
			))}
		</div>
	);

	const contentTab = (
		<EntityEditor
			content={quest.content}
			gameId={gameId}
			entityType="quest"
			entityId={quest.id}
			onSave={handleSave}
			isSaving={updateQuest.isPending}
		/>
	);

	const linksTab = (
		<div className="space-y-4">
			<QuestLinksPopover gameId={gameId} questId={quest.id} />
			{linksLoading && (
				<div className="text-muted-foreground">Loading links...</div>
			)}
			{linksError && (
				<div className="text-destructive">
					Error loading links: {linksQueryError?.message}
				</div>
			)}
			{!linksLoading && !linksError && linksResponse && (
				<EntityLinksTable
					links={flattenLinksForTable(linksResponse as GenericLinksResponse)}
					gameId={gameId}
					sourceId={quest.id}
					sourceType="quest"
				/>
			)}
		</div>
	);

	const tabs = [
		{
			id: "content",
			label: "Content",
			content: contentTab,
		},
		{
			id: "links",
			label: "Links",
			content: linksTab,
		},
		{
			id: "notes",
			label: "Notes",
			content: <div>Notes tabs tbc</div>,
		},
		{
			id: "objectives",
			label: "Objectives",
			content: <div>Objectives tabs tbc</div>,
		},
	];

	const navigate = Route.useNavigate();

	return (
		<EntityView
			name={quest.name}
			badges={badges}
			tabs={tabs}
			onEdit={() => navigate({ to: "edit" })}
		/>
	);
}
</file>

<file path="src/routes/_auth/games/$gameId/index.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { StatCard } from "~/components/stat-card";
import { Link } from "~/components/ui/link";
import { useGetGameLinksSuspenseQuery, useGetGameSuspenseQuery } from "~/queries/games";

export const Route = createFileRoute("/_auth/games/$gameId/")({
	component: RouteComponent,
});

function RouteComponent() {
	const { gameId } = Route.useParams();

	const { data: gameData } = useGetGameSuspenseQuery({ id: gameId });
	const game = gameData.data;

	const { data: links } = useGetGameLinksSuspenseQuery({
		id: gameId,
	});
	const characters = links?.data?.entities?.characters;
	const factions = links?.data?.entities?.factions;
	const locations = links?.data?.entities?.locations;
	const notes = links?.data?.entities?.notes;
	const quests = links?.data?.entities?.quests;

	return (
		<div className="space-y-6 mt-4">
			<div className="flex items-center justify-between">
				<div>
					<h1 className="text-3xl font-bold">Campaign Dashboard</h1>
					<p>
						{game?.name} - {game?.content || "A TTRPG campaign"}
					</p>
				</div>
				<Link to="/games/$gameId/tree" params={{ gameId }} variant={"default"}>
					View Graph
				</Link>
			</div>
			<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
				<StatCard
					title="Characters"
					value={characters?.length.toString() || "0"}
					href="/games/$gameId/characters"
				/>
				<StatCard
					title="Notes"
					value={notes?.length.toString() || "0"}
					href="/games/$gameId/notes"
				/>
				<StatCard
					title="Factions"
					value={factions?.length.toString() || "0"}
					href="/games/$gameId/factions"
				/>
				<StatCard
					title="Locations"
					value={locations?.length.toString() || "0"}
					href="/games/$gameId/locations"
				/>
				<StatCard
					title="Quests"
					value={quests?.length.toString() || "0"}
					href="/games/$gameId/quests"
				/>
			</div>
		</div>
	);
}
</file>

<file path="src/routes/_auth.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import { useLayoutEffect } from "react";
import { Login } from "~/components/login";
import { clearApiAuth, updateApiAuth } from "~/utils/api-client";

export const Route = createFileRoute("/_auth")({
	beforeLoad: ({ context }) => {
		if (!context.token) {
			throw new Error("Not authenticated");
		}

		updateApiAuth(context.token);
	},
	errorComponent: ({ error }) => {
		if (error.message === "Not authenticated") {
			return <Login />;
		}

		throw error;
	},
	component: AuthLayout,
});

function AuthLayout() {
	const { token } = Route.useRouteContext();
	useLayoutEffect(() => {
		if (token) {
			updateApiAuth(token);
		} else {
			clearApiAuth();
		}
	}, [token]);

	return <Outlet />;
}
</file>

<file path="src/api/@tanstack/react-query.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getFactionLinks, createFactionLink, listLocations, createLocation, logoutUser, loginUser, deleteLocationLink, updateLocationLink, listGameMembers, addGameMember, getCharacterNotesTree, deleteLocation, getLocation, updateLocation, listFactions, createFaction, deleteCharacterLink, updateCharacterLink, listGameEntities, getNoteLinks, createNoteLink, getLocationTree, removeCharacterPrimaryFaction, getCharacterPrimaryFaction, setCharacterPrimaryFaction, pinCharacter, getFactionMembers, listQuests, createQuest, deleteNote, getNote, updateNote, getCharacterLinks, createCharacterLink, listCharacters, createCharacter, deleteGame, getGame, updateGame, getGameEntityTree, unpinCharacter, signupUser, getAuthStatus, deleteQuest, getQuest, updateQuest, getLocationLinks, createLocationLink, deleteNoteLink, updateNoteLink, deleteCharacter, getCharacter, updateCharacter, getQuestLinks, createQuestLink, deleteFaction, getFaction, updateFaction, removeGameMember, deleteFactionLink, updateFactionLink, listNotes, createNote, listPinnedEntities, listGames, createGame, deleteQuestLink, updateQuestLink, getQuestTree } from '../sdk.gen';
import { queryOptions, useQuery, type UseMutationOptions } from '@tanstack/react-query';
import type { GetFactionLinksData, CreateFactionLinkData, CreateFactionLinkError, ListLocationsData, CreateLocationData, CreateLocationError, CreateLocationResponse, LogoutUserData, LogoutUserError, LoginUserData, LoginUserError, LoginUserResponse, DeleteLocationLinkData, DeleteLocationLinkError, UpdateLocationLinkData, UpdateLocationLinkError, UpdateLocationLinkResponse, ListGameMembersData, AddGameMemberData, AddGameMemberError, GetCharacterNotesTreeData, DeleteLocationData, DeleteLocationError, GetLocationData, UpdateLocationData, UpdateLocationError, UpdateLocationResponse, ListFactionsData, CreateFactionData, CreateFactionError, CreateFactionResponse, DeleteCharacterLinkData, DeleteCharacterLinkError, UpdateCharacterLinkData, UpdateCharacterLinkError, UpdateCharacterLinkResponse, ListGameEntitiesData, GetNoteLinksData, CreateNoteLinkData, CreateNoteLinkError, CreateNoteLinkResponse, GetLocationTreeData, RemoveCharacterPrimaryFactionData, RemoveCharacterPrimaryFactionError, RemoveCharacterPrimaryFactionResponse, GetCharacterPrimaryFactionData, SetCharacterPrimaryFactionData, SetCharacterPrimaryFactionError, SetCharacterPrimaryFactionResponse, PinCharacterData, PinCharacterError, PinCharacterResponse, GetFactionMembersData, ListQuestsData, CreateQuestData, CreateQuestError, CreateQuestResponse, DeleteNoteData, DeleteNoteError, GetNoteData, UpdateNoteData, UpdateNoteError, UpdateNoteResponse, GetCharacterLinksData, CreateCharacterLinkData, CreateCharacterLinkError, ListCharactersData, CreateCharacterData, CreateCharacterError, CreateCharacterResponse, DeleteGameData, DeleteGameError, GetGameData, UpdateGameData, UpdateGameError, UpdateGameResponse, GetGameEntityTreeData, UnpinCharacterData, UnpinCharacterError, UnpinCharacterResponse, SignupUserData, SignupUserError, SignupUserResponse, GetAuthStatusData, DeleteQuestData, DeleteQuestError, GetQuestData, UpdateQuestData, UpdateQuestError, UpdateQuestResponse, GetLocationLinksData, CreateLocationLinkData, CreateLocationLinkError, DeleteNoteLinkData, DeleteNoteLinkError, UpdateNoteLinkData, UpdateNoteLinkError, UpdateNoteLinkResponse, DeleteCharacterData, DeleteCharacterError, GetCharacterData, UpdateCharacterData, UpdateCharacterError, UpdateCharacterResponse, GetQuestLinksData, CreateQuestLinkData, CreateQuestLinkError, DeleteFactionData, DeleteFactionError, GetFactionData, UpdateFactionData, UpdateFactionError, UpdateFactionResponse, RemoveGameMemberData, RemoveGameMemberError, DeleteFactionLinkData, DeleteFactionLinkError, UpdateFactionLinkData, UpdateFactionLinkError, UpdateFactionLinkResponse, ListNotesData, CreateNoteData, CreateNoteError, CreateNoteResponse, ListPinnedEntitiesData, ListGamesData, CreateGameData, CreateGameError, CreateGameResponse, DeleteQuestLinkData, DeleteQuestLinkError, UpdateQuestLinkData, UpdateQuestLinkError, UpdateQuestLinkResponse, GetQuestTreeData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getFactionLinksQueryKey = (options: Options<GetFactionLinksData>) => createQueryKey('getFactionLinks', options);

/**
 * Get faction links
 * Get all entities linked to a faction
 */
export const getFactionLinksOptions = (options: Options<GetFactionLinksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFactionLinks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFactionLinksQueryKey(options)
    });
};

/**
 * Get faction links
 * Get all entities linked to a faction
 */
export const useGetFactionLinksQuery = (options: Options<GetFactionLinksData>) => {
    return useQuery(getFactionLinksOptions(options));
};

/**
 * Create faction link
 * Link a faction to another entity (note, character, etc.)
 */
export const createFactionLinkMutation = (options?: Partial<Options<CreateFactionLinkData>>): UseMutationOptions<unknown, CreateFactionLinkError, Options<CreateFactionLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, CreateFactionLinkError, Options<CreateFactionLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createFactionLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listLocationsQueryKey = (options: Options<ListLocationsData>) => createQueryKey('listLocations', options);

/**
 * List locations
 * Get all locations in a game
 */
export const listLocationsOptions = (options: Options<ListLocationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listLocations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listLocationsQueryKey(options)
    });
};

/**
 * List locations
 * Get all locations in a game
 */
export const useListLocationsQuery = (options: Options<ListLocationsData>) => {
    return useQuery(listLocationsOptions(options));
};

/**
 * Create location
 * Create a new location in the game
 */
export const createLocationMutation = (options?: Partial<Options<CreateLocationData>>): UseMutationOptions<CreateLocationResponse, CreateLocationError, Options<CreateLocationData>> => {
    const mutationOptions: UseMutationOptions<CreateLocationResponse, CreateLocationError, Options<CreateLocationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createLocation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Logout user
 * Invalidate current session token
 */
export const logoutUserMutation = (options?: Partial<Options<LogoutUserData>>): UseMutationOptions<unknown, LogoutUserError, Options<LogoutUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, LogoutUserError, Options<LogoutUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await logoutUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Login user
 * Authenticate user with email/password or magic link token
 */
export const loginUserMutation = (options?: Partial<Options<LoginUserData>>): UseMutationOptions<LoginUserResponse, LoginUserError, Options<LoginUserData>> => {
    const mutationOptions: UseMutationOptions<LoginUserResponse, LoginUserError, Options<LoginUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete location link
 * Remove a link between a location and another entity
 */
export const deleteLocationLinkMutation = (options?: Partial<Options<DeleteLocationLinkData>>): UseMutationOptions<unknown, DeleteLocationLinkError, Options<DeleteLocationLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteLocationLinkError, Options<DeleteLocationLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteLocationLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a location link
 * Update link metadata between a location and another entity
 */
export const updateLocationLinkMutation = (options?: Partial<Options<UpdateLocationLinkData>>): UseMutationOptions<UpdateLocationLinkResponse, UpdateLocationLinkError, Options<UpdateLocationLinkData>> => {
    const mutationOptions: UseMutationOptions<UpdateLocationLinkResponse, UpdateLocationLinkError, Options<UpdateLocationLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateLocationLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listGameMembersQueryKey = (options: Options<ListGameMembersData>) => createQueryKey('listGameMembers', options);

/**
 * List game members
 * Retrieve a list of all members in the specified game
 */
export const listGameMembersOptions = (options: Options<ListGameMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listGameMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listGameMembersQueryKey(options)
    });
};

/**
 * List game members
 * Retrieve a list of all members in the specified game
 */
export const useListGameMembersQuery = (options: Options<ListGameMembersData>) => {
    return useQuery(listGameMembersOptions(options));
};

/**
 * Add a member to a game
 * Add a user as a member to the specified game
 */
export const addGameMemberMutation = (options?: Partial<Options<AddGameMemberData>>): UseMutationOptions<unknown, AddGameMemberError, Options<AddGameMemberData>> => {
    const mutationOptions: UseMutationOptions<unknown, AddGameMemberError, Options<AddGameMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addGameMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCharacterNotesTreeQueryKey = (options: Options<GetCharacterNotesTreeData>) => createQueryKey('getCharacterNotesTree', options);

/**
 * Get character notes tree
 * Get hierarchical tree of notes associated with a character
 */
export const getCharacterNotesTreeOptions = (options: Options<GetCharacterNotesTreeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCharacterNotesTree({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCharacterNotesTreeQueryKey(options)
    });
};

/**
 * Get character notes tree
 * Get hierarchical tree of notes associated with a character
 */
export const useGetCharacterNotesTreeQuery = (options: Options<GetCharacterNotesTreeData>) => {
    return useQuery(getCharacterNotesTreeOptions(options));
};

/**
 * Delete location
 * Delete a location from the game
 */
export const deleteLocationMutation = (options?: Partial<Options<DeleteLocationData>>): UseMutationOptions<unknown, DeleteLocationError, Options<DeleteLocationData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteLocationError, Options<DeleteLocationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteLocation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLocationQueryKey = (options: Options<GetLocationData>) => createQueryKey('getLocation', options);

/**
 * Get location
 * Get a specific location by ID
 */
export const getLocationOptions = (options: Options<GetLocationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLocation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLocationQueryKey(options)
    });
};

/**
 * Get location
 * Get a specific location by ID
 */
export const useGetLocationQuery = (options: Options<GetLocationData>) => {
    return useQuery(getLocationOptions(options));
};

/**
 * Update location
 * Update an existing location
 */
export const updateLocationMutation = (options?: Partial<Options<UpdateLocationData>>): UseMutationOptions<UpdateLocationResponse, UpdateLocationError, Options<UpdateLocationData>> => {
    const mutationOptions: UseMutationOptions<UpdateLocationResponse, UpdateLocationError, Options<UpdateLocationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateLocation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listFactionsQueryKey = (options: Options<ListFactionsData>) => createQueryKey('listFactions', options);

/**
 * List factions
 * Get all factions in a game
 */
export const listFactionsOptions = (options: Options<ListFactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listFactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listFactionsQueryKey(options)
    });
};

/**
 * List factions
 * Get all factions in a game
 */
export const useListFactionsQuery = (options: Options<ListFactionsData>) => {
    return useQuery(listFactionsOptions(options));
};

/**
 * Create faction
 * Create a new faction in the game
 */
export const createFactionMutation = (options?: Partial<Options<CreateFactionData>>): UseMutationOptions<CreateFactionResponse, CreateFactionError, Options<CreateFactionData>> => {
    const mutationOptions: UseMutationOptions<CreateFactionResponse, CreateFactionError, Options<CreateFactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createFaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete character link
 * Remove a link between a character and another entity
 */
export const deleteCharacterLinkMutation = (options?: Partial<Options<DeleteCharacterLinkData>>): UseMutationOptions<unknown, DeleteCharacterLinkError, Options<DeleteCharacterLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteCharacterLinkError, Options<DeleteCharacterLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCharacterLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a character link
 * Update link metadata between a character and another entity
 */
export const updateCharacterLinkMutation = (options?: Partial<Options<UpdateCharacterLinkData>>): UseMutationOptions<UpdateCharacterLinkResponse, UpdateCharacterLinkError, Options<UpdateCharacterLinkData>> => {
    const mutationOptions: UseMutationOptions<UpdateCharacterLinkResponse, UpdateCharacterLinkError, Options<UpdateCharacterLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCharacterLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listGameEntitiesQueryKey = (options: Options<ListGameEntitiesData>) => createQueryKey('listGameEntities', options);

/**
 * List game entities
 * Retrieve all entities (notes, characters, factions, locations, quests) for the specified game
 */
export const listGameEntitiesOptions = (options: Options<ListGameEntitiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listGameEntities({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listGameEntitiesQueryKey(options)
    });
};

/**
 * List game entities
 * Retrieve all entities (notes, characters, factions, locations, quests) for the specified game
 */
export const useListGameEntitiesQuery = (options: Options<ListGameEntitiesData>) => {
    return useQuery(listGameEntitiesOptions(options));
};

export const getNoteLinksQueryKey = (options: Options<GetNoteLinksData>) => createQueryKey('getNoteLinks', options);

/**
 * List note links
 * Retrieve all entities linked to a specific note
 */
export const getNoteLinksOptions = (options: Options<GetNoteLinksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNoteLinks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNoteLinksQueryKey(options)
    });
};

/**
 * List note links
 * Retrieve all entities linked to a specific note
 */
export const useGetNoteLinksQuery = (options: Options<GetNoteLinksData>) => {
    return useQuery(getNoteLinksOptions(options));
};

/**
 * Create a link
 * Create a link between a note and another entity (character, faction, location, quest)
 */
export const createNoteLinkMutation = (options?: Partial<Options<CreateNoteLinkData>>): UseMutationOptions<CreateNoteLinkResponse, CreateNoteLinkError, Options<CreateNoteLinkData>> => {
    const mutationOptions: UseMutationOptions<CreateNoteLinkResponse, CreateNoteLinkError, Options<CreateNoteLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createNoteLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLocationTreeQueryKey = (options: Options<GetLocationTreeData>) => createQueryKey('getLocationTree', options);

/**
 * Get location tree
 * Get hierarchical tree structure of all locations in a game
 */
export const getLocationTreeOptions = (options: Options<GetLocationTreeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLocationTree({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLocationTreeQueryKey(options)
    });
};

/**
 * Get location tree
 * Get hierarchical tree structure of all locations in a game
 */
export const useGetLocationTreeQuery = (options: Options<GetLocationTreeData>) => {
    return useQuery(getLocationTreeOptions(options));
};

/**
 * Remove character's primary faction
 * Remove a character's primary faction while preserving the CharacterFaction relationship record
 */
export const removeCharacterPrimaryFactionMutation = (options?: Partial<Options<RemoveCharacterPrimaryFactionData>>): UseMutationOptions<RemoveCharacterPrimaryFactionResponse, RemoveCharacterPrimaryFactionError, Options<RemoveCharacterPrimaryFactionData>> => {
    const mutationOptions: UseMutationOptions<RemoveCharacterPrimaryFactionResponse, RemoveCharacterPrimaryFactionError, Options<RemoveCharacterPrimaryFactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeCharacterPrimaryFaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCharacterPrimaryFactionQueryKey = (options: Options<GetCharacterPrimaryFactionData>) => createQueryKey('getCharacterPrimaryFaction', options);

/**
 * Get character's primary faction
 * Get the primary faction details for a character
 */
export const getCharacterPrimaryFactionOptions = (options: Options<GetCharacterPrimaryFactionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCharacterPrimaryFaction({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCharacterPrimaryFactionQueryKey(options)
    });
};

/**
 * Get character's primary faction
 * Get the primary faction details for a character
 */
export const useGetCharacterPrimaryFactionQuery = (options: Options<GetCharacterPrimaryFactionData>) => {
    return useQuery(getCharacterPrimaryFactionOptions(options));
};

/**
 * Set character's primary faction
 * Set or update a character's primary faction and role, automatically syncing with CharacterFaction relationship
 */
export const setCharacterPrimaryFactionMutation = (options?: Partial<Options<SetCharacterPrimaryFactionData>>): UseMutationOptions<SetCharacterPrimaryFactionResponse, SetCharacterPrimaryFactionError, Options<SetCharacterPrimaryFactionData>> => {
    const mutationOptions: UseMutationOptions<SetCharacterPrimaryFactionResponse, SetCharacterPrimaryFactionError, Options<SetCharacterPrimaryFactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setCharacterPrimaryFaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Pin character
 * Pin a character for quick access
 */
export const pinCharacterMutation = (options?: Partial<Options<PinCharacterData>>): UseMutationOptions<PinCharacterResponse, PinCharacterError, Options<PinCharacterData>> => {
    const mutationOptions: UseMutationOptions<PinCharacterResponse, PinCharacterError, Options<PinCharacterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pinCharacter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFactionMembersQueryKey = (options: Options<GetFactionMembersData>) => createQueryKey('getFactionMembers', options);

/**
 * Get faction members
 * Get all characters that are members of a faction (using member_of_faction_id)
 */
export const getFactionMembersOptions = (options: Options<GetFactionMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFactionMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFactionMembersQueryKey(options)
    });
};

/**
 * Get faction members
 * Get all characters that are members of a faction (using member_of_faction_id)
 */
export const useGetFactionMembersQuery = (options: Options<GetFactionMembersData>) => {
    return useQuery(getFactionMembersOptions(options));
};

export const listQuestsQueryKey = (options: Options<ListQuestsData>) => createQueryKey('listQuests', options);

/**
 * List quests
 * Get all quests in a game
 */
export const listQuestsOptions = (options: Options<ListQuestsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listQuests({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listQuestsQueryKey(options)
    });
};

/**
 * List quests
 * Get all quests in a game
 */
export const useListQuestsQuery = (options: Options<ListQuestsData>) => {
    return useQuery(listQuestsOptions(options));
};

/**
 * Create quest
 * Create a new quest in the game
 */
export const createQuestMutation = (options?: Partial<Options<CreateQuestData>>): UseMutationOptions<CreateQuestResponse, CreateQuestError, Options<CreateQuestData>> => {
    const mutationOptions: UseMutationOptions<CreateQuestResponse, CreateQuestError, Options<CreateQuestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createQuest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a note
 * Delete a specific note by its ID
 */
export const deleteNoteMutation = (options?: Partial<Options<DeleteNoteData>>): UseMutationOptions<unknown, DeleteNoteError, Options<DeleteNoteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteNoteError, Options<DeleteNoteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteNote({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNoteQueryKey = (options: Options<GetNoteData>) => createQueryKey('getNote', options);

/**
 * Get a note
 * Retrieve a specific note by its ID
 */
export const getNoteOptions = (options: Options<GetNoteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNote({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNoteQueryKey(options)
    });
};

/**
 * Get a note
 * Retrieve a specific note by its ID
 */
export const useGetNoteQuery = (options: Options<GetNoteData>) => {
    return useQuery(getNoteOptions(options));
};

/**
 * Update a note
 * Update a specific note with the provided parameters
 */
export const updateNoteMutation = (options?: Partial<Options<UpdateNoteData>>): UseMutationOptions<UpdateNoteResponse, UpdateNoteError, Options<UpdateNoteData>> => {
    const mutationOptions: UseMutationOptions<UpdateNoteResponse, UpdateNoteError, Options<UpdateNoteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateNote({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCharacterLinksQueryKey = (options: Options<GetCharacterLinksData>) => createQueryKey('getCharacterLinks', options);

/**
 * Get character links
 * Get all entities linked to a character
 */
export const getCharacterLinksOptions = (options: Options<GetCharacterLinksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCharacterLinks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCharacterLinksQueryKey(options)
    });
};

/**
 * Get character links
 * Get all entities linked to a character
 */
export const useGetCharacterLinksQuery = (options: Options<GetCharacterLinksData>) => {
    return useQuery(getCharacterLinksOptions(options));
};

/**
 * Create character link
 * Link a character to another entity (note, faction, etc.)
 */
export const createCharacterLinkMutation = (options?: Partial<Options<CreateCharacterLinkData>>): UseMutationOptions<unknown, CreateCharacterLinkError, Options<CreateCharacterLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, CreateCharacterLinkError, Options<CreateCharacterLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCharacterLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listCharactersQueryKey = (options: Options<ListCharactersData>) => createQueryKey('listCharacters', options);

/**
 * List characters
 * Get all characters in a game
 */
export const listCharactersOptions = (options: Options<ListCharactersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listCharacters({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listCharactersQueryKey(options)
    });
};

/**
 * List characters
 * Get all characters in a game
 */
export const useListCharactersQuery = (options: Options<ListCharactersData>) => {
    return useQuery(listCharactersOptions(options));
};

/**
 * Create character
 * Create a new character in the game
 */
export const createCharacterMutation = (options?: Partial<Options<CreateCharacterData>>): UseMutationOptions<CreateCharacterResponse, CreateCharacterError, Options<CreateCharacterData>> => {
    const mutationOptions: UseMutationOptions<CreateCharacterResponse, CreateCharacterError, Options<CreateCharacterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCharacter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a game
 * Delete a specific game by its ID
 */
export const deleteGameMutation = (options?: Partial<Options<DeleteGameData>>): UseMutationOptions<unknown, DeleteGameError, Options<DeleteGameData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteGameError, Options<DeleteGameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteGame({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGameQueryKey = (options: Options<GetGameData>) => createQueryKey('getGame', options);

/**
 * Get a game
 * Retrieve a specific game by its ID
 */
export const getGameOptions = (options: Options<GetGameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGame({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGameQueryKey(options)
    });
};

/**
 * Get a game
 * Retrieve a specific game by its ID
 */
export const useGetGameQuery = (options: Options<GetGameData>) => {
    return useQuery(getGameOptions(options));
};

/**
 * Update a game
 * Update a specific game with the provided parameters
 */
export const updateGameMutation = (options?: Partial<Options<UpdateGameData>>): UseMutationOptions<UpdateGameResponse, UpdateGameError, Options<UpdateGameData>> => {
    const mutationOptions: UseMutationOptions<UpdateGameResponse, UpdateGameError, Options<UpdateGameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateGame({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGameEntityTreeQueryKey = (options: Options<GetGameEntityTreeData>) => createQueryKey('getGameEntityTree', options);

/**
 * Get entity tree
 * Get comprehensive hierarchical tree of entity relationships within a game
 */
export const getGameEntityTreeOptions = (options: Options<GetGameEntityTreeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGameEntityTree({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGameEntityTreeQueryKey(options)
    });
};

/**
 * Get entity tree
 * Get comprehensive hierarchical tree of entity relationships within a game
 */
export const useGetGameEntityTreeQuery = (options: Options<GetGameEntityTreeData>) => {
    return useQuery(getGameEntityTreeOptions(options));
};

/**
 * Unpin character
 * Unpin a character
 */
export const unpinCharacterMutation = (options?: Partial<Options<UnpinCharacterData>>): UseMutationOptions<UnpinCharacterResponse, UnpinCharacterError, Options<UnpinCharacterData>> => {
    const mutationOptions: UseMutationOptions<UnpinCharacterResponse, UnpinCharacterError, Options<UnpinCharacterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unpinCharacter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Sign up new user
 * Register a new user with email and password
 */
export const signupUserMutation = (options?: Partial<Options<SignupUserData>>): UseMutationOptions<SignupUserResponse, SignupUserError, Options<SignupUserData>> => {
    const mutationOptions: UseMutationOptions<SignupUserResponse, SignupUserError, Options<SignupUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await signupUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAuthStatusQueryKey = (options?: Options<GetAuthStatusData>) => createQueryKey('getAuthStatus', options);

/**
 * Get auth status
 * Check if user is authenticated and get user info
 */
export const getAuthStatusOptions = (options?: Options<GetAuthStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuthStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuthStatusQueryKey(options)
    });
};

/**
 * Get auth status
 * Check if user is authenticated and get user info
 */
export const useGetAuthStatusQuery = (options?: Options<GetAuthStatusData>) => {
    return useQuery(getAuthStatusOptions(options));
};

/**
 * Delete quest
 * Delete a quest from the game
 */
export const deleteQuestMutation = (options?: Partial<Options<DeleteQuestData>>): UseMutationOptions<unknown, DeleteQuestError, Options<DeleteQuestData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteQuestError, Options<DeleteQuestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteQuest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getQuestQueryKey = (options: Options<GetQuestData>) => createQueryKey('getQuest', options);

/**
 * Get quest
 * Get a specific quest by ID
 */
export const getQuestOptions = (options: Options<GetQuestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getQuest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getQuestQueryKey(options)
    });
};

/**
 * Get quest
 * Get a specific quest by ID
 */
export const useGetQuestQuery = (options: Options<GetQuestData>) => {
    return useQuery(getQuestOptions(options));
};

/**
 * Update quest
 * Update an existing quest
 */
export const updateQuestMutation = (options?: Partial<Options<UpdateQuestData>>): UseMutationOptions<UpdateQuestResponse, UpdateQuestError, Options<UpdateQuestData>> => {
    const mutationOptions: UseMutationOptions<UpdateQuestResponse, UpdateQuestError, Options<UpdateQuestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateQuest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLocationLinksQueryKey = (options: Options<GetLocationLinksData>) => createQueryKey('getLocationLinks', options);

/**
 * Get location links
 * Get all entities linked to a location
 */
export const getLocationLinksOptions = (options: Options<GetLocationLinksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLocationLinks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLocationLinksQueryKey(options)
    });
};

/**
 * Get location links
 * Get all entities linked to a location
 */
export const useGetLocationLinksQuery = (options: Options<GetLocationLinksData>) => {
    return useQuery(getLocationLinksOptions(options));
};

/**
 * Create location link
 * Link a location to another entity (note, faction, etc.)
 */
export const createLocationLinkMutation = (options?: Partial<Options<CreateLocationLinkData>>): UseMutationOptions<unknown, CreateLocationLinkError, Options<CreateLocationLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, CreateLocationLinkError, Options<CreateLocationLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createLocationLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a link
 * Remove a link between a note and another entity
 */
export const deleteNoteLinkMutation = (options?: Partial<Options<DeleteNoteLinkData>>): UseMutationOptions<unknown, DeleteNoteLinkError, Options<DeleteNoteLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteNoteLinkError, Options<DeleteNoteLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteNoteLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a link
 * Update link metadata between a note and another entity
 */
export const updateNoteLinkMutation = (options?: Partial<Options<UpdateNoteLinkData>>): UseMutationOptions<UpdateNoteLinkResponse, UpdateNoteLinkError, Options<UpdateNoteLinkData>> => {
    const mutationOptions: UseMutationOptions<UpdateNoteLinkResponse, UpdateNoteLinkError, Options<UpdateNoteLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateNoteLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete character
 * Delete a character from the game
 */
export const deleteCharacterMutation = (options?: Partial<Options<DeleteCharacterData>>): UseMutationOptions<unknown, DeleteCharacterError, Options<DeleteCharacterData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteCharacterError, Options<DeleteCharacterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCharacter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCharacterQueryKey = (options: Options<GetCharacterData>) => createQueryKey('getCharacter', options);

/**
 * Get character
 * Get a specific character by ID
 */
export const getCharacterOptions = (options: Options<GetCharacterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCharacter({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCharacterQueryKey(options)
    });
};

/**
 * Get character
 * Get a specific character by ID
 */
export const useGetCharacterQuery = (options: Options<GetCharacterData>) => {
    return useQuery(getCharacterOptions(options));
};

/**
 * Update character
 * Update an existing character
 */
export const updateCharacterMutation = (options?: Partial<Options<UpdateCharacterData>>): UseMutationOptions<UpdateCharacterResponse, UpdateCharacterError, Options<UpdateCharacterData>> => {
    const mutationOptions: UseMutationOptions<UpdateCharacterResponse, UpdateCharacterError, Options<UpdateCharacterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCharacter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getQuestLinksQueryKey = (options: Options<GetQuestLinksData>) => createQueryKey('getQuestLinks', options);

/**
 * Get quest links
 * Get all entities linked to a quest
 */
export const getQuestLinksOptions = (options: Options<GetQuestLinksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getQuestLinks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getQuestLinksQueryKey(options)
    });
};

/**
 * Get quest links
 * Get all entities linked to a quest
 */
export const useGetQuestLinksQuery = (options: Options<GetQuestLinksData>) => {
    return useQuery(getQuestLinksOptions(options));
};

/**
 * Create quest link
 * Link a quest to another entity (note, character, faction, location)
 */
export const createQuestLinkMutation = (options?: Partial<Options<CreateQuestLinkData>>): UseMutationOptions<unknown, CreateQuestLinkError, Options<CreateQuestLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, CreateQuestLinkError, Options<CreateQuestLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createQuestLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete faction
 * Delete a faction from the game
 */
export const deleteFactionMutation = (options?: Partial<Options<DeleteFactionData>>): UseMutationOptions<unknown, DeleteFactionError, Options<DeleteFactionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteFactionError, Options<DeleteFactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteFaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFactionQueryKey = (options: Options<GetFactionData>) => createQueryKey('getFaction', options);

/**
 * Get faction
 * Get a specific faction by ID
 */
export const getFactionOptions = (options: Options<GetFactionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFaction({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFactionQueryKey(options)
    });
};

/**
 * Get faction
 * Get a specific faction by ID
 */
export const useGetFactionQuery = (options: Options<GetFactionData>) => {
    return useQuery(getFactionOptions(options));
};

/**
 * Update faction
 * Update an existing faction
 */
export const updateFactionMutation = (options?: Partial<Options<UpdateFactionData>>): UseMutationOptions<UpdateFactionResponse, UpdateFactionError, Options<UpdateFactionData>> => {
    const mutationOptions: UseMutationOptions<UpdateFactionResponse, UpdateFactionError, Options<UpdateFactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateFaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a member from a game
 * Remove a user from the specified game
 */
export const removeGameMemberMutation = (options?: Partial<Options<RemoveGameMemberData>>): UseMutationOptions<unknown, RemoveGameMemberError, Options<RemoveGameMemberData>> => {
    const mutationOptions: UseMutationOptions<unknown, RemoveGameMemberError, Options<RemoveGameMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeGameMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete faction link
 * Remove a link between a faction and another entity
 */
export const deleteFactionLinkMutation = (options?: Partial<Options<DeleteFactionLinkData>>): UseMutationOptions<unknown, DeleteFactionLinkError, Options<DeleteFactionLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteFactionLinkError, Options<DeleteFactionLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteFactionLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a faction link
 * Update link metadata between a faction and another entity
 */
export const updateFactionLinkMutation = (options?: Partial<Options<UpdateFactionLinkData>>): UseMutationOptions<UpdateFactionLinkResponse, UpdateFactionLinkError, Options<UpdateFactionLinkData>> => {
    const mutationOptions: UseMutationOptions<UpdateFactionLinkResponse, UpdateFactionLinkError, Options<UpdateFactionLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateFactionLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listNotesQueryKey = (options: Options<ListNotesData>) => createQueryKey('listNotes', options);

/**
 * List notes
 * Retrieve all notes for a specific game
 */
export const listNotesOptions = (options: Options<ListNotesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listNotes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listNotesQueryKey(options)
    });
};

/**
 * List notes
 * Retrieve all notes for a specific game
 */
export const useListNotesQuery = (options: Options<ListNotesData>) => {
    return useQuery(listNotesOptions(options));
};

/**
 * Create a note
 * Create a new note for the specified game
 */
export const createNoteMutation = (options?: Partial<Options<CreateNoteData>>): UseMutationOptions<CreateNoteResponse, CreateNoteError, Options<CreateNoteData>> => {
    const mutationOptions: UseMutationOptions<CreateNoteResponse, CreateNoteError, Options<CreateNoteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createNote({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listPinnedEntitiesQueryKey = (options: Options<ListPinnedEntitiesData>) => createQueryKey('listPinnedEntities', options);

/**
 * Get all pinned entities
 * Get all pinned entities (characters, notes, factions, locations, quests) for a game
 */
export const listPinnedEntitiesOptions = (options: Options<ListPinnedEntitiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listPinnedEntities({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listPinnedEntitiesQueryKey(options)
    });
};

/**
 * Get all pinned entities
 * Get all pinned entities (characters, notes, factions, locations, quests) for a game
 */
export const useListPinnedEntitiesQuery = (options: Options<ListPinnedEntitiesData>) => {
    return useQuery(listPinnedEntitiesOptions(options));
};

export const listGamesQueryKey = (options?: Options<ListGamesData>) => createQueryKey('listGames', options);

/**
 * List all games
 * Retrieve a list of all games accessible to the current user
 */
export const listGamesOptions = (options?: Options<ListGamesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listGames({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listGamesQueryKey(options)
    });
};

/**
 * List all games
 * Retrieve a list of all games accessible to the current user
 */
export const useListGamesQuery = (options?: Options<ListGamesData>) => {
    return useQuery(listGamesOptions(options));
};

/**
 * Create a new game
 * Create a new game with the provided parameters
 */
export const createGameMutation = (options?: Partial<Options<CreateGameData>>): UseMutationOptions<CreateGameResponse, CreateGameError, Options<CreateGameData>> => {
    const mutationOptions: UseMutationOptions<CreateGameResponse, CreateGameError, Options<CreateGameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createGame({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete quest link
 * Remove a link between a quest and another entity
 */
export const deleteQuestLinkMutation = (options?: Partial<Options<DeleteQuestLinkData>>): UseMutationOptions<unknown, DeleteQuestLinkError, Options<DeleteQuestLinkData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteQuestLinkError, Options<DeleteQuestLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteQuestLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a quest link
 * Update link metadata between a quest and another entity
 */
export const updateQuestLinkMutation = (options?: Partial<Options<UpdateQuestLinkData>>): UseMutationOptions<UpdateQuestLinkResponse, UpdateQuestLinkError, Options<UpdateQuestLinkData>> => {
    const mutationOptions: UseMutationOptions<UpdateQuestLinkResponse, UpdateQuestLinkError, Options<UpdateQuestLinkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateQuestLink({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getQuestTreeQueryKey = (options: Options<GetQuestTreeData>) => createQueryKey('getQuestTree', options);

/**
 * Get quest tree
 * Get hierarchical tree structure of all quests in a game
 */
export const getQuestTreeOptions = (options: Options<GetQuestTreeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getQuestTree({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getQuestTreeQueryKey(options)
    });
};

/**
 * Get quest tree
 * Get hierarchical tree structure of all quests in a game
 */
export const useGetQuestTreeQuery = (options: Options<GetQuestTreeData>) => {
    return useQuery(getQuestTreeOptions(options));
};
</file>

<file path="src/api/sdk.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type { GetFactionLinksData, GetFactionLinksResponses, GetFactionLinksErrors, CreateFactionLinkData, CreateFactionLinkResponses, CreateFactionLinkErrors, ListLocationsData, ListLocationsResponses, ListLocationsErrors, CreateLocationData, CreateLocationResponses, CreateLocationErrors, LogoutUserData, LogoutUserResponses, LogoutUserErrors, LoginUserData, LoginUserResponses, LoginUserErrors, DeleteLocationLinkData, DeleteLocationLinkResponses, DeleteLocationLinkErrors, UpdateLocationLinkData, UpdateLocationLinkResponses, UpdateLocationLinkErrors, ListGameMembersData, ListGameMembersResponses, ListGameMembersErrors, AddGameMemberData, AddGameMemberResponses, AddGameMemberErrors, GetCharacterNotesTreeData, GetCharacterNotesTreeResponses, GetCharacterNotesTreeErrors, DeleteLocationData, DeleteLocationResponses, DeleteLocationErrors, GetLocationData, GetLocationResponses, GetLocationErrors, UpdateLocationData, UpdateLocationResponses, UpdateLocationErrors, ListFactionsData, ListFactionsResponses, ListFactionsErrors, CreateFactionData, CreateFactionResponses, CreateFactionErrors, DeleteCharacterLinkData, DeleteCharacterLinkResponses, DeleteCharacterLinkErrors, UpdateCharacterLinkData, UpdateCharacterLinkResponses, UpdateCharacterLinkErrors, ListGameEntitiesData, ListGameEntitiesResponses, ListGameEntitiesErrors, GetNoteLinksData, GetNoteLinksResponses, GetNoteLinksErrors, CreateNoteLinkData, CreateNoteLinkResponses, CreateNoteLinkErrors, GetLocationTreeData, GetLocationTreeResponses, GetLocationTreeErrors, RemoveCharacterPrimaryFactionData, RemoveCharacterPrimaryFactionResponses, RemoveCharacterPrimaryFactionErrors, GetCharacterPrimaryFactionData, GetCharacterPrimaryFactionResponses, GetCharacterPrimaryFactionErrors, SetCharacterPrimaryFactionData, SetCharacterPrimaryFactionResponses, SetCharacterPrimaryFactionErrors, PinCharacterData, PinCharacterResponses, PinCharacterErrors, GetFactionMembersData, GetFactionMembersResponses, GetFactionMembersErrors, ListQuestsData, ListQuestsResponses, ListQuestsErrors, CreateQuestData, CreateQuestResponses, CreateQuestErrors, DeleteNoteData, DeleteNoteResponses, DeleteNoteErrors, GetNoteData, GetNoteResponses, GetNoteErrors, UpdateNoteData, UpdateNoteResponses, UpdateNoteErrors, GetCharacterLinksData, GetCharacterLinksResponses, GetCharacterLinksErrors, CreateCharacterLinkData, CreateCharacterLinkResponses, CreateCharacterLinkErrors, ListCharactersData, ListCharactersResponses, ListCharactersErrors, CreateCharacterData, CreateCharacterResponses, CreateCharacterErrors, DeleteGameData, DeleteGameResponses, DeleteGameErrors, GetGameData, GetGameResponses, GetGameErrors, UpdateGameData, UpdateGameResponses, UpdateGameErrors, GetGameEntityTreeData, GetGameEntityTreeResponses, GetGameEntityTreeErrors, UnpinCharacterData, UnpinCharacterResponses, UnpinCharacterErrors, SignupUserData, SignupUserResponses, SignupUserErrors, GetAuthStatusData, GetAuthStatusResponses, GetAuthStatusErrors, DeleteQuestData, DeleteQuestResponses, DeleteQuestErrors, GetQuestData, GetQuestResponses, GetQuestErrors, UpdateQuestData, UpdateQuestResponses, UpdateQuestErrors, GetLocationLinksData, GetLocationLinksResponses, GetLocationLinksErrors, CreateLocationLinkData, CreateLocationLinkResponses, CreateLocationLinkErrors, DeleteNoteLinkData, DeleteNoteLinkResponses, DeleteNoteLinkErrors, UpdateNoteLinkData, UpdateNoteLinkResponses, UpdateNoteLinkErrors, DeleteCharacterData, DeleteCharacterResponses, DeleteCharacterErrors, GetCharacterData, GetCharacterResponses, GetCharacterErrors, UpdateCharacterData, UpdateCharacterResponses, UpdateCharacterErrors, GetQuestLinksData, GetQuestLinksResponses, GetQuestLinksErrors, CreateQuestLinkData, CreateQuestLinkResponses, CreateQuestLinkErrors, DeleteFactionData, DeleteFactionResponses, DeleteFactionErrors, GetFactionData, GetFactionResponses, GetFactionErrors, UpdateFactionData, UpdateFactionResponses, UpdateFactionErrors, RemoveGameMemberData, RemoveGameMemberResponses, RemoveGameMemberErrors, DeleteFactionLinkData, DeleteFactionLinkResponses, DeleteFactionLinkErrors, UpdateFactionLinkData, UpdateFactionLinkResponses, UpdateFactionLinkErrors, ListNotesData, ListNotesResponses, ListNotesErrors, CreateNoteData, CreateNoteResponses, CreateNoteErrors, ListPinnedEntitiesData, ListPinnedEntitiesResponses, ListPinnedEntitiesErrors, ListGamesData, ListGamesResponses, ListGamesErrors, CreateGameData, CreateGameResponses, CreateGameErrors, DeleteQuestLinkData, DeleteQuestLinkResponses, DeleteQuestLinkErrors, UpdateQuestLinkData, UpdateQuestLinkResponses, UpdateQuestLinkErrors, GetQuestTreeData, GetQuestTreeResponses, GetQuestTreeErrors } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get faction links
 * Get all entities linked to a faction
 */
export const getFactionLinks = <ThrowOnError extends boolean = false>(options: Options<GetFactionLinksData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFactionLinksResponses, GetFactionLinksErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions/{faction_id}/links',
        ...options
    });
};

/**
 * Create faction link
 * Link a faction to another entity (note, character, etc.)
 */
export const createFactionLink = <ThrowOnError extends boolean = false>(options: Options<CreateFactionLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateFactionLinkResponses, CreateFactionLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions/{faction_id}/links',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List locations
 * Get all locations in a game
 */
export const listLocations = <ThrowOnError extends boolean = false>(options: Options<ListLocationsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListLocationsResponses, ListLocationsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations',
        ...options
    });
};

/**
 * Create location
 * Create a new location in the game
 */
export const createLocation = <ThrowOnError extends boolean = false>(options: Options<CreateLocationData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateLocationResponses, CreateLocationErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Logout user
 * Invalidate current session token
 */
export const logoutUser = <ThrowOnError extends boolean = false>(options?: Options<LogoutUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<LogoutUserResponses, LogoutUserErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/auth/logout',
        ...options
    });
};

/**
 * Login user
 * Authenticate user with email/password or magic link token
 */
export const loginUser = <ThrowOnError extends boolean = false>(options: Options<LoginUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<LoginUserResponses, LoginUserErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/auth/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete location link
 * Remove a link between a location and another entity
 */
export const deleteLocationLink = <ThrowOnError extends boolean = false>(options: Options<DeleteLocationLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteLocationLinkResponses, DeleteLocationLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations/{location_id}/links/{entity_type}/{entity_id}',
        ...options
    });
};

/**
 * Update a location link
 * Update link metadata between a location and another entity
 */
export const updateLocationLink = <ThrowOnError extends boolean = false>(options: Options<UpdateLocationLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateLocationLinkResponses, UpdateLocationLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations/{location_id}/links/{entity_type}/{entity_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List game members
 * Retrieve a list of all members in the specified game
 */
export const listGameMembers = <ThrowOnError extends boolean = false>(options: Options<ListGameMembersData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListGameMembersResponses, ListGameMembersErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/members',
        ...options
    });
};

/**
 * Add a member to a game
 * Add a user as a member to the specified game
 */
export const addGameMember = <ThrowOnError extends boolean = false>(options: Options<AddGameMemberData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<AddGameMemberResponses, AddGameMemberErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/members',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get character notes tree
 * Get hierarchical tree of notes associated with a character
 */
export const getCharacterNotesTree = <ThrowOnError extends boolean = false>(options: Options<GetCharacterNotesTreeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCharacterNotesTreeResponses, GetCharacterNotesTreeErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{id}/notes/tree',
        ...options
    });
};

/**
 * Delete location
 * Delete a location from the game
 */
export const deleteLocation = <ThrowOnError extends boolean = false>(options: Options<DeleteLocationData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteLocationResponses, DeleteLocationErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations/{id}',
        ...options
    });
};

/**
 * Get location
 * Get a specific location by ID
 */
export const getLocation = <ThrowOnError extends boolean = false>(options: Options<GetLocationData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetLocationResponses, GetLocationErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations/{id}',
        ...options
    });
};

/**
 * Update location
 * Update an existing location
 */
export const updateLocation = <ThrowOnError extends boolean = false>(options: Options<UpdateLocationData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateLocationResponses, UpdateLocationErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List factions
 * Get all factions in a game
 */
export const listFactions = <ThrowOnError extends boolean = false>(options: Options<ListFactionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListFactionsResponses, ListFactionsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions',
        ...options
    });
};

/**
 * Create faction
 * Create a new faction in the game
 */
export const createFaction = <ThrowOnError extends boolean = false>(options: Options<CreateFactionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateFactionResponses, CreateFactionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete character link
 * Remove a link between a character and another entity
 */
export const deleteCharacterLink = <ThrowOnError extends boolean = false>(options: Options<DeleteCharacterLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteCharacterLinkResponses, DeleteCharacterLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{character_id}/links/{entity_type}/{entity_id}',
        ...options
    });
};

/**
 * Update a character link
 * Update link metadata between a character and another entity
 */
export const updateCharacterLink = <ThrowOnError extends boolean = false>(options: Options<UpdateCharacterLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateCharacterLinkResponses, UpdateCharacterLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{character_id}/links/{entity_type}/{entity_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List game entities
 * Retrieve all entities (notes, characters, factions, locations, quests) for the specified game
 */
export const listGameEntities = <ThrowOnError extends boolean = false>(options: Options<ListGameEntitiesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListGameEntitiesResponses, ListGameEntitiesErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/links',
        ...options
    });
};

/**
 * List note links
 * Retrieve all entities linked to a specific note
 */
export const getNoteLinks = <ThrowOnError extends boolean = false>(options: Options<GetNoteLinksData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetNoteLinksResponses, GetNoteLinksErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/notes/{note_id}/links',
        ...options
    });
};

/**
 * Create a link
 * Create a link between a note and another entity (character, faction, location, quest)
 */
export const createNoteLink = <ThrowOnError extends boolean = false>(options: Options<CreateNoteLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateNoteLinkResponses, CreateNoteLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/notes/{note_id}/links',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get location tree
 * Get hierarchical tree structure of all locations in a game
 */
export const getLocationTree = <ThrowOnError extends boolean = false>(options: Options<GetLocationTreeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetLocationTreeResponses, GetLocationTreeErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations/tree',
        ...options
    });
};

/**
 * Remove character's primary faction
 * Remove a character's primary faction while preserving the CharacterFaction relationship record
 */
export const removeCharacterPrimaryFaction = <ThrowOnError extends boolean = false>(options: Options<RemoveCharacterPrimaryFactionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<RemoveCharacterPrimaryFactionResponses, RemoveCharacterPrimaryFactionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{character_id}/primary-faction',
        ...options
    });
};

/**
 * Get character's primary faction
 * Get the primary faction details for a character
 */
export const getCharacterPrimaryFaction = <ThrowOnError extends boolean = false>(options: Options<GetCharacterPrimaryFactionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCharacterPrimaryFactionResponses, GetCharacterPrimaryFactionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{character_id}/primary-faction',
        ...options
    });
};

/**
 * Set character's primary faction
 * Set or update a character's primary faction and role, automatically syncing with CharacterFaction relationship
 */
export const setCharacterPrimaryFaction = <ThrowOnError extends boolean = false>(options: Options<SetCharacterPrimaryFactionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SetCharacterPrimaryFactionResponses, SetCharacterPrimaryFactionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{character_id}/primary-faction',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Pin character
 * Pin a character for quick access
 */
export const pinCharacter = <ThrowOnError extends boolean = false>(options: Options<PinCharacterData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<PinCharacterResponses, PinCharacterErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{character_id}/pin',
        ...options
    });
};

/**
 * Get faction members
 * Get all characters that are members of a faction (using member_of_faction_id)
 */
export const getFactionMembers = <ThrowOnError extends boolean = false>(options: Options<GetFactionMembersData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFactionMembersResponses, GetFactionMembersErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions/{faction_id}/members',
        ...options
    });
};

/**
 * List quests
 * Get all quests in a game
 */
export const listQuests = <ThrowOnError extends boolean = false>(options: Options<ListQuestsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListQuestsResponses, ListQuestsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests',
        ...options
    });
};

/**
 * Create quest
 * Create a new quest in the game
 */
export const createQuest = <ThrowOnError extends boolean = false>(options: Options<CreateQuestData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateQuestResponses, CreateQuestErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a note
 * Delete a specific note by its ID
 */
export const deleteNote = <ThrowOnError extends boolean = false>(options: Options<DeleteNoteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteNoteResponses, DeleteNoteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/notes/{id}',
        ...options
    });
};

/**
 * Get a note
 * Retrieve a specific note by its ID
 */
export const getNote = <ThrowOnError extends boolean = false>(options: Options<GetNoteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetNoteResponses, GetNoteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/notes/{id}',
        ...options
    });
};

/**
 * Update a note
 * Update a specific note with the provided parameters
 */
export const updateNote = <ThrowOnError extends boolean = false>(options: Options<UpdateNoteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateNoteResponses, UpdateNoteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/notes/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get character links
 * Get all entities linked to a character
 */
export const getCharacterLinks = <ThrowOnError extends boolean = false>(options: Options<GetCharacterLinksData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCharacterLinksResponses, GetCharacterLinksErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{character_id}/links',
        ...options
    });
};

/**
 * Create character link
 * Link a character to another entity (note, faction, etc.)
 */
export const createCharacterLink = <ThrowOnError extends boolean = false>(options: Options<CreateCharacterLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateCharacterLinkResponses, CreateCharacterLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{character_id}/links',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List characters
 * Get all characters in a game
 */
export const listCharacters = <ThrowOnError extends boolean = false>(options: Options<ListCharactersData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListCharactersResponses, ListCharactersErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters',
        ...options
    });
};

/**
 * Create character
 * Create a new character in the game
 */
export const createCharacter = <ThrowOnError extends boolean = false>(options: Options<CreateCharacterData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateCharacterResponses, CreateCharacterErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a game
 * Delete a specific game by its ID
 */
export const deleteGame = <ThrowOnError extends boolean = false>(options: Options<DeleteGameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteGameResponses, DeleteGameErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{id}',
        ...options
    });
};

/**
 * Get a game
 * Retrieve a specific game by its ID
 */
export const getGame = <ThrowOnError extends boolean = false>(options: Options<GetGameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGameResponses, GetGameErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{id}',
        ...options
    });
};

/**
 * Update a game
 * Update a specific game with the provided parameters
 */
export const updateGame = <ThrowOnError extends boolean = false>(options: Options<UpdateGameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateGameResponses, UpdateGameErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get entity tree
 * Get comprehensive hierarchical tree of entity relationships within a game
 */
export const getGameEntityTree = <ThrowOnError extends boolean = false>(options: Options<GetGameEntityTreeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGameEntityTreeResponses, GetGameEntityTreeErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/tree',
        ...options
    });
};

/**
 * Unpin character
 * Unpin a character
 */
export const unpinCharacter = <ThrowOnError extends boolean = false>(options: Options<UnpinCharacterData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UnpinCharacterResponses, UnpinCharacterErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{character_id}/unpin',
        ...options
    });
};

/**
 * Sign up new user
 * Register a new user with email and password
 */
export const signupUser = <ThrowOnError extends boolean = false>(options: Options<SignupUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SignupUserResponses, SignupUserErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/auth/signup',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get auth status
 * Check if user is authenticated and get user info
 */
export const getAuthStatus = <ThrowOnError extends boolean = false>(options?: Options<GetAuthStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAuthStatusResponses, GetAuthStatusErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/auth/status',
        ...options
    });
};

/**
 * Delete quest
 * Delete a quest from the game
 */
export const deleteQuest = <ThrowOnError extends boolean = false>(options: Options<DeleteQuestData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteQuestResponses, DeleteQuestErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests/{id}',
        ...options
    });
};

/**
 * Get quest
 * Get a specific quest by ID
 */
export const getQuest = <ThrowOnError extends boolean = false>(options: Options<GetQuestData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetQuestResponses, GetQuestErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests/{id}',
        ...options
    });
};

/**
 * Update quest
 * Update an existing quest
 */
export const updateQuest = <ThrowOnError extends boolean = false>(options: Options<UpdateQuestData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateQuestResponses, UpdateQuestErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get location links
 * Get all entities linked to a location
 */
export const getLocationLinks = <ThrowOnError extends boolean = false>(options: Options<GetLocationLinksData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetLocationLinksResponses, GetLocationLinksErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations/{location_id}/links',
        ...options
    });
};

/**
 * Create location link
 * Link a location to another entity (note, faction, etc.)
 */
export const createLocationLink = <ThrowOnError extends boolean = false>(options: Options<CreateLocationLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateLocationLinkResponses, CreateLocationLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/locations/{location_id}/links',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a link
 * Remove a link between a note and another entity
 */
export const deleteNoteLink = <ThrowOnError extends boolean = false>(options: Options<DeleteNoteLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteNoteLinkResponses, DeleteNoteLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/notes/{note_id}/links/{entity_type}/{entity_id}',
        ...options
    });
};

/**
 * Update a link
 * Update link metadata between a note and another entity
 */
export const updateNoteLink = <ThrowOnError extends boolean = false>(options: Options<UpdateNoteLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateNoteLinkResponses, UpdateNoteLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/notes/{note_id}/links/{entity_type}/{entity_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete character
 * Delete a character from the game
 */
export const deleteCharacter = <ThrowOnError extends boolean = false>(options: Options<DeleteCharacterData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteCharacterResponses, DeleteCharacterErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{id}',
        ...options
    });
};

/**
 * Get character
 * Get a specific character by ID
 */
export const getCharacter = <ThrowOnError extends boolean = false>(options: Options<GetCharacterData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCharacterResponses, GetCharacterErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{id}',
        ...options
    });
};

/**
 * Update character
 * Update an existing character
 */
export const updateCharacter = <ThrowOnError extends boolean = false>(options: Options<UpdateCharacterData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateCharacterResponses, UpdateCharacterErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/characters/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get quest links
 * Get all entities linked to a quest
 */
export const getQuestLinks = <ThrowOnError extends boolean = false>(options: Options<GetQuestLinksData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetQuestLinksResponses, GetQuestLinksErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests/{quest_id}/links',
        ...options
    });
};

/**
 * Create quest link
 * Link a quest to another entity (note, character, faction, location)
 */
export const createQuestLink = <ThrowOnError extends boolean = false>(options: Options<CreateQuestLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateQuestLinkResponses, CreateQuestLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests/{quest_id}/links',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete faction
 * Delete a faction from the game
 */
export const deleteFaction = <ThrowOnError extends boolean = false>(options: Options<DeleteFactionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteFactionResponses, DeleteFactionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions/{id}',
        ...options
    });
};

/**
 * Get faction
 * Get a specific faction by ID
 */
export const getFaction = <ThrowOnError extends boolean = false>(options: Options<GetFactionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFactionResponses, GetFactionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions/{id}',
        ...options
    });
};

/**
 * Update faction
 * Update an existing faction
 */
export const updateFaction = <ThrowOnError extends boolean = false>(options: Options<UpdateFactionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateFactionResponses, UpdateFactionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Remove a member from a game
 * Remove a user from the specified game
 */
export const removeGameMember = <ThrowOnError extends boolean = false>(options: Options<RemoveGameMemberData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<RemoveGameMemberResponses, RemoveGameMemberErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/members/{user_id}',
        ...options
    });
};

/**
 * Delete faction link
 * Remove a link between a faction and another entity
 */
export const deleteFactionLink = <ThrowOnError extends boolean = false>(options: Options<DeleteFactionLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteFactionLinkResponses, DeleteFactionLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions/{faction_id}/links/{entity_type}/{entity_id}',
        ...options
    });
};

/**
 * Update a faction link
 * Update link metadata between a faction and another entity
 */
export const updateFactionLink = <ThrowOnError extends boolean = false>(options: Options<UpdateFactionLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateFactionLinkResponses, UpdateFactionLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/factions/{faction_id}/links/{entity_type}/{entity_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List notes
 * Retrieve all notes for a specific game
 */
export const listNotes = <ThrowOnError extends boolean = false>(options: Options<ListNotesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListNotesResponses, ListNotesErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/notes',
        ...options
    });
};

/**
 * Create a note
 * Create a new note for the specified game
 */
export const createNote = <ThrowOnError extends boolean = false>(options: Options<CreateNoteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateNoteResponses, CreateNoteErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/notes',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get all pinned entities
 * Get all pinned entities (characters, notes, factions, locations, quests) for a game
 */
export const listPinnedEntities = <ThrowOnError extends boolean = false>(options: Options<ListPinnedEntitiesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListPinnedEntitiesResponses, ListPinnedEntitiesErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/pinned',
        ...options
    });
};

/**
 * List all games
 * Retrieve a list of all games accessible to the current user
 */
export const listGames = <ThrowOnError extends boolean = false>(options?: Options<ListGamesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ListGamesResponses, ListGamesErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games',
        ...options
    });
};

/**
 * Create a new game
 * Create a new game with the provided parameters
 */
export const createGame = <ThrowOnError extends boolean = false>(options: Options<CreateGameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateGameResponses, CreateGameErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete quest link
 * Remove a link between a quest and another entity
 */
export const deleteQuestLink = <ThrowOnError extends boolean = false>(options: Options<DeleteQuestLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteQuestLinkResponses, DeleteQuestLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests/{quest_id}/links/{entity_type}/{entity_id}',
        ...options
    });
};

/**
 * Update a quest link
 * Update link metadata between a quest and another entity
 */
export const updateQuestLink = <ThrowOnError extends boolean = false>(options: Options<UpdateQuestLinkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateQuestLinkResponses, UpdateQuestLinkErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests/{quest_id}/links/{entity_type}/{entity_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get quest tree
 * Get hierarchical tree structure of all quests in a game
 */
export const getQuestTree = <ThrowOnError extends boolean = false>(options: Options<GetQuestTreeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetQuestTreeResponses, GetQuestTreeErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/api/games/{game_id}/quests/tree',
        ...options
    });
};
</file>

<file path="src/components/forms/smart-factory.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: factory component */

import type { UseMutationOptions } from "@tanstack/react-query";
import { useMutation } from "@tanstack/react-query";
import { CheckCircle, XCircle } from "lucide-react";

import { z } from "zod";
import type { TDataShape } from "~/api/client/types.gen";
import type { Options } from "~/api/sdk.gen";
import { Button } from "~/components/ui/button";
import { createFormHook } from "~/components/ui/form-tanstack";
import { type ApiError, type FieldConfig, FormFieldControl } from "./factory-v2";
import { extractDefaultValues, generateFieldsFromSchema } from "./type-utils";

const { useAppForm } = createFormHook();

// ===================================
// SMART FACTORY TYPES
// ===================================

export interface SmartFormOptions<TData, TError, TMutationData extends TDataShape> {
	/** Generated mutation function from OpenAPI */
	mutation: (
		options?: Partial<Options<TMutationData>>,
	) => UseMutationOptions<TData, TError, Options<TMutationData>>;
	/** Zod schema for validation */
	schema: z.ZodObject<z.ZodRawShape>;
	/** Entity name for API request body wrapping */
	entityName: string;
	/** Success callback */
	onSuccess?: (data: TData) => void;
	/** Field configuration overrides (use null to exclude a field) */
	fieldOverrides?: Partial<Record<string, Partial<FieldConfig> | null>>;
	/** CSS class for form container */
	className?: string;
	/** Custom submit button text */
	submitText?: string;
	/** Initial values for form fields (for edit forms) */
	initialValues?: Record<string, any>;
}

export interface HookFormOptions<TData, TError, TMutationData extends TDataShape> {
	/** Generated mutation function from OpenAPI */
	mutation: (
		options?: Partial<Options<TMutationData>>,
	) => UseMutationOptions<TData, TError, Options<TMutationData>>;
	/** Zod schema for validation */
	schema: z.ZodObject<z.ZodRawShape>;
	/** Entity name for API request body wrapping */
	entityName: string;
	/** Success callback */
	onSuccess?: (data: TData) => void;
	/** Initial values for form fields (for edit forms) */
	initialValues?: Record<string, any>;
}

// ===================================
// SMART FORM FACTORY
// ===================================

/**
 * Creates a form component with automatic field generation from Zod schema
 * Eliminates the need for manual field configuration and default values
 */
export function createSmartForm<TData, TError, TMutationData extends TDataShape>({
	mutation,
	schema,
	entityName,
	onSuccess,
	fieldOverrides = {},
	className = "space-y-6",
	submitText = "Submit",
	initialValues,
}: SmartFormOptions<TData, TError, TMutationData>) {
	return function SmartFormComponent() {
		// Auto-generate fields from schema
		const fields = generateFieldsFromSchema(schema, fieldOverrides);
		const defaultValues = processInitialValues(
			initialValues ?? extractDefaultValues(schema),
			fields,
		);

		const mutationInstance = useMutation({
			...mutation(),
			onSuccess: (data) => {
				onSuccess?.(data);
				form.reset();
			},
		});

		const form = useAppForm({
			defaultValues,
			onSubmit: async ({ value }) => {
				try {
					// Convert editor objects to strings before validation
					const processedValue = processFormValuesForSubmission(value, fields);

					// Auto-extend schema to include _plain_text fields for editor fields
					const extendedSchema = fields.reduce((acc, field) => {
						if (field.type === "editor") {
							return acc.extend({
								[`${field.name}_plain_text`]: z.string().optional(),
							});
						}
						return acc;
					}, schema);

					const validatedData = extendedSchema.parse(processedValue);
					const fullData = {
						body: { [entityName]: validatedData },
					} as unknown as Options<TMutationData>;

					await mutationInstance.mutateAsync(fullData);
				} catch (error) {
					if (error instanceof z.ZodError) {
						console.error("Validation error:", error.issues);
						// Set field-specific validation errors
						for (const issue of error.issues) {
							if (issue.path.length > 0) {
								const fieldName = issue.path[0] as string;
								form.setFieldMeta(fieldName, (prev) => ({
									...prev,
									errors: [issue.message],
								}));
							}
						}
					}

					// Handle API field errors
					const apiError = error as ApiError;
					if (apiError.fields) {
						for (const [fieldName, messages] of Object.entries(
							apiError.fields,
						)) {
							form.setFieldMeta(fieldName, (prev) => ({
								...prev,
								errors: messages,
							}));
						}
					}
					throw error;
				}
			},
		});

		return (
			<div className={className}>
				<form.AppForm>
					<form
						onSubmit={(e) => {
							e.preventDefault();
							form.handleSubmit();
						}}
					>
						{fields.map((fieldConfig) => (
							<form.AppField
								key={fieldConfig.name}
								name={fieldConfig.name}
								validators={{
									onChange: ({ value }) => {
										// Skip validation for editor fields during editing
										if (fieldConfig.type === "editor") {
											return undefined;
										}

										// Use Zod for real-time validation, but be lenient during typing
										const fieldSchema = (schema.shape as any)[
											fieldConfig.name
										];
										if (
											fieldSchema &&
											value !== undefined &&
											value !== ""
										) {
											const result = fieldSchema.safeParse(value);
											if (!result.success) {
												return (
													result.error.issues[0]?.message ||
													"Invalid value"
												);
											}
										}
										return undefined;
									},
								}}
							>
								{(field) => (
									<form.Item>
										<field.Label>
											{fieldConfig.label}
											{fieldConfig.required && (
												<span className="text-destructive ml-1">
													*
												</span>
											)}
										</field.Label>

										<field.Control>
											<FormFieldControl
												field={fieldConfig}
												fieldApi={field}
											/>
										</field.Control>

										{fieldConfig.description && (
											<field.Description>
												{fieldConfig.description}
											</field.Description>
										)}

										<field.Message />
									</form.Item>
								)}
							</form.AppField>
						))}

						<div className="flex gap-2">
							<Button type="submit" disabled={mutationInstance.isPending}>
								{mutationInstance.isPending
									? "Submitting..."
									: submitText}
							</Button>

							<Button
								type="button"
								variant="outline"
								onClick={() => {
									if (
										form.state.isDirty &&
										!confirm(
											"Are you sure? All unsaved changes will be lost.",
										)
									) {
										return;
									}
									form.reset();
								}}
							>
								Reset
							</Button>
						</div>
					</form>
				</form.AppForm>

				{mutationInstance.isSuccess && (
					<div className="mt-4 bg-green-50 dark:bg-green-950/50 border border-green-200 dark:border-green-800 text-green-700 dark:text-green-300 px-4 py-3 rounded-md">
						<div className="flex items-center">
							<div className="flex-shrink-0">
								<CheckCircle className="h-5 w-5 text-green-600 dark:text-green-400" />
							</div>
							<div className="ml-3">
								<p className="text-sm font-medium">Success!</p>
								<p className="text-sm">
									{entityName} saved successfully!
								</p>
							</div>
						</div>
					</div>
				)}

				{mutationInstance.isError && (
					<div className="mt-4 bg-destructive/10 border border-destructive/20 text-destructive px-4 py-3 rounded-md">
						<div className="flex items-center">
							<div className="flex-shrink-0">
								<XCircle className="h-5 w-5 text-destructive" />
							</div>
							<div className="ml-3">
								<p className="text-sm font-medium">Error</p>
								<p className="text-sm">
									{(mutationInstance.error as ApiError)?.message ||
										"Something went wrong"}
								</p>
							</div>
						</div>
					</div>
				)}
			</div>
		);
	};
}

/**
 * Hook version for more control over form rendering
 * Auto-generates defaults and provides smart field rendering
 */
export function useSmartForm<TData, TError, TMutationData extends TDataShape>({
	mutation,
	schema,
	entityName,
	onSuccess,
	initialValues,
}: HookFormOptions<TData, TError, TMutationData>) {
	// Auto-generate fields from schema (needed for processing)
	const fields = generateFieldsFromSchema(schema, {});
	const defaultValues = processInitialValues(
		initialValues ?? extractDefaultValues(schema),
		fields,
	);

	const mutationInstance = useMutation({
		...mutation(),
		onSuccess: (data) => {
			onSuccess?.(data);
			form.reset();
		},
	});

	const form = useAppForm({
		defaultValues,
		onSubmit: async ({ value }) => {
			try {
				// Convert editor objects to strings before validation
				const processedValue = processFormValuesForSubmission(value, fields);

				// Auto-extend schema to include _plain_text fields for editor fields
				const extendedSchema = fields.reduce((acc, field) => {
					if (field.type === "editor") {
						return acc.extend({
							[`${field.name}_plain_text`]: z.string().optional(),
						});
					}
					return acc;
				}, schema);

				const validatedData = extendedSchema.parse(processedValue);
				const fullData = {
					body: { [entityName]: validatedData },
				} as unknown as Options<TMutationData>;

				await mutationInstance.mutateAsync(fullData);
			} catch (error) {
				if (error instanceof z.ZodError) {
					console.error("Validation error:", error.issues);
					for (const issue of error.issues) {
						if (issue.path.length > 0) {
							const fieldName = issue.path[0] as string;
							form.setFieldMeta(fieldName, (prev) => ({
								...prev,
								errors: [issue.message],
							}));
						}
					}
				}

				const apiError = error as ApiError;
				if (apiError.fields) {
					for (const [fieldName, messages] of Object.entries(apiError.fields)) {
						form.setFieldMeta(fieldName, (prev) => ({
							...prev,
							errors: messages,
						}));
					}
				}
				throw error;
			}
		},
	});

	return {
		form,
		mutation: mutationInstance,

		/**
		 * Render a field with auto-generated configuration
		 */
		renderSmartField: (fieldName: string, overrides: Partial<FieldConfig> = {}) => {
			// Start with basic field config
			let fieldConfig: FieldConfig = {
				name: fieldName,
				label: fieldName
					.replace(/([A-Z])/g, " $1")
					.replace(/^./, (str) => str.toUpperCase()),
				type: "text",
				required: !(schema.shape as any)[fieldName]?.isOptional?.(),
			};

			// Apply smart field type detection
			const zodField = (schema.shape as any)[fieldName];
			const actualType =
				zodField instanceof z.ZodOptional ? zodField._def.innerType : zodField;

			if (actualType instanceof z.ZodString) {
				// Check for rich text editor fields (complex content)
				if (
					fieldName.includes("content") ||
					fieldName.includes("description") ||
					fieldName.includes("notes") ||
					fieldName.includes("body") ||
					fieldName.includes("message")
				) {
					fieldConfig.type = "editor";
				}
			} else if (actualType instanceof z.ZodEnum) {
				fieldConfig.type = "select";
				const enumValues = actualType.options || [];
				fieldConfig.options = enumValues.map((value) => ({
					value: String(value),
					label: String(value).charAt(0).toUpperCase() + String(value).slice(1),
				}));
			} else if (actualType instanceof z.ZodArray) {
				// Check if it's an array of strings, likely for tags
				const elementType = actualType._def?.element;
				if (elementType instanceof z.ZodString) {
					fieldConfig.type = "tags";
				}
			}

			// Apply any overrides
			fieldConfig = { ...fieldConfig, ...overrides };

			return (
				<form.AppField
					key={fieldName}
					name={fieldName}
					validators={{
						onChange: ({ value }) => {
							// Skip validation for editor fields during editing
							if (fieldConfig.type === "editor") {
								return undefined;
							}

							const fieldSchema = (schema.shape as any)[fieldName];
							if (fieldSchema && value !== undefined && value !== "") {
								const result = fieldSchema.safeParse(value);
								if (!result.success) {
									return (
										result.error.issues[0]?.message || "Invalid value"
									);
								}
							}
							return undefined;
						},
					}}
				>
					{(field) => (
						<form.Item>
							<field.Label>
								{fieldConfig.label}
								{fieldConfig.required && (
									<span className="text-destructive ml-1">*</span>
								)}
							</field.Label>

							<field.Control>
								<FormFieldControl field={fieldConfig} fieldApi={field} />
							</field.Control>

							{fieldConfig.description && (
								<field.Description>
									{fieldConfig.description}
								</field.Description>
							)}

							<field.Message />
						</form.Item>
					)}
				</form.AppField>
			);
		},
	};
}

const processInitialValues = (
	initialValues: Record<string, any>,
	fields: FieldConfig[],
) => {
	if (!initialValues) return initialValues;

	const processed = { ...initialValues };

	fields.forEach((field) => {
		if (field.type === "editor" && typeof processed[field.name] === "string") {
			const stringValue = processed[field.name] as string;

			// Try to parse as JSON first
			try {
				const parsed = JSON.parse(stringValue);
				// Verify it's a valid TipTap document structure
				if (parsed && typeof parsed === "object" && parsed.type) {
					processed[field.name] = parsed;
					return;
				}
			} catch {
				// Not JSON, continue to plain text handling
			}

			// Handle as plain text - convert to TipTap document structure
			if (stringValue.trim()) {
				processed[field.name] = {
					type: "doc",
					content: [
						{
							type: "paragraph",
							content: [
								{
									type: "text",
									text: stringValue,
								},
							],
						},
					],
				};
			} else {
				// Empty string becomes null
				processed[field.name] = null;
			}
		}
	});

	return processed;
};

const processFormValuesForSubmission = (
	value: Record<string, any>,
	fields: FieldConfig[],
) => {
	const processed = { ...value };

	fields.forEach((field) => {
		const fieldValue = processed[field.name];

		// Handle new editor format with both JSON and text
		if (
			field.type === "editor" &&
			typeof fieldValue === "object" &&
			fieldValue !== null &&
			"json" in fieldValue &&
			"text" in fieldValue
		) {
			// Set the main field to the JSON string
			processed[field.name] = JSON.stringify(fieldValue.json);
			// Set the plain text field
			processed[`${field.name}_plain_text`] = fieldValue.text;
		} else if (
			field.type === "editor" &&
			typeof fieldValue === "object" &&
			fieldValue !== null
		) {
			// Backward compatibility: if it's just a TipTap object
			processed[field.name] = JSON.stringify(fieldValue);
		}
		// If it's already a string, leave it as is
		// If it's null/undefined, leave it as is
	});

	return processed;
};
</file>

<file path="src/routes/_auth/games/$gameId/route.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import { Search } from "lucide-react";
import * as React from "react";
import {
	getGameOptions,
	getLocationTreeOptions,
	getQuestTreeOptions,
	listCharactersOptions,
	listFactionsOptions,
	listGameEntitiesOptions,
	listLocationsOptions,
	listNotesOptions,
	listPinnedEntitiesOptions,
	listQuestsOptions,
} from "~/api/@tanstack/react-query.gen";
import { CreateCharacterSheet } from "~/components/characters/create-character-sheet";
import { Commander } from "~/components/commander";
import { EntityTabs, EntityTabsProvider } from "~/components/entity-tabs";
import { BasicErrorComponent } from "~/components/error";
import { CreateFactionSheet } from "~/components/factions/create-faction-sheet";
import { GameSidebar } from "~/components/layout/game-sidebar";
import { CreateLocationSheet } from "~/components/locations/create-location-sheet";
import { CreateNoteSheet } from "~/components/notes/create-note-sheet";
import { CreateQuestSheet } from "~/components/quests/create-quest-sheet";
import { Badge } from "~/components/ui/badge";
import { SidebarProvider, SidebarTrigger } from "~/components/ui/sidebar";

export const Route = createFileRoute("/_auth/games/$gameId")({
	component: RouteComponent,
	loader: async ({ params, context }) => {
		const gameId = params.gameId;
		await context.queryClient.ensureQueryData({
			...getGameOptions({ path: { id: gameId } }),
		});
		context.queryClient.ensureQueryData(
			listGameEntitiesOptions({ path: { game_id: gameId } }),
		);
		context.queryClient.ensureQueryData(
			getLocationTreeOptions({ path: { game_id: gameId } }),
		);
		context.queryClient.ensureQueryData(
			getQuestTreeOptions({ path: { game_id: gameId } }),
		);
		context.queryClient.ensureQueryData(
			listPinnedEntitiesOptions({ path: { game_id: gameId } }),
		);
		context.queryClient.ensureQueryData(
			listCharactersOptions({ path: { game_id: gameId } }),
		);
		context.queryClient.ensureQueryData(
			listFactionsOptions({ path: { game_id: gameId } }),
		);
		context.queryClient.ensureQueryData(
			listNotesOptions({ path: { game_id: gameId } }),
		);
		context.queryClient.ensureQueryData(
			listQuestsOptions({ path: { game_id: gameId } }),
		);
		context.queryClient.ensureQueryData(
			listLocationsOptions({ path: { game_id: gameId } }),
		);
	},
	errorComponent: BasicErrorComponent,
});

// Games Layout
function RouteComponent() {
	const { gameId } = Route.useParams();

	const [commanderOpen, setCommanderOpen] = React.useState(false);
	const [newCharSheetOpen, setNewCharSheetOpen] = React.useState(false);
	const [newFactionSheetOpen, setNewFactionSheetOpen] = React.useState(false);
	const [newLocationSheetOpen, setNewLocationSheetOpen] = React.useState(false);
	const [newNoteSheetOpen, setNewNoteSheetOpen] = React.useState(false);
	const [newQuestSheetOpen, setNewQuestSheetOpen] = React.useState(false);

	return (
		<EntityTabsProvider>
			<SidebarProvider>
				<div className="flex h-screen w-full">
					<GameSidebar
						setNewCharSheetOpen={setNewCharSheetOpen}
						setNewFactionSheetOpen={setNewFactionSheetOpen}
						setNewLocationSheetOpen={setNewLocationSheetOpen}
						setNewNoteSheetOpen={setNewNoteSheetOpen}
						setNewQuestSheetOpen={setNewQuestSheetOpen}
					/>
					{/* Main Content */}
					<div className="flex-1 flex flex-col">
						<main className="flex-1 overflow-auto">
							<header className="sticky top-0 border-b p-4 flex items-center gap-4 backdrop-blur-md bg-background/80 z-20">
								<SidebarTrigger />
								<Commander
									gameId={gameId}
									isOpen={commanderOpen}
									setIsOpen={setCommanderOpen}
								/>
								<div className="flex-1 max-w-md">
									<button
										type="button"
										onClick={() => setCommanderOpen(true)}
										className="relative w-full h-10 px-3 py-2 text-left text-sm bg-background border border-input rounded-md hover:ring-2 hover:ring-ring focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 cursor-pointer flex items-center"
									>
										<Search className="mr-3 w-4 h-4 text-muted-foreground" />
										<span className="text-muted-foreground">
											Search entities...
										</span>
										<Badge
											variant="secondary"
											className="ml-auto text-xs"
										>
											‚åòJ
										</Badge>
									</button>
								</div>
							</header>
							<EntityTabs />
							<div className="p-6">
								<Outlet />
							</div>
						</main>
						<CreateCharacterSheet
							isOpen={newCharSheetOpen}
							setIsOpen={setNewCharSheetOpen}
						/>
						<CreateFactionSheet
							isOpen={newFactionSheetOpen}
							setIsOpen={setNewFactionSheetOpen}
						/>
						<CreateNoteSheet
							isOpen={newNoteSheetOpen}
							setIsOpen={setNewNoteSheetOpen}
						/>
						<CreateLocationSheet
							isOpen={newLocationSheetOpen}
							setIsOpen={setNewLocationSheetOpen}
						/>
						<CreateQuestSheet
							isOpen={newQuestSheetOpen}
							setIsOpen={setNewQuestSheetOpen}
						/>
					</div>
				</div>
			</SidebarProvider>
		</EntityTabsProvider>
	);
}
</file>

<file path="server/schema/swagger.json">
{
  "info": {
    "version": "1.0",
    "title": "Game Master API"
  },
  "host": "gamemastercore-production.up.railway.app",
  "definitions": {
    "LoginRequest": {
      "description": "Login credentials - either email/password or magic link token",
      "example": {
        "email": "user@example.com",
        "password": "password123"
      },
      "properties": {
        "email": {
          "description": "User email",
          "type": "string"
        },
        "password": {
          "description": "User password",
          "type": "string"
        },
        "token": {
          "description": "Magic link token",
          "type": "string"
        }
      },
      "title": "Login Request",
      "type": "object"
    },
    "EntitiesResponse": {
      "description": "Response containing all game entities",
      "properties": {
        "data": {
          "$ref": "#/definitions/EntitiesData",
          "description": "Response data"
        }
      },
      "title": "Entities Response",
      "type": "object"
    },
    "LinkUpdateRequest": {
      "description": "Request to update link metadata between entities",
      "example": {
        "description": "Former allies turned enemies",
        "is_active": false,
        "metadata": {
          "changed_on": "2021-06-15",
          "reason": "Betrayal during the council meeting"
        },
        "relationship_type": "enemy",
        "strength": 9
      },
      "properties": {
        "description": {
          "description": "Free-form description of the relationship",
          "type": "string"
        },
        "is_active": {
          "description": "Whether the relationship is currently active",
          "type": "boolean"
        },
        "metadata": {
          "description": "Additional flexible metadata as JSON",
          "type": "object"
        },
        "relationship_type": {
          "description": "Type of relationship between entities",
          "type": "string"
        },
        "strength": {
          "description": "Relationship strength/importance (1-10)",
          "maximum": 10,
          "minimum": 1,
          "type": "integer"
        }
      },
      "title": "Link Update Request",
      "type": "object"
    },
    "MembersResponse": {
      "description": "Response containing a list of game members",
      "properties": {
        "data": {
          "description": "Response data",
          "items": {
            "$ref": "#/definitions/Member"
          },
          "type": "array"
        }
      },
      "title": "Members Response",
      "type": "object"
    },
    "EntityCharacter": {
      "description": "Character entity in game entities list",
      "example": {
        "class": "Wizard",
        "content": "A wise and powerful wizard who guides the Fellowship.",
        "content_plain_text": "A wise and powerful wizard who guides the Fellowship.",
        "created_at": "2023-08-20T12:00:00Z",
        "faction_role": "Elder Council Member",
        "id": "323e4567-e89b-12d3-a456-426614174002",
        "image_url": "https://example.com/gandalf.jpg",
        "level": 20,
        "member_of_faction_id": "423e4567-e89b-12d3-a456-426614174003",
        "name": "Gandalf the Grey",
        "tags": [
          "npc",
          "ally",
          "wizard"
        ],
        "updated_at": "2023-08-20T12:00:00Z"
      },
      "properties": {
        "class": {
          "description": "Character class",
          "type": "string"
        },
        "content": {
          "description": "Character content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Character content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "faction_role": {
          "description": "Role within the faction",
          "type": "string"
        },
        "id": {
          "description": "Character ID",
          "format": "uuid",
          "type": "string"
        },
        "image_url": {
          "description": "Character image URL",
          "type": "string"
        },
        "level": {
          "description": "Character level",
          "type": "integer"
        },
        "member_of_faction_id": {
          "description": "ID of faction this character belongs to",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Character name",
          "type": "string"
        },
        "tags": {
          "description": "Tags associated with this character",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        }
      },
      "required": [
        "level",
        "class",
        "name",
        "id"
      ],
      "title": "Entity Character",
      "type": "object"
    },
    "LocationCreateRequest": {
      "description": "Location creation parameters",
      "properties": {
        "location": {
          "$ref": "#/definitions/LocationCreateParams",
          "description": "Location parameters"
        }
      },
      "required": [
        "location"
      ],
      "title": "Location Create Request",
      "type": "object"
    },
    "FactionCreateParams": {
      "description": "Parameters for creating a new faction",
      "example": {
        "content": "A secretive organization that seeks to control the realm from behind the scenes.",
        "content_plain_text": "A secretive organization that seeks to control the realm from behind the scenes.",
        "name": "The Shadow Council",
        "tags": [
          "secret",
          "political"
        ]
      },
      "properties": {
        "content": {
          "description": "Faction content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Faction content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Faction name",
          "type": "string"
        },
        "tags": {
          "description": "Tags for this faction",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "description",
        "content",
        "name"
      ],
      "title": "Faction Create Parameters",
      "type": "object"
    },
    "User": {
      "description": "User information",
      "example": {
        "confirmed_at": "2023-08-20T12:00:00Z",
        "email": "user@example.com",
        "id": 1
      },
      "properties": {
        "confirmed_at": {
          "description": "Email confirmation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "email": {
          "description": "User email",
          "type": "string"
        },
        "id": {
          "description": "User ID",
          "type": "integer"
        }
      },
      "required": [
        "email",
        "id"
      ],
      "title": "User",
      "type": "object"
    },
    "LocationLinks": {
      "description": "Collections of entities linked to a location",
      "properties": {
        "characters": {
          "description": "Linked characters with metadata",
          "items": {
            "$ref": "#/definitions/LinkedCharacter"
          },
          "type": "array"
        },
        "factions": {
          "description": "Linked factions with metadata",
          "items": {
            "$ref": "#/definitions/LinkedFaction"
          },
          "type": "array"
        },
        "locations": {
          "description": "Linked locations with metadata",
          "items": {
            "$ref": "#/definitions/LinkedLocation"
          },
          "type": "array"
        },
        "notes": {
          "description": "Linked notes with metadata",
          "items": {
            "$ref": "#/definitions/LinkedNote"
          },
          "type": "array"
        },
        "quests": {
          "description": "Linked quests with metadata",
          "items": {
            "$ref": "#/definitions/LinkedQuest"
          },
          "type": "array"
        }
      },
      "title": "Location Links",
      "type": "object"
    },
    "LinkedQuest": {
      "description": "A quest with relationship metadata",
      "properties": {
        "content": {
          "description": "Quest content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Quest content as plain text",
          "type": "string"
        },
        "description_meta": {
          "description": "Description of the relationship",
          "type": "string"
        },
        "id": {
          "description": "Quest ID",
          "format": "uuid",
          "type": "string"
        },
        "is_active": {
          "description": "Whether the relationship is active",
          "type": "boolean"
        },
        "metadata": {
          "description": "Additional metadata",
          "type": "object"
        },
        "name": {
          "description": "Quest name",
          "type": "string"
        },
        "relationship_type": {
          "description": "Type of relationship",
          "type": "string"
        },
        "strength": {
          "description": "Relationship strength (1-10)",
          "type": "integer"
        },
        "tags": {
          "description": "Quest tags",
          "type": "array"
        }
      },
      "required": [
        "content",
        "name",
        "id"
      ],
      "title": "Linked Quest",
      "type": "object"
    },
    "Entities": {
      "description": "Collection of game entities",
      "properties": {
        "characters": {
          "description": "Characters list",
          "items": {
            "$ref": "#/definitions/EntityCharacter"
          },
          "type": "array"
        },
        "factions": {
          "description": "Factions list",
          "items": {
            "$ref": "#/definitions/EntityFaction"
          },
          "type": "array"
        },
        "locations": {
          "description": "Locations list",
          "items": {
            "$ref": "#/definitions/EntityLocation"
          },
          "type": "array"
        },
        "notes": {
          "description": "Notes list",
          "items": {
            "$ref": "#/definitions/EntityNote"
          },
          "type": "array"
        },
        "quests": {
          "description": "Quests list",
          "items": {
            "$ref": "#/definitions/EntityQuest"
          },
          "type": "array"
        }
      },
      "title": "Entities",
      "type": "object"
    },
    "LinkedEntityBase": {
      "properties": {
        "description": {
          "description": "Description of the relationship",
          "type": "string"
        },
        "is_active": {
          "description": "Whether the relationship is active",
          "type": "boolean"
        },
        "metadata": {
          "description": "Additional metadata",
          "type": "object"
        },
        "relationship_type": {
          "description": "Type of relationship",
          "type": "string"
        },
        "strength": {
          "description": "Relationship strength (1-10)",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "CharacterLinksResponse": {
      "description": "Response containing character links",
      "properties": {
        "data": {
          "$ref": "#/definitions/CharacterLinksData",
          "description": "Response data"
        }
      },
      "title": "Character Links Response",
      "type": "object"
    },
    "EntityQuest": {
      "description": "Quest entity in game entities list",
      "example": {
        "content": "Find the lost treasure hidden in the ancient ruins.",
        "content_plain_text": "Find the lost treasure hidden in the ancient ruins.",
        "created_at": "2023-08-20T12:00:00Z",
        "id": "623e4567-e89b-12d3-a456-426614174005",
        "name": "The Lost Treasure",
        "parent_id": "723e4567-e89b-12d3-a456-426614174006",
        "tags": [
          "main",
          "treasure",
          "exploration"
        ],
        "updated_at": "2023-08-20T12:00:00Z"
      },
      "properties": {
        "content": {
          "description": "Quest content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Quest content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "id": {
          "description": "Quest ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Quest name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent quest ID for hierarchical structure",
          "format": "uuid",
          "type": "string"
        },
        "tags": {
          "description": "Tags associated with this quest",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        }
      },
      "required": [
        "content",
        "name",
        "id"
      ],
      "title": "Entity Quest",
      "type": "object"
    },
    "ErrorDetails": {
      "description": "Detailed error information",
      "title": "Error Details",
      "type": "object"
    },
    "GameCreateRequest": {
      "description": "Game creation parameters",
      "properties": {
        "game": {
          "$ref": "#/definitions/GameCreateParams",
          "description": "Game parameters"
        }
      },
      "required": [
        "game"
      ],
      "title": "Game Create Request",
      "type": "object"
    },
    "EntitiesData": {
      "description": "Game entities data structure",
      "properties": {
        "entities": {
          "$ref": "#/definitions/Entities",
          "description": "Game entities"
        },
        "game_id": {
          "description": "Game ID",
          "format": "uuid",
          "type": "string"
        },
        "game_name": {
          "description": "Game name",
          "type": "string"
        }
      },
      "required": [
        "game_name",
        "game_id"
      ],
      "title": "Entities Data",
      "type": "object"
    },
    "CharactersResponse": {
      "description": "Response containing a list of characters",
      "properties": {
        "data": {
          "description": "Response data",
          "items": {
            "$ref": "#/definitions/Character"
          },
          "type": "array"
        }
      },
      "title": "Characters Response",
      "type": "object"
    },
    "FactionUpdateRequest": {
      "description": "Faction update parameters",
      "properties": {
        "faction": {
          "$ref": "#/definitions/FactionUpdateParams",
          "description": "Faction parameters"
        }
      },
      "required": [
        "faction"
      ],
      "title": "Faction Update Request",
      "type": "object"
    },
    "FactionMembersData": {
      "description": "Characters that are members of a faction",
      "example": {
        "faction_id": "423e4567-e89b-12d3-a456-426614174003",
        "faction_name": "The White Council",
        "members": [
          {
            "class": "Wizard",
            "faction_role": "Elder Council Member",
            "id": "123e4567-e89b-12d3-a456-426614174000",
            "level": 20,
            "member_of_faction_id": "423e4567-e89b-12d3-a456-426614174003",
            "name": "Gandalf the Grey"
          }
        ]
      },
      "properties": {
        "faction_id": {
          "description": "Faction ID",
          "format": "uuid",
          "type": "string"
        },
        "faction_name": {
          "description": "Faction name",
          "type": "string"
        },
        "members": {
          "description": "Faction member characters",
          "items": {
            "$ref": "#/definitions/Character"
          },
          "type": "array"
        }
      },
      "required": [
        "faction_name",
        "faction_id"
      ],
      "title": "Faction Members Data",
      "type": "object"
    },
    "EntityTreeData": {
      "description": "Entity relationship tree data grouped by entity types or single tree",
      "example": {
        "characters": [
          {
            "children": [],
            "id": "123e4567-e89b-12d3-a456-426614174000",
            "name": "Main Character",
            "type": "character"
          }
        ],
        "factions": [],
        "locations": [],
        "notes": [],
        "quests": []
      },
      "properties": {
        "characters": {
          "description": "Character trees",
          "items": {
            "$ref": "#/definitions/EntityTreeNode"
          },
          "type": "array"
        },
        "factions": {
          "description": "Faction trees",
          "items": {
            "$ref": "#/definitions/EntityTreeNode"
          },
          "type": "array"
        },
        "locations": {
          "description": "Location trees",
          "items": {
            "$ref": "#/definitions/EntityTreeNode"
          },
          "type": "array"
        },
        "notes": {
          "description": "Note trees",
          "items": {
            "$ref": "#/definitions/EntityTreeNode"
          },
          "type": "array"
        },
        "quests": {
          "description": "Quest trees",
          "items": {
            "$ref": "#/definitions/EntityTreeNode"
          },
          "type": "array"
        }
      },
      "title": "Entity Tree Data",
      "type": "object"
    },
    "QuestTreeNode": {
      "description": "A node in the quest hierarchy tree",
      "example": {
        "children": [],
        "content": "Find the lost treasure hidden in the ancient ruins.",
        "content_plain_text": "Find the lost treasure hidden in the ancient ruins.",
        "entity_type": "quest",
        "id": "623e4567-e89b-12d3-a456-426614174005",
        "name": "The Lost Treasure",
        "parent_id": "723e4567-e89b-12d3-a456-426614174006",
        "tags": [
          "main",
          "treasure",
          "exploration"
        ]
      },
      "properties": {
        "children": {
          "description": "Child quests",
          "items": {
            "$ref": "#/definitions/QuestTreeNode"
          },
          "type": "array"
        },
        "content": {
          "description": "Quest content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Quest content as plain text",
          "type": "string"
        },
        "entity_type": {
          "description": "Entity type for URL building",
          "enum": [
            "quest"
          ],
          "type": "string"
        },
        "id": {
          "description": "Quest ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Quest name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent quest ID",
          "format": "uuid",
          "type": "string"
        },
        "tags": {
          "description": "Tags associated with this quest",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "entity_type",
        "name",
        "id"
      ],
      "title": "Quest Tree Node",
      "type": "object"
    },
    "CharacterCreateRequest": {
      "description": "Character creation parameters",
      "properties": {
        "character": {
          "$ref": "#/definitions/CharacterCreateParams",
          "description": "Character parameters"
        }
      },
      "required": [
        "character"
      ],
      "title": "Character Create Request",
      "type": "object"
    },
    "EntityNote": {
      "description": "Note entity in game entities list",
      "example": {
        "content": "The dragon is hiding in the crystal cave beyond the misty mountains.",
        "content_plain_text": "The dragon is hiding in the crystal cave beyond the misty mountains.",
        "created_at": "2023-08-20T12:00:00Z",
        "id": "223e4567-e89b-12d3-a456-426614174001",
        "name": "Important Quest Notes",
        "tags": [
          "important",
          "dragon",
          "quest"
        ],
        "updated_at": "2023-08-20T12:00:00Z"
      },
      "properties": {
        "content": {
          "description": "Note content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Note content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "id": {
          "description": "Note ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Note name",
          "type": "string"
        },
        "tags": {
          "description": "Tags associated with this note",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        }
      },
      "required": [
        "content",
        "name",
        "id"
      ],
      "title": "Entity Note",
      "type": "object"
    },
    "NoteLinks": {
      "description": "Collections of entities linked to a note",
      "properties": {
        "characters": {
          "description": "Linked characters with metadata",
          "items": {
            "$ref": "#/definitions/LinkedCharacter"
          },
          "type": "array"
        },
        "factions": {
          "description": "Linked factions with metadata",
          "items": {
            "$ref": "#/definitions/LinkedFaction"
          },
          "type": "array"
        },
        "locations": {
          "description": "Linked locations with metadata",
          "items": {
            "$ref": "#/definitions/LinkedLocation"
          },
          "type": "array"
        },
        "notes": {
          "description": "Linked notes with metadata",
          "items": {
            "$ref": "#/definitions/LinkedNote"
          },
          "type": "array"
        },
        "quests": {
          "description": "Linked quests with metadata",
          "items": {
            "$ref": "#/definitions/LinkedQuest"
          },
          "type": "array"
        }
      },
      "title": "Note Links",
      "type": "object"
    },
    "FactionLinks": {
      "description": "Collections of entities linked to a faction",
      "properties": {
        "characters": {
          "description": "Linked characters with metadata",
          "items": {
            "$ref": "#/definitions/LinkedCharacter"
          },
          "type": "array"
        },
        "factions": {
          "description": "Linked factions with metadata",
          "items": {
            "$ref": "#/definitions/LinkedFaction"
          },
          "type": "array"
        },
        "locations": {
          "description": "Linked locations with metadata",
          "items": {
            "$ref": "#/definitions/LinkedLocation"
          },
          "type": "array"
        },
        "notes": {
          "description": "Linked notes with metadata",
          "items": {
            "$ref": "#/definitions/LinkedNote"
          },
          "type": "array"
        },
        "quests": {
          "description": "Linked quests with metadata",
          "items": {
            "$ref": "#/definitions/LinkedQuest"
          },
          "type": "array"
        }
      },
      "title": "Faction Links",
      "type": "object"
    },
    "FactionsResponse": {
      "description": "Response containing a list of factions",
      "properties": {
        "data": {
          "description": "Response data",
          "items": {
            "$ref": "#/definitions/Faction"
          },
          "type": "array"
        }
      },
      "title": "Factions Response",
      "type": "object"
    },
    "NoteTreeNode": {
      "description": "A node in the note hierarchy tree",
      "example": {
        "children": [
          {
            "children": [],
            "content": "Early life details...",
            "entity_type": "note",
            "id": "823e4567-e89b-12d3-a456-426614174007",
            "name": "Childhood Memories"
          }
        ],
        "content": "Detailed backstory information...",
        "content_plain_text": "Detailed backstory information...",
        "created_at": "2024-01-01T00:00:00Z",
        "entity_type": "note",
        "id": "723e4567-e89b-12d3-a456-426614174006",
        "name": "Character Backstory",
        "parent_id": "523e4567-e89b-12d3-a456-426614174004",
        "parent_type": "Character",
        "tags": [
          "backstory",
          "important"
        ],
        "updated_at": "2024-01-01T00:00:00Z"
      },
      "properties": {
        "children": {
          "description": "Child notes",
          "items": {
            "$ref": "#/definitions/NoteTreeNode"
          },
          "type": "array"
        },
        "content": {
          "description": "Note content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Note content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "entity_type": {
          "description": "Entity type for URL building",
          "enum": [
            "note"
          ],
          "type": "string"
        },
        "id": {
          "description": "Note ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Note name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent ID (note or other entity)",
          "format": "uuid",
          "type": "string"
        },
        "parent_type": {
          "description": "Type of parent entity (character, quest, location, faction)",
          "enum": [
            "character",
            "quest",
            "location",
            "faction"
          ],
          "type": "string"
        },
        "tags": {
          "description": "Tags associated with this note",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        }
      },
      "required": [
        "entity_type",
        "content",
        "name",
        "id"
      ],
      "title": "Note Tree Node",
      "type": "object"
    },
    "QuestLinksData": {
      "description": "Links associated with a quest",
      "properties": {
        "links": {
          "$ref": "#/definitions/QuestLinks",
          "description": "Associated entity links"
        },
        "quest_id": {
          "description": "Quest ID",
          "format": "uuid",
          "type": "string"
        },
        "quest_name": {
          "description": "Quest name",
          "type": "string"
        }
      },
      "required": [
        "quest_name",
        "quest_id"
      ],
      "title": "Quest Links Data",
      "type": "object"
    },
    "CharacterPrimaryFactionResponse": {
      "description": "Response containing character's primary faction data",
      "properties": {
        "data": {
          "$ref": "#/definitions/CharacterPrimaryFactionData",
          "description": "Response data"
        }
      },
      "title": "Character Primary Faction Response",
      "type": "object"
    },
    "QuestResponse": {
      "description": "Response containing a single quest",
      "properties": {
        "data": {
          "$ref": "#/definitions/Quest",
          "description": "Response data"
        }
      },
      "title": "Quest Response",
      "type": "object"
    },
    "Location": {
      "description": "A game location",
      "example": {
        "content": "A mysterious cave hidden in the mountains, known for its glowing crystals.",
        "content_plain_text": "A mysterious cave hidden in the mountains, known for its glowing crystals.",
        "created_at": "2023-08-20T12:00:00Z",
        "game_id": "123e4567-e89b-12d3-a456-426614174000",
        "id": "523e4567-e89b-12d3-a456-426614174004",
        "name": "The Crystal Cave",
        "parent_id": "723e4567-e89b-12d3-a456-426614174006",
        "pinned": false,
        "tags": [
          "magical",
          "hidden",
          "dangerous"
        ],
        "type": "building",
        "updated_at": "2023-08-20T12:00:00Z",
        "user_id": 1
      },
      "properties": {
        "content": {
          "description": "Location content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Location content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "game_id": {
          "description": "Associated game ID",
          "format": "uuid",
          "type": "string"
        },
        "id": {
          "description": "Location ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Location name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent location ID",
          "format": "uuid",
          "type": "string"
        },
        "pinned": {
          "description": "Whether this location is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags associated with this location",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "type": {
          "description": "Location type",
          "enum": [
            "continent",
            "nation",
            "region",
            "city",
            "settlement",
            "building",
            "complex"
          ],
          "type": "string"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        },
        "user_id": {
          "description": "Creator user ID",
          "type": "integer"
        }
      },
      "required": [
        "user_id",
        "game_id",
        "pinned",
        "type",
        "name",
        "id"
      ],
      "title": "Location",
      "type": "object"
    },
    "LocationUpdateRequest": {
      "description": "Location update parameters",
      "properties": {
        "location": {
          "$ref": "#/definitions/LocationUpdateParams",
          "description": "Location parameters"
        }
      },
      "required": [
        "location"
      ],
      "title": "Location Update Request",
      "type": "object"
    },
    "LinkRequest": {
      "description": "Request to create a link between entities",
      "example": {
        "description": "Long-time allies from the war",
        "entity_id": "323e4567-e89b-12d3-a456-426614174002",
        "entity_type": "character",
        "is_active": true,
        "metadata": {
          "notes": "Met during the siege",
          "since": "2021-01-01"
        },
        "relationship_type": "ally",
        "strength": 8
      },
      "properties": {
        "description": {
          "description": "Free-form description of the relationship",
          "type": "string"
        },
        "entity_id": {
          "description": "Entity ID to link",
          "format": "uuid",
          "type": "string"
        },
        "entity_type": {
          "description": "Entity type to link",
          "enum": [
            "character",
            "faction",
            "location",
            "quest",
            "note"
          ],
          "type": "string"
        },
        "is_active": {
          "default": true,
          "description": "Whether the relationship is currently active",
          "type": "boolean"
        },
        "metadata": {
          "description": "Additional flexible metadata as JSON",
          "type": "object"
        },
        "relationship_type": {
          "description": "Type of relationship between entities",
          "type": "string"
        },
        "strength": {
          "description": "Relationship strength/importance (1-10)",
          "maximum": 10,
          "minimum": 1,
          "type": "integer"
        }
      },
      "required": [
        "entity_type",
        "entity_id",
        "entity_id",
        "entity_type"
      ],
      "title": "Link Request",
      "type": "object"
    },
    "GamesResponse": {
      "description": "Response containing a list of games",
      "properties": {
        "data": {
          "description": "Response data",
          "items": {
            "$ref": "#/definitions/Game"
          },
          "type": "array"
        }
      },
      "title": "Games Response",
      "type": "object"
    },
    "Member": {
      "description": "A game member",
      "example": {
        "email": "user@example.com",
        "joined_at": "2023-08-20T12:00:00Z",
        "role": "member",
        "user_id": 1
      },
      "properties": {
        "email": {
          "description": "User email",
          "type": "string"
        },
        "joined_at": {
          "description": "Join timestamp",
          "format": "datetime",
          "type": "string"
        },
        "role": {
          "description": "Member role",
          "type": "string"
        },
        "user_id": {
          "description": "User ID",
          "type": "integer"
        }
      },
      "required": [
        "role",
        "email",
        "user_id"
      ],
      "title": "Member",
      "type": "object"
    },
    "Faction": {
      "description": "A game faction",
      "example": {
        "content": "A secretive organization that seeks to control the realm from behind the scenes.",
        "content_plain_text": "A secretive organization that seeks to control the realm from behind the scenes.",
        "created_at": "2023-08-20T12:00:00Z",
        "game_id": "123e4567-e89b-12d3-a456-426614174000",
        "id": "423e4567-e89b-12d3-a456-426614174003",
        "name": "The Shadow Council",
        "pinned": false,
        "tags": [
          "secret",
          "political",
          "antagonist"
        ],
        "updated_at": "2023-08-20T12:00:00Z",
        "user_id": 1
      },
      "properties": {
        "content": {
          "description": "Faction content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Faction content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "game_id": {
          "description": "Associated game ID",
          "format": "uuid",
          "type": "string"
        },
        "id": {
          "description": "Faction ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Faction name",
          "type": "string"
        },
        "pinned": {
          "description": "Whether this faction is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags associated with this faction",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        },
        "user_id": {
          "description": "Creator user ID",
          "type": "integer"
        }
      },
      "required": [
        "user_id",
        "game_id",
        "pinned",
        "content",
        "name",
        "id"
      ],
      "title": "Faction",
      "type": "object"
    },
    "PinnedEntitiesData": {
      "description": "All pinned entities for a game",
      "example": {
        "game_id": "123e4567-e89b-12d3-a456-426614174000",
        "pinned_entities": {
          "characters": [
            {
              "id": "456e7890-e89b-12d3-a456-426614174001",
              "name": "Hero Character",
              "pinned": true
            }
          ],
          "factions": [],
          "locations": [],
          "notes": [
            {
              "id": "789e1234-e89b-12d3-a456-426614174002",
              "name": "Important Note",
              "pinned": true
            }
          ],
          "quests": []
        },
        "total_count": 3
      },
      "properties": {
        "game_id": {
          "description": "Game ID",
          "format": "uuid",
          "type": "string"
        },
        "pinned_entities": {
          "$ref": "#/definitions/PinnedEntities",
          "description": "Pinned entities grouped by type"
        },
        "total_count": {
          "description": "Total number of pinned entities",
          "type": "integer"
        }
      },
      "required": [
        "pinned_entities",
        "total_count",
        "game_id"
      ],
      "title": "Pinned Entities Data",
      "type": "object"
    },
    "NoteCreateRequest": {
      "description": "Note creation parameters",
      "properties": {
        "note": {
          "$ref": "#/definitions/NoteCreateParams",
          "description": "Note parameters"
        }
      },
      "required": [
        "note"
      ],
      "title": "Note Create Request",
      "type": "object"
    },
    "LocationResponse": {
      "description": "Response containing a single location",
      "properties": {
        "data": {
          "$ref": "#/definitions/Location",
          "description": "Response data"
        }
      },
      "title": "Location Response",
      "type": "object"
    },
    "CharacterResponse": {
      "description": "Response containing a single character",
      "properties": {
        "data": {
          "$ref": "#/definitions/Character",
          "description": "Response data"
        }
      },
      "title": "Character Response",
      "type": "object"
    },
    "LocationLinksData": {
      "description": "Links associated with a location",
      "properties": {
        "links": {
          "$ref": "#/definitions/LocationLinks",
          "description": "Associated entity links"
        },
        "location_id": {
          "description": "Location ID",
          "format": "uuid",
          "type": "string"
        },
        "location_name": {
          "description": "Location name",
          "type": "string"
        }
      },
      "required": [
        "location_name",
        "location_id"
      ],
      "title": "Location Links Data",
      "type": "object"
    },
    "CharacterLinks": {
      "description": "Collections of entities linked to a character",
      "properties": {
        "characters": {
          "description": "Linked characters with metadata",
          "items": {
            "$ref": "#/definitions/LinkedCharacter"
          },
          "type": "array"
        },
        "factions": {
          "description": "Linked factions with metadata",
          "items": {
            "$ref": "#/definitions/LinkedFaction"
          },
          "type": "array"
        },
        "locations": {
          "description": "Linked locations with metadata",
          "items": {
            "$ref": "#/definitions/LinkedLocation"
          },
          "type": "array"
        },
        "notes": {
          "description": "Linked notes with metadata",
          "items": {
            "$ref": "#/definitions/LinkedNote"
          },
          "type": "array"
        },
        "quests": {
          "description": "Linked quests with metadata",
          "items": {
            "$ref": "#/definitions/LinkedQuest"
          },
          "type": "array"
        }
      },
      "title": "Character Links",
      "type": "object"
    },
    "LocationLinksResponse": {
      "description": "Response containing location links",
      "properties": {
        "data": {
          "$ref": "#/definitions/LocationLinksData",
          "description": "Response data"
        }
      },
      "title": "Location Links Response",
      "type": "object"
    },
    "EntityTreeResponse": {
      "description": "Response containing hierarchical tree of entity relationships",
      "properties": {
        "data": {
          "$ref": "#/definitions/EntityTreeData",
          "description": "Response data"
        }
      },
      "title": "Entity Tree Response",
      "type": "object"
    },
    "QuestLinksResponse": {
      "description": "Response containing quest links",
      "properties": {
        "data": {
          "$ref": "#/definitions/QuestLinksData",
          "description": "Response data"
        }
      },
      "title": "Quest Links Response",
      "type": "object"
    },
    "SignupRequest": {
      "description": "User registration credentials",
      "example": {
        "email": "user@example.com",
        "password": "password123"
      },
      "properties": {
        "email": {
          "description": "User email",
          "type": "string"
        },
        "password": {
          "description": "User password",
          "type": "string"
        }
      },
      "required": [
        "email",
        "password",
        "password",
        "email"
      ],
      "title": "Signup Request",
      "type": "object"
    },
    "NotesResponse": {
      "description": "Response containing a list of notes",
      "properties": {
        "data": {
          "description": "Response data",
          "items": {
            "$ref": "#/definitions/Note"
          },
          "type": "array"
        }
      },
      "title": "Notes Response",
      "type": "object"
    },
    "LocationCreateParams": {
      "description": "Parameters for creating a new location",
      "example": {
        "content": "A mysterious cave hidden in the mountains, known for its glowing crystals.",
        "content_plain_text": "A mysterious cave hidden in the mountains, known for its glowing crystals.",
        "name": "The Crystal Cave",
        "parent_id": "723e4567-e89b-12d3-a456-426614174006",
        "tags": [
          "magical",
          "hidden"
        ],
        "type": "building"
      },
      "properties": {
        "content": {
          "description": "Location content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Location content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Location name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent location ID",
          "format": "uuid",
          "type": "string"
        },
        "tags": {
          "description": "Tags for this location",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "type": {
          "description": "Location type",
          "enum": [
            "continent",
            "nation",
            "region",
            "city",
            "settlement",
            "building",
            "complex"
          ],
          "type": "string"
        }
      },
      "required": [
        "name",
        "type",
        "type",
        "name"
      ],
      "title": "Location Create Parameters",
      "type": "object"
    },
    "FactionUpdateParams": {
      "description": "Parameters for updating an existing faction (partial updates supported)",
      "example": {
        "content": "A secretive organization that seeks to control the entire realm from behind the scenes, now with expanded influence.",
        "content_plain_text": "A secretive organization that seeks to control the entire realm from behind the scenes, now with expanded influence.",
        "pinned": false
      },
      "properties": {
        "content": {
          "description": "Faction content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Faction content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Faction name",
          "type": "string"
        },
        "pinned": {
          "description": "Whether this faction is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags for this faction",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "title": "Faction Update Parameters",
      "type": "object"
    },
    "LinkedCharacter": {
      "description": "A character with relationship metadata",
      "properties": {
        "content": {
          "description": "Character content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Character content as plain text",
          "type": "string"
        },
        "description_meta": {
          "description": "Description of the relationship",
          "type": "string"
        },
        "faction_role": {
          "description": "Role within the faction",
          "type": "string"
        },
        "id": {
          "description": "Character ID",
          "format": "uuid",
          "type": "string"
        },
        "is_active": {
          "description": "Whether the relationship is active",
          "type": "boolean"
        },
        "member_of_faction_id": {
          "description": "ID of faction this character belongs to",
          "format": "uuid",
          "type": "string"
        },
        "metadata": {
          "description": "Additional metadata",
          "type": "object"
        },
        "name": {
          "description": "Character name",
          "type": "string"
        },
        "relationship_type": {
          "description": "Type of relationship",
          "type": "string"
        },
        "strength": {
          "description": "Relationship strength (1-10)",
          "type": "integer"
        },
        "tags": {
          "description": "Character tags",
          "type": "array"
        }
      },
      "required": [
        "content",
        "name",
        "id"
      ],
      "title": "Linked Character",
      "type": "object"
    },
    "CharacterPrimaryFactionData": {
      "description": "Primary faction information for a character",
      "example": {
        "character_id": "323e4567-e89b-12d3-a456-426614174002",
        "faction": {
          "content": "A council of wise beings...",
          "content_plain_text": "A council of wise beings...",
          "id": "423e4567-e89b-12d3-a456-426614174003",
          "name": "The Grey Council",
          "tags": [
            "council",
            "wisdom"
          ]
        },
        "role": "Elder Council Member"
      },
      "properties": {
        "character_id": {
          "description": "Character ID",
          "format": "uuid",
          "type": "string"
        },
        "faction": {
          "$ref": "#/definitions/Faction",
          "description": "Faction details"
        },
        "role": {
          "description": "Character's role in the faction",
          "type": "string"
        }
      },
      "required": [
        "role",
        "faction",
        "character_id"
      ],
      "title": "Character Primary Faction Data",
      "type": "object"
    },
    "QuestUpdateRequest": {
      "description": "Quest update parameters",
      "properties": {
        "quest": {
          "$ref": "#/definitions/QuestUpdateParams",
          "description": "Quest parameters"
        }
      },
      "required": [
        "quest"
      ],
      "title": "Quest Update Request",
      "type": "object"
    },
    "SetPrimaryFactionRequest": {
      "description": "Parameters for setting a character's primary faction",
      "example": {
        "faction_id": "423e4567-e89b-12d3-a456-426614174003",
        "role": "Captain"
      },
      "properties": {
        "faction_id": {
          "description": "Faction ID",
          "format": "uuid",
          "type": "string"
        },
        "role": {
          "description": "Character's role in the faction",
          "type": "string"
        }
      },
      "required": [
        "faction_id",
        "role",
        "role",
        "faction_id"
      ],
      "title": "Set Primary Faction Request",
      "type": "object"
    },
    "EntityTreeNode": {
      "description": "A single node in the entity relationship tree",
      "example": {
        "children": [
          {
            "children": [],
            "description": "Active member",
            "id": "456e7890-e89b-12d3-a456-426614174001",
            "is_active": true,
            "metadata": {},
            "name": "Character's Faction",
            "relationship_type": "member",
            "strength": 3,
            "type": "faction"
          }
        ],
        "description": "Close friend and ally",
        "id": "123e4567-e89b-12d3-a456-426614174000",
        "is_active": true,
        "metadata": {
          "notes": "Met during quest"
        },
        "name": "Main Character",
        "relationship_type": "friend",
        "strength": 4,
        "type": "character"
      },
      "properties": {
        "children": {
          "description": "Child entities",
          "items": {
            "$ref": "#/definitions/EntityTreeNode"
          },
          "type": "array"
        },
        "description": {
          "description": "Relationship description",
          "type": "string"
        },
        "id": {
          "description": "Entity ID",
          "format": "uuid",
          "type": "string"
        },
        "is_active": {
          "description": "Whether relationship is active",
          "type": "boolean"
        },
        "metadata": {
          "description": "Additional relationship metadata",
          "type": "object"
        },
        "name": {
          "description": "Entity name",
          "type": "string"
        },
        "relationship_type": {
          "description": "Type of relationship to parent",
          "type": "string"
        },
        "strength": {
          "description": "Relationship strength (1-5)",
          "maximum": 5,
          "minimum": 1,
          "type": "integer"
        },
        "type": {
          "description": "Entity type",
          "enum": [
            "character",
            "faction",
            "location",
            "quest",
            "note"
          ],
          "type": "string"
        }
      },
      "required": [
        "children",
        "type",
        "name",
        "id"
      ],
      "title": "Entity Tree Node",
      "type": "object"
    },
    "FactionLinksResponse": {
      "description": "Response containing faction links",
      "properties": {
        "data": {
          "$ref": "#/definitions/FactionLinksData",
          "description": "Response data"
        }
      },
      "title": "Faction Links Response",
      "type": "object"
    },
    "CharacterUpdateRequest": {
      "description": "Character update parameters",
      "properties": {
        "character": {
          "$ref": "#/definitions/CharacterUpdateParams",
          "description": "Character parameters"
        }
      },
      "required": [
        "character"
      ],
      "title": "Character Update Request",
      "type": "object"
    },
    "LinkedFaction": {
      "description": "A faction with relationship metadata",
      "properties": {
        "content": {
          "description": "Faction content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Faction content as plain text",
          "type": "string"
        },
        "description_meta": {
          "description": "Description of the relationship",
          "type": "string"
        },
        "id": {
          "description": "Faction ID",
          "format": "uuid",
          "type": "string"
        },
        "is_active": {
          "description": "Whether the relationship is active",
          "type": "boolean"
        },
        "metadata": {
          "description": "Additional metadata",
          "type": "object"
        },
        "name": {
          "description": "Faction name",
          "type": "string"
        },
        "relationship_type": {
          "description": "Type of relationship",
          "type": "string"
        },
        "strength": {
          "description": "Relationship strength (1-10)",
          "type": "integer"
        },
        "tags": {
          "description": "Faction tags",
          "type": "array"
        }
      },
      "required": [
        "content",
        "name",
        "id"
      ],
      "title": "Linked Faction",
      "type": "object"
    },
    "AuthStatusResponse": {
      "description": "Authentication status response",
      "example": {
        "authenticated": true,
        "user": {
          "confirmed_at": "2023-08-20T12:00:00Z",
          "email": "user@example.com",
          "id": 1
        }
      },
      "properties": {
        "authenticated": {
          "description": "Whether user is authenticated",
          "type": "boolean"
        },
        "user": {
          "$ref": "#/definitions/User",
          "description": "User information if authenticated"
        }
      },
      "required": [
        "authenticated"
      ],
      "title": "Auth Status Response",
      "type": "object"
    },
    "LinkedNote": {
      "description": "A note with relationship metadata",
      "properties": {
        "content": {
          "description": "Note content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Note content as plain text",
          "type": "string"
        },
        "description_meta": {
          "description": "Description of the relationship",
          "type": "string"
        },
        "id": {
          "description": "Note ID",
          "format": "uuid",
          "type": "string"
        },
        "is_active": {
          "description": "Whether the relationship is active",
          "type": "boolean"
        },
        "metadata": {
          "description": "Additional metadata",
          "type": "object"
        },
        "name": {
          "description": "Note name",
          "type": "string"
        },
        "relationship_type": {
          "description": "Type of relationship",
          "type": "string"
        },
        "strength": {
          "description": "Relationship strength (1-10)",
          "type": "integer"
        },
        "tags": {
          "description": "Note tags",
          "type": "array"
        }
      },
      "required": [
        "content",
        "name",
        "id"
      ],
      "title": "Linked Note",
      "type": "object"
    },
    "LocationUpdateParams": {
      "description": "Parameters for updating an existing location (partial updates supported)",
      "example": {
        "content": "A mysterious cave hidden deep in the mountains, known for its brilliant glowing crystals and ancient runes.",
        "content_plain_text": "A mysterious cave hidden deep in the mountains, known for its brilliant glowing crystals and ancient runes.",
        "pinned": true
      },
      "properties": {
        "content": {
          "description": "Location content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Location content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Location name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent location ID",
          "format": "uuid",
          "type": "string"
        },
        "pinned": {
          "description": "Whether this location is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags for this location",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "type": {
          "description": "Location type",
          "enum": [
            "continent",
            "nation",
            "region",
            "city",
            "settlement",
            "building",
            "complex"
          ],
          "type": "string"
        }
      },
      "title": "Location Update Parameters",
      "type": "object"
    },
    "CharacterNotesTreeData": {
      "description": "Hierarchical tree of notes associated with a character",
      "properties": {
        "character_id": {
          "description": "Character ID",
          "format": "uuid",
          "type": "string"
        },
        "character_name": {
          "description": "Character name",
          "type": "string"
        },
        "notes_tree": {
          "description": "Hierarchical notes tree",
          "items": {
            "$ref": "#/definitions/NoteTreeNode"
          },
          "type": "array"
        }
      },
      "required": [
        "character_name",
        "character_id"
      ],
      "title": "Character Notes Tree Data",
      "type": "object"
    },
    "FactionResponse": {
      "description": "Response containing a single faction",
      "properties": {
        "data": {
          "$ref": "#/definitions/Faction",
          "description": "Response data"
        }
      },
      "title": "Faction Response",
      "type": "object"
    },
    "FactionMembersResponse": {
      "description": "Response containing faction members",
      "properties": {
        "data": {
          "$ref": "#/definitions/FactionMembersData",
          "description": "Response data"
        }
      },
      "title": "Faction Members Response",
      "type": "object"
    },
    "NoteUpdateRequest": {
      "description": "Note update parameters",
      "properties": {
        "note": {
          "$ref": "#/definitions/NoteUpdateParams",
          "description": "Note parameters"
        }
      },
      "required": [
        "note"
      ],
      "title": "Note Update Request",
      "type": "object"
    },
    "LocationTreeResponse": {
      "description": "Response containing hierarchical location tree",
      "properties": {
        "data": {
          "description": "Response data",
          "items": {
            "$ref": "#/definitions/LocationTreeNode"
          },
          "type": "array"
        }
      },
      "title": "Location Tree Response",
      "type": "object"
    },
    "NoteLinksResponse": {
      "description": "Response containing note links",
      "properties": {
        "data": {
          "$ref": "#/definitions/NoteLinksData",
          "description": "Response data"
        }
      },
      "title": "Note Links Response",
      "type": "object"
    },
    "Quest": {
      "description": "A game quest",
      "example": {
        "content": "Find the lost treasure hidden in the ancient ruins.",
        "content_plain_text": "Find the lost treasure hidden in the ancient ruins.",
        "created_at": "2023-08-20T12:00:00Z",
        "game_id": "123e4567-e89b-12d3-a456-426614174000",
        "id": "623e4567-e89b-12d3-a456-426614174005",
        "name": "The Lost Treasure",
        "parent_id": "723e4567-e89b-12d3-a456-426614174006",
        "pinned": false,
        "tags": [
          "main",
          "treasure",
          "exploration"
        ],
        "updated_at": "2023-08-20T12:00:00Z",
        "user_id": 1
      },
      "properties": {
        "content": {
          "description": "Quest content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Quest content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "game_id": {
          "description": "Associated game ID",
          "format": "uuid",
          "type": "string"
        },
        "id": {
          "description": "Quest ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Quest name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent quest ID for hierarchical structure",
          "format": "uuid",
          "type": "string"
        },
        "pinned": {
          "description": "Whether this quest is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags associated with this quest",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        },
        "user_id": {
          "description": "Creator user ID",
          "type": "integer"
        }
      },
      "required": [
        "user_id",
        "game_id",
        "pinned",
        "content",
        "name",
        "id"
      ],
      "title": "Quest",
      "type": "object"
    },
    "PinnedEntitiesResponse": {
      "description": "Response containing all pinned entities for a game",
      "properties": {
        "data": {
          "$ref": "#/definitions/PinnedEntitiesData",
          "description": "Response data"
        }
      },
      "title": "Pinned Entities Response",
      "type": "object"
    },
    "NoteCreateParams": {
      "description": "Parameters for creating a new note",
      "example": {
        "content": "The dragon is hiding in the crystal cave beyond the misty mountains.",
        "content_plain_text": "The dragon is hiding in the crystal cave beyond the misty mountains.",
        "name": "Important Quest Notes",
        "tags": [
          "important",
          "dragon"
        ]
      },
      "properties": {
        "content": {
          "description": "Note content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Note content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Note name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent ID (note or other entity)",
          "format": "uuid",
          "type": "string"
        },
        "parent_type": {
          "description": "Type of parent entity (character, quest, location, faction)",
          "enum": [
            "character",
            "quest",
            "location",
            "faction"
          ],
          "type": "string"
        },
        "tags": {
          "description": "Tags for this note",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "content",
        "content",
        "name"
      ],
      "title": "Note Create Parameters",
      "type": "object"
    },
    "LocationTreeNode": {
      "description": "A node in the location hierarchy tree",
      "example": {
        "children": [],
        "content": "A mysterious cave hidden in the mountains, known for its glowing crystals.",
        "entity_type": "location",
        "id": "523e4567-e89b-12d3-a456-426614174004",
        "name": "The Crystal Cave",
        "parent_id": "723e4567-e89b-12d3-a456-426614174006",
        "tags": [
          "magical",
          "hidden",
          "dangerous"
        ],
        "type": "building"
      },
      "properties": {
        "children": {
          "description": "Child locations",
          "items": {
            "$ref": "#/definitions/LocationTreeNode"
          },
          "type": "array"
        },
        "content": {
          "description": "Location content",
          "type": "string"
        },
        "entity_type": {
          "description": "Entity type for URL building",
          "enum": [
            "location"
          ],
          "type": "string"
        },
        "id": {
          "description": "Location ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Location name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent location ID",
          "format": "uuid",
          "type": "string"
        },
        "tags": {
          "description": "Tags associated with this location",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "type": {
          "description": "Location type",
          "enum": [
            "continent",
            "nation",
            "region",
            "city",
            "settlement",
            "building",
            "complex"
          ],
          "type": "string"
        }
      },
      "required": [
        "entity_type",
        "type",
        "name",
        "id"
      ],
      "title": "Location Tree Node",
      "type": "object"
    },
    "GameResponse": {
      "description": "Response containing a single game",
      "properties": {
        "data": {
          "$ref": "#/definitions/Game",
          "description": "Response data"
        }
      },
      "title": "Game Response",
      "type": "object"
    },
    "CharacterCreateParams": {
      "description": "Parameters for creating a new character",
      "example": {
        "class": "Wizard",
        "content": "A wise and powerful wizard who guides the Fellowship.",
        "content_plain_text": "A wise and powerful wizard who guides the Fellowship.",
        "faction_role": "Elder Council Member",
        "image_url": "https://example.com/gandalf.jpg",
        "level": 20,
        "member_of_faction_id": "423e4567-e89b-12d3-a456-426614174003",
        "name": "Gandalf the Grey",
        "tags": [
          "npc",
          "ally",
          "wizard"
        ]
      },
      "properties": {
        "class": {
          "description": "Character class",
          "type": "string"
        },
        "content": {
          "description": "Character content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Character content as plain text",
          "type": "string"
        },
        "faction_role": {
          "description": "Role within the faction",
          "type": "string"
        },
        "image_url": {
          "description": "Character image URL",
          "type": "string"
        },
        "level": {
          "description": "Character level",
          "type": "integer"
        },
        "member_of_faction_id": {
          "description": "ID of faction this character belongs to",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Character name",
          "type": "string"
        },
        "tags": {
          "description": "Tags for this character",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "class",
        "level",
        "level",
        "class",
        "name"
      ],
      "title": "Character Create Parameters",
      "type": "object"
    },
    "EntityFaction": {
      "description": "Faction entity in game entities list",
      "example": {
        "content": "A secretive organization that seeks to control the realm from behind the scenes.",
        "content_plain_text": "A secretive organization that seeks to control the realm from behind the scenes.",
        "created_at": "2023-08-20T12:00:00Z",
        "id": "423e4567-e89b-12d3-a456-426614174003",
        "name": "The Shadow Council",
        "tags": [
          "secret",
          "political",
          "antagonist"
        ],
        "updated_at": "2023-08-20T12:00:00Z"
      },
      "properties": {
        "content": {
          "description": "Faction content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Faction content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "id": {
          "description": "Faction ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Faction name",
          "type": "string"
        },
        "tags": {
          "description": "Tags associated with this faction",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        }
      },
      "required": [
        "content",
        "name",
        "id"
      ],
      "title": "Entity Faction",
      "type": "object"
    },
    "EntityLocation": {
      "description": "Location entity in game entities list",
      "example": {
        "content": "A mysterious cave hidden in the mountains, known for its glowing crystals.",
        "content_plain_text": "A mysterious cave hidden in the mountains, known for its glowing crystals.",
        "created_at": "2023-08-20T12:00:00Z",
        "has_parent": true,
        "id": "523e4567-e89b-12d3-a456-426614174004",
        "name": "The Crystal Cave",
        "tags": [
          "magical",
          "hidden",
          "dangerous"
        ],
        "type": "building",
        "updated_at": "2023-08-20T12:00:00Z"
      },
      "properties": {
        "content": {
          "description": "Location content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Location content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "has_parent": {
          "description": "Whether this location has a parent location",
          "type": "boolean"
        },
        "id": {
          "description": "Location ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Location name",
          "type": "string"
        },
        "tags": {
          "description": "Tags associated with this location",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "type": {
          "description": "Location type",
          "enum": [
            "continent",
            "nation",
            "region",
            "city",
            "settlement",
            "building",
            "complex"
          ],
          "type": "string"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        }
      },
      "required": [
        "has_parent",
        "type",
        "name",
        "id"
      ],
      "title": "Entity Location",
      "type": "object"
    },
    "CharacterLinksData": {
      "description": "Links associated with a character",
      "properties": {
        "character_id": {
          "description": "Character ID",
          "format": "uuid",
          "type": "string"
        },
        "character_name": {
          "description": "Character name",
          "type": "string"
        },
        "links": {
          "$ref": "#/definitions/CharacterLinks",
          "description": "Associated entity links"
        }
      },
      "required": [
        "character_name",
        "character_id"
      ],
      "title": "Character Links Data",
      "type": "object"
    },
    "QuestsResponse": {
      "description": "Response containing a list of quests",
      "properties": {
        "data": {
          "description": "Response data",
          "items": {
            "$ref": "#/definitions/Quest"
          },
          "type": "array"
        }
      },
      "title": "Quests Response",
      "type": "object"
    },
    "QuestUpdateParams": {
      "description": "Parameters for updating an existing quest (partial updates supported)",
      "example": {
        "content": "Find the lost treasure hidden deep within the ancient ruins beneath the Crystal Cave. Beware of the guardian spirits.",
        "content_plain_text": "Find the lost treasure hidden deep within the ancient ruins beneath the Crystal Cave. Beware of the guardian spirits.",
        "parent_id": "723e4567-e89b-12d3-a456-426614174006",
        "pinned": false
      },
      "properties": {
        "content": {
          "description": "Quest content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Quest content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Quest name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent quest ID for hierarchical structure",
          "format": "uuid",
          "type": "string"
        },
        "pinned": {
          "description": "Whether this quest is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags for this quest",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "title": "Quest Update Parameters",
      "type": "object"
    },
    "LinkedLocation": {
      "description": "A location with relationship metadata",
      "properties": {
        "content": {
          "description": "Location content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Location content as plain text",
          "type": "string"
        },
        "description_meta": {
          "description": "Description of the relationship",
          "type": "string"
        },
        "id": {
          "description": "Location ID",
          "format": "uuid",
          "type": "string"
        },
        "is_active": {
          "description": "Whether the relationship is active",
          "type": "boolean"
        },
        "metadata": {
          "description": "Additional metadata",
          "type": "object"
        },
        "name": {
          "description": "Location name",
          "type": "string"
        },
        "relationship_type": {
          "description": "Type of relationship",
          "type": "string"
        },
        "strength": {
          "description": "Relationship strength (1-10)",
          "type": "integer"
        },
        "tags": {
          "description": "Location tags",
          "type": "array"
        }
      },
      "required": [
        "content",
        "name",
        "id"
      ],
      "title": "Linked Location",
      "type": "object"
    },
    "GameCreateParams": {
      "description": "Parameters for creating a new game",
      "example": {
        "content": "An epic adventure",
        "content_plain_text": "An epic adventure",
        "name": "My Campaign",
        "setting": "Fantasy"
      },
      "properties": {
        "content": {
          "description": "Game content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Game content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Game name",
          "type": "string"
        },
        "setting": {
          "description": "Game setting",
          "type": "string"
        }
      },
      "required": [
        "name",
        "name"
      ],
      "title": "Game Create Parameters",
      "type": "object"
    },
    "NoteLinksData": {
      "description": "Links associated with a note",
      "properties": {
        "links": {
          "$ref": "#/definitions/NoteLinks",
          "description": "Associated entity links"
        },
        "note_id": {
          "description": "Note ID",
          "format": "uuid",
          "type": "string"
        },
        "note_name": {
          "description": "Note name",
          "type": "string"
        }
      },
      "required": [
        "note_name",
        "note_id"
      ],
      "title": "Note Links Data",
      "type": "object"
    },
    "NoteResponse": {
      "description": "Response containing a single note",
      "properties": {
        "data": {
          "$ref": "#/definitions/Note",
          "description": "Response data"
        }
      },
      "title": "Note Response",
      "type": "object"
    },
    "Error": {
      "description": "Error response",
      "properties": {
        "errors": {
          "$ref": "#/definitions/ErrorDetails",
          "description": "Error details"
        }
      },
      "title": "Error",
      "type": "object"
    },
    "LocationsResponse": {
      "description": "Response containing a list of locations",
      "properties": {
        "data": {
          "description": "Response data",
          "items": {
            "$ref": "#/definitions/Location"
          },
          "type": "array"
        }
      },
      "title": "Locations Response",
      "type": "object"
    },
    "Game": {
      "description": "A game instance",
      "example": {
        "content": "An epic adventure",
        "content_plain_text": "An epic adventure",
        "created_at": "2023-08-20T12:00:00Z",
        "id": "123e4567-e89b-12d3-a456-426614174000",
        "name": "My Campaign",
        "owner_id": 1,
        "setting": "Fantasy",
        "updated_at": "2023-08-20T12:00:00Z"
      },
      "properties": {
        "content": {
          "description": "Game content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Game content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "id": {
          "description": "Game ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Game name",
          "type": "string"
        },
        "owner_id": {
          "description": "Owner user ID",
          "type": "integer"
        },
        "setting": {
          "description": "Game setting",
          "type": "string"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        }
      },
      "required": [
        "owner_id",
        "name",
        "id"
      ],
      "title": "Game",
      "type": "object"
    },
    "GameUpdateParams": {
      "description": "Parameters for updating an existing game (partial updates supported)",
      "example": {
        "name": "My Updated Campaign"
      },
      "properties": {
        "content": {
          "description": "Game content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Game content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Game name",
          "type": "string"
        },
        "setting": {
          "description": "Game setting",
          "type": "string"
        }
      },
      "title": "Game Update Parameters",
      "type": "object"
    },
    "QuestTreeResponse": {
      "description": "Response containing hierarchical quest tree",
      "properties": {
        "data": {
          "description": "Response data",
          "items": {
            "$ref": "#/definitions/QuestTreeNode"
          },
          "type": "array"
        }
      },
      "title": "Quest Tree Response",
      "type": "object"
    },
    "LoginResponse": {
      "description": "Successful login response",
      "example": {
        "token": "dGVzdF90b2tlbg==",
        "user": {
          "confirmed_at": "2023-08-20T12:00:00Z",
          "email": "user@example.com",
          "id": 1
        }
      },
      "properties": {
        "token": {
          "description": "Session token (Base64 encoded)",
          "type": "string"
        },
        "user": {
          "$ref": "#/definitions/User",
          "description": "User information"
        }
      },
      "required": [
        "user",
        "token"
      ],
      "title": "Login Response",
      "type": "object"
    },
    "Character": {
      "description": "A game character",
      "example": {
        "class": "Wizard",
        "content": "A wise and powerful wizard who guides the Fellowship.",
        "content_plain_text": "A wise and powerful wizard who guides the Fellowship.",
        "created_at": "2023-08-20T12:00:00Z",
        "faction_role": "Elder Council Member",
        "game_id": "123e4567-e89b-12d3-a456-426614174000",
        "id": "323e4567-e89b-12d3-a456-426614174002",
        "image_url": "https://example.com/gandalf.jpg",
        "level": 20,
        "member_of_faction_id": "423e4567-e89b-12d3-a456-426614174003",
        "name": "Gandalf the Grey",
        "pinned": false,
        "tags": [
          "npc",
          "ally",
          "wizard"
        ],
        "updated_at": "2023-08-20T12:00:00Z",
        "user_id": 1
      },
      "properties": {
        "class": {
          "description": "Character class",
          "type": "string"
        },
        "content": {
          "description": "Character content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Character content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "faction_role": {
          "description": "Role within the faction",
          "type": "string"
        },
        "game_id": {
          "description": "Associated game ID",
          "format": "uuid",
          "type": "string"
        },
        "id": {
          "description": "Character ID",
          "format": "uuid",
          "type": "string"
        },
        "image_url": {
          "description": "Character image URL",
          "type": "string"
        },
        "level": {
          "description": "Character level",
          "type": "integer"
        },
        "member_of_faction_id": {
          "description": "ID of faction this character belongs to",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Character name",
          "type": "string"
        },
        "pinned": {
          "description": "Whether this character is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags associated with this character",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        },
        "user_id": {
          "description": "Creator user ID",
          "type": "integer"
        }
      },
      "required": [
        "user_id",
        "game_id",
        "pinned",
        "level",
        "class",
        "name",
        "id"
      ],
      "title": "Character",
      "type": "object"
    },
    "QuestCreateParams": {
      "description": "Parameters for creating a new quest",
      "example": {
        "content": "Find the lost treasure hidden in the ancient ruins.",
        "content_plain_text": "Find the lost treasure hidden in the ancient ruins.",
        "name": "The Lost Treasure",
        "parent_id": "723e4567-e89b-12d3-a456-426614174006",
        "tags": [
          "main",
          "treasure"
        ]
      },
      "properties": {
        "content": {
          "description": "Quest content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Quest content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Quest name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent quest ID for hierarchical structure",
          "format": "uuid",
          "type": "string"
        },
        "tags": {
          "description": "Tags for this quest",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "content",
        "content",
        "name"
      ],
      "title": "Quest Create Parameters",
      "type": "object"
    },
    "Note": {
      "description": "A game note",
      "example": {
        "content": "The dragon is hiding in the crystal cave beyond the misty mountains.",
        "content_plain_text": "The dragon is hiding in the crystal cave beyond the misty mountains.",
        "created_at": "2023-08-20T12:00:00Z",
        "game_id": "123e4567-e89b-12d3-a456-426614174000",
        "id": "223e4567-e89b-12d3-a456-426614174001",
        "name": "Important Quest Notes",
        "pinned": false,
        "tags": [
          "important",
          "dragon",
          "quest"
        ],
        "updated_at": "2023-08-20T12:00:00Z",
        "user_id": 1
      },
      "properties": {
        "content": {
          "description": "Note content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Note content as plain text",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "datetime",
          "type": "string"
        },
        "game_id": {
          "description": "Associated game ID",
          "format": "uuid",
          "type": "string"
        },
        "id": {
          "description": "Note ID",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Note name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent ID (note or other entity)",
          "format": "uuid",
          "type": "string"
        },
        "parent_type": {
          "description": "Type of parent entity (character, quest, location, faction)",
          "enum": [
            "character",
            "quest",
            "location",
            "faction"
          ],
          "type": "string"
        },
        "pinned": {
          "description": "Whether this note is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags associated with this note",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Last update timestamp",
          "format": "datetime",
          "type": "string"
        },
        "user_id": {
          "description": "Author user ID",
          "type": "integer"
        }
      },
      "required": [
        "user_id",
        "game_id",
        "pinned",
        "content",
        "name",
        "id"
      ],
      "title": "Note",
      "type": "object"
    },
    "GameUpdateRequest": {
      "description": "Game update parameters",
      "properties": {
        "game": {
          "$ref": "#/definitions/GameUpdateParams",
          "description": "Game parameters"
        }
      },
      "required": [
        "game"
      ],
      "title": "Game Update Request",
      "type": "object"
    },
    "FactionCreateRequest": {
      "description": "Faction creation parameters",
      "properties": {
        "faction": {
          "$ref": "#/definitions/FactionCreateParams",
          "description": "Faction parameters"
        }
      },
      "required": [
        "faction"
      ],
      "title": "Faction Create Request",
      "type": "object"
    },
    "CharacterUpdateParams": {
      "description": "Parameters for updating an existing character (partial updates supported)",
      "example": {
        "content": "A wise and powerful wizard who guides the Fellowship through many perils.",
        "content_plain_text": "A wise and powerful wizard who guides the Fellowship through many perils.",
        "faction_role": "Elder Council Leader",
        "level": 21,
        "pinned": true
      },
      "properties": {
        "class": {
          "description": "Character class",
          "type": "string"
        },
        "content": {
          "description": "Character content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Character content as plain text",
          "type": "string"
        },
        "faction_role": {
          "description": "Role within the faction",
          "type": "string"
        },
        "image_url": {
          "description": "Character image URL",
          "type": "string"
        },
        "level": {
          "description": "Character level",
          "type": "integer"
        },
        "member_of_faction_id": {
          "description": "ID of faction this character belongs to",
          "format": "uuid",
          "type": "string"
        },
        "name": {
          "description": "Character name",
          "type": "string"
        },
        "pinned": {
          "description": "Whether this character is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags for this character",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "title": "Character Update Parameters",
      "type": "object"
    },
    "PinnedEntities": {
      "description": "Collection of pinned entities grouped by type",
      "properties": {
        "characters": {
          "description": "Pinned characters",
          "items": {
            "$ref": "#/definitions/Character"
          },
          "type": "array"
        },
        "factions": {
          "description": "Pinned factions",
          "items": {
            "$ref": "#/definitions/Faction"
          },
          "type": "array"
        },
        "locations": {
          "description": "Pinned locations",
          "items": {
            "$ref": "#/definitions/Location"
          },
          "type": "array"
        },
        "notes": {
          "description": "Pinned notes",
          "items": {
            "$ref": "#/definitions/Note"
          },
          "type": "array"
        },
        "quests": {
          "description": "Pinned quests",
          "items": {
            "$ref": "#/definitions/Quest"
          },
          "type": "array"
        }
      },
      "title": "Pinned Entities",
      "type": "object"
    },
    "CharacterNotesTreeResponse": {
      "description": "Response containing character notes tree",
      "properties": {
        "data": {
          "$ref": "#/definitions/CharacterNotesTreeData",
          "description": "Response data"
        }
      },
      "title": "Character Notes Tree Response",
      "type": "object"
    },
    "QuestCreateRequest": {
      "description": "Quest creation parameters",
      "properties": {
        "quest": {
          "$ref": "#/definitions/QuestCreateParams",
          "description": "Quest parameters"
        }
      },
      "required": [
        "quest"
      ],
      "title": "Quest Create Request",
      "type": "object"
    },
    "NoteUpdateParams": {
      "description": "Parameters for updating an existing note (partial updates supported)",
      "example": {
        "name": "Updated Quest Notes",
        "pinned": true
      },
      "properties": {
        "content": {
          "description": "Note content",
          "type": "string"
        },
        "content_plain_text": {
          "description": "Note content as plain text",
          "type": "string"
        },
        "name": {
          "description": "Note name",
          "type": "string"
        },
        "parent_id": {
          "description": "Parent ID (note or other entity)",
          "format": "uuid",
          "type": "string",
          "x-nullable": true
        },
        "parent_type": {
          "description": "Type of parent entity (character, quest, location, faction)",
          "enum": [
            "character",
            "quest",
            "location",
            "faction"
          ],
          "type": "string"
        },
        "pinned": {
          "description": "Whether this note is pinned",
          "type": "boolean"
        },
        "tags": {
          "description": "Tags for this note",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "title": "Note Update Parameters",
      "type": "object"
    },
    "FactionLinksData": {
      "description": "Links associated with a faction",
      "properties": {
        "faction_id": {
          "description": "Faction ID",
          "format": "uuid",
          "type": "string"
        },
        "faction_name": {
          "description": "Faction name",
          "type": "string"
        },
        "links": {
          "$ref": "#/definitions/FactionLinks",
          "description": "Associated entity links"
        }
      },
      "required": [
        "faction_name",
        "faction_id"
      ],
      "title": "Faction Links Data",
      "type": "object"
    },
    "QuestLinks": {
      "description": "Collections of entities linked to a quest",
      "properties": {
        "characters": {
          "description": "Linked characters with metadata",
          "items": {
            "$ref": "#/definitions/LinkedCharacter"
          },
          "type": "array"
        },
        "factions": {
          "description": "Linked factions with metadata",
          "items": {
            "$ref": "#/definitions/LinkedFaction"
          },
          "type": "array"
        },
        "locations": {
          "description": "Linked locations with metadata",
          "items": {
            "$ref": "#/definitions/LinkedLocation"
          },
          "type": "array"
        },
        "notes": {
          "description": "Linked notes with metadata",
          "items": {
            "$ref": "#/definitions/LinkedNote"
          },
          "type": "array"
        },
        "quests": {
          "description": "Linked quests with metadata",
          "items": {
            "$ref": "#/definitions/LinkedQuest"
          },
          "type": "array"
        }
      },
      "title": "Quest Links",
      "type": "object"
    }
  },
  "schemes": [
    "https"
  ],
  "paths": {
    "/api/games/{game_id}/factions/{faction_id}/links": {
      "get": {
        "description": "Get all entities linked to a faction",
        "operationId": "getFactionLinks",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction ID",
            "format": "uuid",
            "in": "path",
            "name": "faction_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/FactionLinksResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get faction links",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Link a faction to another entity (note, character, etc.)",
        "operationId": "createFactionLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction ID",
            "format": "uuid",
            "in": "path",
            "name": "faction_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link creation data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Create faction link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/locations": {
      "get": {
        "description": "Get all locations in a game",
        "operationId": "listLocations",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/LocationsResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "List locations",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new location in the game",
        "operationId": "createLocation",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Location to create",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LocationCreateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/LocationResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Create location",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/auth/logout": {
      "delete": {
        "description": "Invalidate current session token",
        "operationId": "logoutUser",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Logout user",
        "tags": [
          "Authentication"
        ]
      }
    },
    "/api/auth/login": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Authenticate user with email/password or magic link token",
        "operationId": "loginUser",
        "parameters": [
          {
            "description": "Login credentials",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LoginRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/LoginResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Login user",
        "tags": [
          "Authentication"
        ]
      }
    },
    "/api/games/{game_id}/locations/{location_id}/links/{entity_type}/{entity_id}": {
      "delete": {
        "description": "Remove a link between a location and another entity",
        "operationId": "deleteLocationLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Location ID",
            "format": "uuid",
            "in": "path",
            "name": "location_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "character",
              "faction",
              "location",
              "quest",
              "note"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Delete location link",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update link metadata between a location and another entity",
        "operationId": "updateLocationLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Location ID",
            "format": "uuid",
            "in": "path",
            "name": "location_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "note",
              "character",
              "faction",
              "quest",
              "location"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link update data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "properties": {
                "entity_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "entity_type": {
                  "type": "string"
                },
                "location_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "message": {
                  "type": "string"
                },
                "updated_at": {
                  "format": "date-time",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Update a location link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/members": {
      "get": {
        "description": "Retrieve a list of all members in the specified game",
        "operationId": "listGameMembers",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/MembersResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "List game members",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Add a user as a member to the specified game",
        "operationId": "addGameMember",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "User ID to add",
            "in": "formData",
            "name": "user_id",
            "required": true,
            "type": "integer"
          },
          {
            "description": "Member role (default: 'member')",
            "in": "formData",
            "name": "role",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Add a member to a game",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/characters/{id}/notes/tree": {
      "get": {
        "description": "Get hierarchical tree of notes associated with a character",
        "operationId": "getCharacterNotesTree",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharacterNotesTreeResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get character notes tree",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/locations/{id}": {
      "delete": {
        "description": "Delete a location from the game",
        "operationId": "deleteLocation",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Location ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Delete location",
        "tags": [
          "GameMaster"
        ]
      },
      "get": {
        "description": "Get a specific location by ID",
        "operationId": "getLocation",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Location ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/LocationResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get location",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update an existing location",
        "operationId": "updateLocation",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Location ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Location updates",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LocationUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/LocationResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Update location",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/factions": {
      "get": {
        "description": "Get all factions in a game",
        "operationId": "listFactions",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/FactionsResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "List factions",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new faction in the game",
        "operationId": "createFaction",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction to create",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/FactionCreateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/FactionResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Create faction",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/characters/{character_id}/links/{entity_type}/{entity_id}": {
      "delete": {
        "description": "Remove a link between a character and another entity",
        "operationId": "deleteCharacterLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "character_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "note",
              "faction",
              "location",
              "quest",
              "character"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Delete character link",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update link metadata between a character and another entity",
        "operationId": "updateCharacterLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "character_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "note",
              "faction",
              "location",
              "quest",
              "character"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link update data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "properties": {
                "character_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "entity_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "entity_type": {
                  "type": "string"
                },
                "message": {
                  "type": "string"
                },
                "updated_at": {
                  "format": "date-time",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Update a character link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/links": {
      "get": {
        "description": "Retrieve all entities (notes, characters, factions, locations, quests) for the specified game",
        "operationId": "listGameEntities",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/EntitiesResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "List game entities",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/notes/{note_id}/links": {
      "get": {
        "description": "Retrieve all entities linked to a specific note",
        "operationId": "getNoteLinks",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Note ID",
            "format": "uuid",
            "in": "path",
            "name": "note_id",
            "required": true,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/NoteLinksResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "List note links",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a link between a note and another entity (character, faction, location, quest)",
        "operationId": "createNoteLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Note ID",
            "format": "uuid",
            "in": "path",
            "name": "note_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link creation data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "properties": {
                "entity_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "entity_type": {
                  "type": "string"
                },
                "message": {
                  "type": "string"
                },
                "note_id": {
                  "format": "uuid",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Create a link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/locations/tree": {
      "get": {
        "description": "Get hierarchical tree structure of all locations in a game",
        "operationId": "getLocationTree",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/LocationTreeResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get location tree",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/characters/{character_id}/primary-faction": {
      "delete": {
        "description": "Remove a character's primary faction while preserving the CharacterFaction relationship record",
        "operationId": "removeCharacterPrimaryFaction",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "character_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharacterResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Remove character's primary faction",
        "tags": [
          "GameMaster"
        ]
      },
      "get": {
        "description": "Get the primary faction details for a character",
        "operationId": "getCharacterPrimaryFaction",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "character_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharacterPrimaryFactionResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get character's primary faction",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Set or update a character's primary faction and role, automatically syncing with CharacterFaction relationship",
        "operationId": "setCharacterPrimaryFaction",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "character_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Primary faction data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SetPrimaryFactionRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharacterResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Set character's primary faction",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/characters/{character_id}/pin": {
      "put": {
        "description": "Pin a character for quick access",
        "operationId": "pinCharacter",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "character_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharacterResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Pin character",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/factions/{faction_id}/members": {
      "get": {
        "description": "Get all characters that are members of a faction (using member_of_faction_id)",
        "operationId": "getFactionMembers",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction ID",
            "format": "uuid",
            "in": "path",
            "name": "faction_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/FactionMembersResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get faction members",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/quests": {
      "get": {
        "description": "Get all quests in a game",
        "operationId": "listQuests",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/QuestsResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "List quests",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new quest in the game",
        "operationId": "createQuest",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Quest to create",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/QuestCreateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/QuestResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Create quest",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/notes/{id}": {
      "delete": {
        "description": "Delete a specific note by its ID",
        "operationId": "deleteNote",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Note ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Delete a note",
        "tags": [
          "GameMaster"
        ]
      },
      "get": {
        "description": "Retrieve a specific note by its ID",
        "operationId": "getNote",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Note ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/NoteResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Get a note",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update a specific note with the provided parameters",
        "operationId": "updateNote",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Note ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Note parameters",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/NoteUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/NoteResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Update a note",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/characters/{character_id}/links": {
      "get": {
        "description": "Get all entities linked to a character",
        "operationId": "getCharacterLinks",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "character_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharacterLinksResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get character links",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Link a character to another entity (note, faction, etc.)",
        "operationId": "createCharacterLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "character_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link creation data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Create character link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/characters": {
      "get": {
        "description": "Get all characters in a game",
        "operationId": "listCharacters",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharactersResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "List characters",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new character in the game",
        "operationId": "createCharacter",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character to create",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CharacterCreateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/CharacterResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Create character",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{id}": {
      "delete": {
        "description": "Delete a specific game by its ID",
        "operationId": "deleteGame",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Delete a game",
        "tags": [
          "GameMaster"
        ]
      },
      "get": {
        "description": "Retrieve a specific game by its ID",
        "operationId": "getGame",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/GameResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Get a game",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update a specific game with the provided parameters",
        "operationId": "updateGame",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Game parameters",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/GameUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/GameResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Update a game",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/tree": {
      "get": {
        "description": "Get comprehensive hierarchical tree of entity relationships within a game",
        "operationId": "getGameEntityTree",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Maximum depth to traverse (default: 3, max: 10)",
            "in": "query",
            "name": "depth",
            "required": false,
            "type": "integer"
          },
          {
            "description": "Entity type to start from (character, faction, location, quest, note)",
            "in": "query",
            "name": "start_entity_type",
            "required": false,
            "type": "string"
          },
          {
            "description": "Entity ID to start from (requires start_entity_type)",
            "format": "uuid",
            "in": "query",
            "name": "start_entity_id",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/EntityTreeResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Get entity tree",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/characters/{character_id}/unpin": {
      "put": {
        "description": "Unpin a character",
        "operationId": "unpinCharacter",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "character_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharacterResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Unpin character",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/auth/signup": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Register a new user with email and password",
        "operationId": "signupUser",
        "parameters": [
          {
            "description": "Signup credentials",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SignupRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/LoginResponse"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Sign up new user",
        "tags": [
          "Authentication"
        ]
      }
    },
    "/api/auth/status": {
      "get": {
        "description": "Check if user is authenticated and get user info",
        "operationId": "getAuthStatus",
        "parameters": [],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/AuthStatusResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get auth status",
        "tags": [
          "Authentication"
        ]
      }
    },
    "/api/games/{game_id}/quests/{id}": {
      "delete": {
        "description": "Delete a quest from the game",
        "operationId": "deleteQuest",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Quest ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Delete quest",
        "tags": [
          "GameMaster"
        ]
      },
      "get": {
        "description": "Get a specific quest by ID",
        "operationId": "getQuest",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Quest ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/QuestResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get quest",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update an existing quest",
        "operationId": "updateQuest",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Quest ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Quest updates",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/QuestUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/QuestResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Update quest",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/locations/{location_id}/links": {
      "get": {
        "description": "Get all entities linked to a location",
        "operationId": "getLocationLinks",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Location ID",
            "format": "uuid",
            "in": "path",
            "name": "location_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/LocationLinksResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get location links",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Link a location to another entity (note, faction, etc.)",
        "operationId": "createLocationLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Location ID",
            "format": "uuid",
            "in": "path",
            "name": "location_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link creation data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Create location link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/notes/{note_id}/links/{entity_type}/{entity_id}": {
      "delete": {
        "description": "Remove a link between a note and another entity",
        "operationId": "deleteNoteLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Note ID",
            "format": "uuid",
            "in": "path",
            "name": "note_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "character",
              "faction",
              "location",
              "quest",
              "note"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Delete a link",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update link metadata between a note and another entity",
        "operationId": "updateNoteLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Note ID",
            "format": "uuid",
            "in": "path",
            "name": "note_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "character",
              "faction",
              "location",
              "quest",
              "note"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link update data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "properties": {
                "entity_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "entity_type": {
                  "type": "string"
                },
                "message": {
                  "type": "string"
                },
                "note_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "updated_at": {
                  "format": "date-time",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Update a link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/characters/{id}": {
      "delete": {
        "description": "Delete a character from the game",
        "operationId": "deleteCharacter",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Delete character",
        "tags": [
          "GameMaster"
        ]
      },
      "get": {
        "description": "Get a specific character by ID",
        "operationId": "getCharacter",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharacterResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get character",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update an existing character",
        "operationId": "updateCharacter",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Character updates",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CharacterUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/CharacterResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Update character",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/quests/{quest_id}/links": {
      "get": {
        "description": "Get all entities linked to a quest",
        "operationId": "getQuestLinks",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Quest ID",
            "format": "uuid",
            "in": "path",
            "name": "quest_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/QuestLinksResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get quest links",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Link a quest to another entity (note, character, faction, location)",
        "operationId": "createQuestLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Quest ID",
            "format": "uuid",
            "in": "path",
            "name": "quest_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link creation data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Create quest link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/factions/{id}": {
      "delete": {
        "description": "Delete a faction from the game",
        "operationId": "deleteFaction",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Delete faction",
        "tags": [
          "GameMaster"
        ]
      },
      "get": {
        "description": "Get a specific faction by ID",
        "operationId": "getFaction",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/FactionResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get faction",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update an existing faction",
        "operationId": "updateFaction",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction ID",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction updates",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/FactionUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/FactionResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Update faction",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/members/{user_id}": {
      "delete": {
        "description": "Remove a user from the specified game",
        "operationId": "removeGameMember",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "User ID to remove",
            "in": "path",
            "name": "user_id",
            "required": true,
            "type": "integer"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Remove a member from a game",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/factions/{faction_id}/links/{entity_type}/{entity_id}": {
      "delete": {
        "description": "Remove a link between a faction and another entity",
        "operationId": "deleteFactionLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction ID",
            "format": "uuid",
            "in": "path",
            "name": "faction_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "character",
              "location",
              "quest",
              "note",
              "faction"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Delete faction link",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update link metadata between a faction and another entity",
        "operationId": "updateFactionLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Faction ID",
            "format": "uuid",
            "in": "path",
            "name": "faction_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "note",
              "character",
              "location",
              "quest",
              "faction"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link update data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "properties": {
                "entity_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "entity_type": {
                  "type": "string"
                },
                "faction_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "message": {
                  "type": "string"
                },
                "updated_at": {
                  "format": "date-time",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Update a faction link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/notes": {
      "get": {
        "description": "Retrieve all notes for a specific game",
        "operationId": "listNotes",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/NotesResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "List notes",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new note for the specified game",
        "operationId": "createNote",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Note parameters",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/NoteCreateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/NoteResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Create a note",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/pinned": {
      "get": {
        "description": "Get all pinned entities (characters, notes, factions, locations, quests) for a game",
        "operationId": "listPinnedEntities",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/PinnedEntitiesResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get all pinned entities",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games": {
      "get": {
        "description": "Retrieve a list of all games accessible to the current user",
        "operationId": "listGames",
        "parameters": [],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/GamesResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "List all games",
        "tags": [
          "GameMaster"
        ]
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new game with the provided parameters",
        "operationId": "createGame",
        "parameters": [
          {
            "description": "Game parameters",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/GameCreateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/GameResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Create a new game",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/quests/{quest_id}/links/{entity_type}/{entity_id}": {
      "delete": {
        "description": "Remove a link between a quest and another entity",
        "operationId": "deleteQuestLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Quest ID",
            "format": "uuid",
            "in": "path",
            "name": "quest_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "character",
              "faction",
              "location",
              "note",
              "quest"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Delete quest link",
        "tags": [
          "GameMaster"
        ]
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Update link metadata between a quest and another entity",
        "operationId": "updateQuestLink",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Quest ID",
            "format": "uuid",
            "in": "path",
            "name": "quest_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity type",
            "enum": [
              "note",
              "character",
              "faction",
              "location",
              "quest"
            ],
            "in": "path",
            "name": "entity_type",
            "required": true,
            "type": "string"
          },
          {
            "description": "Entity ID",
            "format": "uuid",
            "in": "path",
            "name": "entity_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Link update data",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LinkUpdateRequest"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "properties": {
                "entity_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "entity_type": {
                  "type": "string"
                },
                "message": {
                  "type": "string"
                },
                "quest_id": {
                  "format": "uuid",
                  "type": "string"
                },
                "updated_at": {
                  "format": "date-time",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Update a quest link",
        "tags": [
          "GameMaster"
        ]
      }
    },
    "/api/games/{game_id}/quests/tree": {
      "get": {
        "description": "Get hierarchical tree structure of all quests in a game",
        "operationId": "getQuestTree",
        "parameters": [
          {
            "description": "Game ID",
            "format": "uuid",
            "in": "path",
            "name": "game_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/QuestTreeResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "security": [
          {
            "Bearer": []
          }
        ],
        "summary": "Get quest tree",
        "tags": [
          "GameMaster"
        ]
      }
    }
  },
  "swagger": "2.0",
  "security": [
    {
      "Bearer": []
    }
  ],
  "securityDefinitions": {
    "Bearer": {
      "in": "header",
      "name": "Authorization",
      "type": "apiKey",
      "description": "Bearer token authentication"
    }
  }
}
</file>

<file path="src/api/types.gen.ts">
// This file is auto-generated by @hey-api/openapi-ts

/**
 * Login Request
 * Login credentials - either email/password or magic link token
 */
export type LoginRequest = {
    /**
     * User email
     */
    email?: string;
    /**
     * User password
     */
    password?: string;
    /**
     * Magic link token
     */
    token?: string;
};

/**
 * Entities Response
 * Response containing all game entities
 */
export type EntitiesResponse = {
    data?: EntitiesData;
};

/**
 * Link Update Request
 * Request to update link metadata between entities
 */
export type LinkUpdateRequest = {
    /**
     * Free-form description of the relationship
     */
    description?: string;
    /**
     * Whether the relationship is currently active
     */
    is_active?: boolean;
    /**
     * Additional flexible metadata as JSON
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Type of relationship between entities
     */
    relationship_type?: string;
    /**
     * Relationship strength/importance (1-10)
     */
    strength?: number;
};

/**
 * Members Response
 * Response containing a list of game members
 */
export type MembersResponse = {
    /**
     * Response data
     */
    data?: Array<Member>;
};

/**
 * Entity Character
 * Character entity in game entities list
 */
export type EntityCharacter = {
    /**
     * Character class
     */
    class: string;
    /**
     * Character content
     */
    content?: string;
    /**
     * Character content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Role within the faction
     */
    faction_role?: string;
    /**
     * Character ID
     */
    id: string;
    /**
     * Character image URL
     */
    image_url?: string;
    /**
     * Character level
     */
    level: number;
    /**
     * ID of faction this character belongs to
     */
    member_of_faction_id?: string;
    /**
     * Character name
     */
    name: string;
    /**
     * Tags associated with this character
     */
    tags?: Array<string>;
    /**
     * Last update timestamp
     */
    updated_at?: string;
};

/**
 * Location Create Request
 * Location creation parameters
 */
export type LocationCreateRequest = {
    location: LocationCreateParams;
};

/**
 * Faction Create Parameters
 * Parameters for creating a new faction
 */
export type FactionCreateParams = {
    /**
     * Faction content
     */
    content: string;
    /**
     * Faction content as plain text
     */
    content_plain_text?: string;
    /**
     * Faction name
     */
    name: string;
    /**
     * Tags for this faction
     */
    tags?: Array<string>;
};

/**
 * User
 * User information
 */
export type User = {
    /**
     * Email confirmation timestamp
     */
    confirmed_at?: string;
    /**
     * User email
     */
    email: string;
    /**
     * User ID
     */
    id: number;
};

/**
 * Location Links
 * Collections of entities linked to a location
 */
export type LocationLinks = {
    /**
     * Linked characters with metadata
     */
    characters?: Array<LinkedCharacter>;
    /**
     * Linked factions with metadata
     */
    factions?: Array<LinkedFaction>;
    /**
     * Linked locations with metadata
     */
    locations?: Array<LinkedLocation>;
    /**
     * Linked notes with metadata
     */
    notes?: Array<LinkedNote>;
    /**
     * Linked quests with metadata
     */
    quests?: Array<LinkedQuest>;
};

/**
 * Linked Quest
 * A quest with relationship metadata
 */
export type LinkedQuest = {
    /**
     * Quest content
     */
    content: string;
    /**
     * Quest content as plain text
     */
    content_plain_text?: string;
    /**
     * Description of the relationship
     */
    description_meta?: string;
    /**
     * Quest ID
     */
    id: string;
    /**
     * Whether the relationship is active
     */
    is_active?: boolean;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Quest name
     */
    name: string;
    /**
     * Type of relationship
     */
    relationship_type?: string;
    /**
     * Relationship strength (1-10)
     */
    strength?: number;
    /**
     * Quest tags
     */
    tags?: Array<unknown>;
};

/**
 * Entities
 * Collection of game entities
 */
export type Entities = {
    /**
     * Characters list
     */
    characters?: Array<EntityCharacter>;
    /**
     * Factions list
     */
    factions?: Array<EntityFaction>;
    /**
     * Locations list
     */
    locations?: Array<EntityLocation>;
    /**
     * Notes list
     */
    notes?: Array<EntityNote>;
    /**
     * Quests list
     */
    quests?: Array<EntityQuest>;
};

export type LinkedEntityBase = {
    /**
     * Description of the relationship
     */
    description?: string;
    /**
     * Whether the relationship is active
     */
    is_active?: boolean;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Type of relationship
     */
    relationship_type?: string;
    /**
     * Relationship strength (1-10)
     */
    strength?: number;
};

/**
 * Character Links Response
 * Response containing character links
 */
export type CharacterLinksResponse = {
    data?: CharacterLinksData;
};

/**
 * Entity Quest
 * Quest entity in game entities list
 */
export type EntityQuest = {
    /**
     * Quest content
     */
    content: string;
    /**
     * Quest content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Quest ID
     */
    id: string;
    /**
     * Quest name
     */
    name: string;
    /**
     * Parent quest ID for hierarchical structure
     */
    parent_id?: string;
    /**
     * Tags associated with this quest
     */
    tags?: Array<string>;
    /**
     * Last update timestamp
     */
    updated_at?: string;
};

/**
 * Error Details
 * Detailed error information
 */
export type ErrorDetails = {
    [key: string]: unknown;
};

/**
 * Game Create Request
 * Game creation parameters
 */
export type GameCreateRequest = {
    game: GameCreateParams;
};

/**
 * Entities Data
 * Game entities data structure
 */
export type EntitiesData = {
    entities?: Entities;
    /**
     * Game ID
     */
    game_id: string;
    /**
     * Game name
     */
    game_name: string;
};

/**
 * Characters Response
 * Response containing a list of characters
 */
export type CharactersResponse = {
    /**
     * Response data
     */
    data?: Array<Character>;
};

/**
 * Faction Update Request
 * Faction update parameters
 */
export type FactionUpdateRequest = {
    faction: FactionUpdateParams;
};

/**
 * Faction Members Data
 * Characters that are members of a faction
 */
export type FactionMembersData = {
    /**
     * Faction ID
     */
    faction_id: string;
    /**
     * Faction name
     */
    faction_name: string;
    /**
     * Faction member characters
     */
    members?: Array<Character>;
};

/**
 * Entity Tree Data
 * Entity relationship tree data grouped by entity types or single tree
 */
export type EntityTreeData = {
    /**
     * Character trees
     */
    characters?: Array<EntityTreeNode>;
    /**
     * Faction trees
     */
    factions?: Array<EntityTreeNode>;
    /**
     * Location trees
     */
    locations?: Array<EntityTreeNode>;
    /**
     * Note trees
     */
    notes?: Array<EntityTreeNode>;
    /**
     * Quest trees
     */
    quests?: Array<EntityTreeNode>;
};

/**
 * Quest Tree Node
 * A node in the quest hierarchy tree
 */
export type QuestTreeNode = {
    /**
     * Child quests
     */
    children?: Array<QuestTreeNode>;
    /**
     * Quest content
     */
    content?: string;
    /**
     * Quest content as plain text
     */
    content_plain_text?: string;
    /**
     * Entity type for URL building
     */
    entity_type: 'quest';
    /**
     * Quest ID
     */
    id: string;
    /**
     * Quest name
     */
    name: string;
    /**
     * Parent quest ID
     */
    parent_id?: string;
    /**
     * Tags associated with this quest
     */
    tags?: Array<string>;
};

/**
 * Character Create Request
 * Character creation parameters
 */
export type CharacterCreateRequest = {
    character: CharacterCreateParams;
};

/**
 * Entity Note
 * Note entity in game entities list
 */
export type EntityNote = {
    /**
     * Note content
     */
    content: string;
    /**
     * Note content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Note ID
     */
    id: string;
    /**
     * Note name
     */
    name: string;
    /**
     * Tags associated with this note
     */
    tags?: Array<string>;
    /**
     * Last update timestamp
     */
    updated_at?: string;
};

/**
 * Note Links
 * Collections of entities linked to a note
 */
export type NoteLinks = {
    /**
     * Linked characters with metadata
     */
    characters?: Array<LinkedCharacter>;
    /**
     * Linked factions with metadata
     */
    factions?: Array<LinkedFaction>;
    /**
     * Linked locations with metadata
     */
    locations?: Array<LinkedLocation>;
    /**
     * Linked notes with metadata
     */
    notes?: Array<LinkedNote>;
    /**
     * Linked quests with metadata
     */
    quests?: Array<LinkedQuest>;
};

/**
 * Faction Links
 * Collections of entities linked to a faction
 */
export type FactionLinks = {
    /**
     * Linked characters with metadata
     */
    characters?: Array<LinkedCharacter>;
    /**
     * Linked factions with metadata
     */
    factions?: Array<LinkedFaction>;
    /**
     * Linked locations with metadata
     */
    locations?: Array<LinkedLocation>;
    /**
     * Linked notes with metadata
     */
    notes?: Array<LinkedNote>;
    /**
     * Linked quests with metadata
     */
    quests?: Array<LinkedQuest>;
};

/**
 * Factions Response
 * Response containing a list of factions
 */
export type FactionsResponse = {
    /**
     * Response data
     */
    data?: Array<Faction>;
};

/**
 * Note Tree Node
 * A node in the note hierarchy tree
 */
export type NoteTreeNode = {
    /**
     * Child notes
     */
    children?: Array<NoteTreeNode>;
    /**
     * Note content
     */
    content: string;
    /**
     * Note content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Entity type for URL building
     */
    entity_type: 'note';
    /**
     * Note ID
     */
    id: string;
    /**
     * Note name
     */
    name: string;
    /**
     * Parent ID (note or other entity)
     */
    parent_id?: string;
    /**
     * Type of parent entity (character, quest, location, faction)
     */
    parent_type?: 'character' | 'quest' | 'location' | 'faction';
    /**
     * Tags associated with this note
     */
    tags?: Array<string>;
    /**
     * Last update timestamp
     */
    updated_at?: string;
};

/**
 * Quest Links Data
 * Links associated with a quest
 */
export type QuestLinksData = {
    links?: QuestLinks;
    /**
     * Quest ID
     */
    quest_id: string;
    /**
     * Quest name
     */
    quest_name: string;
};

/**
 * Character Primary Faction Response
 * Response containing character's primary faction data
 */
export type CharacterPrimaryFactionResponse = {
    data?: CharacterPrimaryFactionData;
};

/**
 * Quest Response
 * Response containing a single quest
 */
export type QuestResponse = {
    data?: Quest;
};

/**
 * Location
 * A game location
 */
export type Location = {
    /**
     * Location content
     */
    content?: string;
    /**
     * Location content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Associated game ID
     */
    game_id: string;
    /**
     * Location ID
     */
    id: string;
    /**
     * Location name
     */
    name: string;
    /**
     * Parent location ID
     */
    parent_id?: string;
    /**
     * Whether this location is pinned
     */
    pinned: boolean;
    /**
     * Tags associated with this location
     */
    tags?: Array<string>;
    /**
     * Location type
     */
    type: 'continent' | 'nation' | 'region' | 'city' | 'settlement' | 'building' | 'complex';
    /**
     * Last update timestamp
     */
    updated_at?: string;
    /**
     * Creator user ID
     */
    user_id: number;
};

/**
 * Location Update Request
 * Location update parameters
 */
export type LocationUpdateRequest = {
    location: LocationUpdateParams;
};

/**
 * Link Request
 * Request to create a link between entities
 */
export type LinkRequest = {
    /**
     * Free-form description of the relationship
     */
    description?: string;
    /**
     * Entity ID to link
     */
    entity_id: string;
    /**
     * Entity type to link
     */
    entity_type: 'character' | 'faction' | 'location' | 'quest' | 'note';
    /**
     * Whether the relationship is currently active
     */
    is_active?: boolean;
    /**
     * Additional flexible metadata as JSON
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Type of relationship between entities
     */
    relationship_type?: string;
    /**
     * Relationship strength/importance (1-10)
     */
    strength?: number;
};

/**
 * Games Response
 * Response containing a list of games
 */
export type GamesResponse = {
    /**
     * Response data
     */
    data?: Array<Game>;
};

/**
 * Member
 * A game member
 */
export type Member = {
    /**
     * User email
     */
    email: string;
    /**
     * Join timestamp
     */
    joined_at?: string;
    /**
     * Member role
     */
    role: string;
    /**
     * User ID
     */
    user_id: number;
};

/**
 * Faction
 * A game faction
 */
export type Faction = {
    /**
     * Faction content
     */
    content: string;
    /**
     * Faction content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Associated game ID
     */
    game_id: string;
    /**
     * Faction ID
     */
    id: string;
    /**
     * Faction name
     */
    name: string;
    /**
     * Whether this faction is pinned
     */
    pinned: boolean;
    /**
     * Tags associated with this faction
     */
    tags?: Array<string>;
    /**
     * Last update timestamp
     */
    updated_at?: string;
    /**
     * Creator user ID
     */
    user_id: number;
};

/**
 * Pinned Entities Data
 * All pinned entities for a game
 */
export type PinnedEntitiesData = {
    /**
     * Game ID
     */
    game_id: string;
    pinned_entities: PinnedEntities;
    /**
     * Total number of pinned entities
     */
    total_count: number;
};

/**
 * Note Create Request
 * Note creation parameters
 */
export type NoteCreateRequest = {
    note: NoteCreateParams;
};

/**
 * Location Response
 * Response containing a single location
 */
export type LocationResponse = {
    data?: Location;
};

/**
 * Character Response
 * Response containing a single character
 */
export type CharacterResponse = {
    data?: Character;
};

/**
 * Location Links Data
 * Links associated with a location
 */
export type LocationLinksData = {
    links?: LocationLinks;
    /**
     * Location ID
     */
    location_id: string;
    /**
     * Location name
     */
    location_name: string;
};

/**
 * Character Links
 * Collections of entities linked to a character
 */
export type CharacterLinks = {
    /**
     * Linked characters with metadata
     */
    characters?: Array<LinkedCharacter>;
    /**
     * Linked factions with metadata
     */
    factions?: Array<LinkedFaction>;
    /**
     * Linked locations with metadata
     */
    locations?: Array<LinkedLocation>;
    /**
     * Linked notes with metadata
     */
    notes?: Array<LinkedNote>;
    /**
     * Linked quests with metadata
     */
    quests?: Array<LinkedQuest>;
};

/**
 * Location Links Response
 * Response containing location links
 */
export type LocationLinksResponse = {
    data?: LocationLinksData;
};

/**
 * Entity Tree Response
 * Response containing hierarchical tree of entity relationships
 */
export type EntityTreeResponse = {
    data?: EntityTreeData;
};

/**
 * Quest Links Response
 * Response containing quest links
 */
export type QuestLinksResponse = {
    data?: QuestLinksData;
};

/**
 * Signup Request
 * User registration credentials
 */
export type SignupRequest = {
    /**
     * User email
     */
    email: string;
    /**
     * User password
     */
    password: string;
};

/**
 * Notes Response
 * Response containing a list of notes
 */
export type NotesResponse = {
    /**
     * Response data
     */
    data?: Array<Note>;
};

/**
 * Location Create Parameters
 * Parameters for creating a new location
 */
export type LocationCreateParams = {
    /**
     * Location content
     */
    content?: string;
    /**
     * Location content as plain text
     */
    content_plain_text?: string;
    /**
     * Location name
     */
    name: string;
    /**
     * Parent location ID
     */
    parent_id?: string;
    /**
     * Tags for this location
     */
    tags?: Array<string>;
    /**
     * Location type
     */
    type: 'continent' | 'nation' | 'region' | 'city' | 'settlement' | 'building' | 'complex';
};

/**
 * Faction Update Parameters
 * Parameters for updating an existing faction (partial updates supported)
 */
export type FactionUpdateParams = {
    /**
     * Faction content
     */
    content?: string;
    /**
     * Faction content as plain text
     */
    content_plain_text?: string;
    /**
     * Faction name
     */
    name?: string;
    /**
     * Whether this faction is pinned
     */
    pinned?: boolean;
    /**
     * Tags for this faction
     */
    tags?: Array<string>;
};

/**
 * Linked Character
 * A character with relationship metadata
 */
export type LinkedCharacter = {
    /**
     * Character content
     */
    content: string;
    /**
     * Character content as plain text
     */
    content_plain_text?: string;
    /**
     * Description of the relationship
     */
    description_meta?: string;
    /**
     * Role within the faction
     */
    faction_role?: string;
    /**
     * Character ID
     */
    id: string;
    /**
     * Whether the relationship is active
     */
    is_active?: boolean;
    /**
     * ID of faction this character belongs to
     */
    member_of_faction_id?: string;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Character name
     */
    name: string;
    /**
     * Type of relationship
     */
    relationship_type?: string;
    /**
     * Relationship strength (1-10)
     */
    strength?: number;
    /**
     * Character tags
     */
    tags?: Array<unknown>;
};

/**
 * Character Primary Faction Data
 * Primary faction information for a character
 */
export type CharacterPrimaryFactionData = {
    /**
     * Character ID
     */
    character_id: string;
    faction: Faction;
    /**
     * Character's role in the faction
     */
    role: string;
};

/**
 * Quest Update Request
 * Quest update parameters
 */
export type QuestUpdateRequest = {
    quest: QuestUpdateParams;
};

/**
 * Set Primary Faction Request
 * Parameters for setting a character's primary faction
 */
export type SetPrimaryFactionRequest = {
    /**
     * Faction ID
     */
    faction_id: string;
    /**
     * Character's role in the faction
     */
    role: string;
};

/**
 * Entity Tree Node
 * A single node in the entity relationship tree
 */
export type EntityTreeNode = {
    /**
     * Child entities
     */
    children: Array<EntityTreeNode>;
    /**
     * Relationship description
     */
    description?: string;
    /**
     * Entity ID
     */
    id: string;
    /**
     * Whether relationship is active
     */
    is_active?: boolean;
    /**
     * Additional relationship metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Entity name
     */
    name: string;
    /**
     * Type of relationship to parent
     */
    relationship_type?: string;
    /**
     * Relationship strength (1-5)
     */
    strength?: number;
    /**
     * Entity type
     */
    type: 'character' | 'faction' | 'location' | 'quest' | 'note';
};

/**
 * Faction Links Response
 * Response containing faction links
 */
export type FactionLinksResponse = {
    data?: FactionLinksData;
};

/**
 * Character Update Request
 * Character update parameters
 */
export type CharacterUpdateRequest = {
    character: CharacterUpdateParams;
};

/**
 * Linked Faction
 * A faction with relationship metadata
 */
export type LinkedFaction = {
    /**
     * Faction content
     */
    content: string;
    /**
     * Faction content as plain text
     */
    content_plain_text?: string;
    /**
     * Description of the relationship
     */
    description_meta?: string;
    /**
     * Faction ID
     */
    id: string;
    /**
     * Whether the relationship is active
     */
    is_active?: boolean;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Faction name
     */
    name: string;
    /**
     * Type of relationship
     */
    relationship_type?: string;
    /**
     * Relationship strength (1-10)
     */
    strength?: number;
    /**
     * Faction tags
     */
    tags?: Array<unknown>;
};

/**
 * Auth Status Response
 * Authentication status response
 */
export type AuthStatusResponse = {
    /**
     * Whether user is authenticated
     */
    authenticated: boolean;
    user?: User;
};

/**
 * Linked Note
 * A note with relationship metadata
 */
export type LinkedNote = {
    /**
     * Note content
     */
    content: string;
    /**
     * Note content as plain text
     */
    content_plain_text?: string;
    /**
     * Description of the relationship
     */
    description_meta?: string;
    /**
     * Note ID
     */
    id: string;
    /**
     * Whether the relationship is active
     */
    is_active?: boolean;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Note name
     */
    name: string;
    /**
     * Type of relationship
     */
    relationship_type?: string;
    /**
     * Relationship strength (1-10)
     */
    strength?: number;
    /**
     * Note tags
     */
    tags?: Array<unknown>;
};

/**
 * Location Update Parameters
 * Parameters for updating an existing location (partial updates supported)
 */
export type LocationUpdateParams = {
    /**
     * Location content
     */
    content?: string;
    /**
     * Location content as plain text
     */
    content_plain_text?: string;
    /**
     * Location name
     */
    name?: string;
    /**
     * Parent location ID
     */
    parent_id?: string;
    /**
     * Whether this location is pinned
     */
    pinned?: boolean;
    /**
     * Tags for this location
     */
    tags?: Array<string>;
    /**
     * Location type
     */
    type?: 'continent' | 'nation' | 'region' | 'city' | 'settlement' | 'building' | 'complex';
};

/**
 * Character Notes Tree Data
 * Hierarchical tree of notes associated with a character
 */
export type CharacterNotesTreeData = {
    /**
     * Character ID
     */
    character_id: string;
    /**
     * Character name
     */
    character_name: string;
    /**
     * Hierarchical notes tree
     */
    notes_tree?: Array<NoteTreeNode>;
};

/**
 * Faction Response
 * Response containing a single faction
 */
export type FactionResponse = {
    data?: Faction;
};

/**
 * Faction Members Response
 * Response containing faction members
 */
export type FactionMembersResponse = {
    data?: FactionMembersData;
};

/**
 * Note Update Request
 * Note update parameters
 */
export type NoteUpdateRequest = {
    note: NoteUpdateParams;
};

/**
 * Location Tree Response
 * Response containing hierarchical location tree
 */
export type LocationTreeResponse = {
    /**
     * Response data
     */
    data?: Array<LocationTreeNode>;
};

/**
 * Note Links Response
 * Response containing note links
 */
export type NoteLinksResponse = {
    data?: NoteLinksData;
};

/**
 * Quest
 * A game quest
 */
export type Quest = {
    /**
     * Quest content
     */
    content: string;
    /**
     * Quest content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Associated game ID
     */
    game_id: string;
    /**
     * Quest ID
     */
    id: string;
    /**
     * Quest name
     */
    name: string;
    /**
     * Parent quest ID for hierarchical structure
     */
    parent_id?: string;
    /**
     * Whether this quest is pinned
     */
    pinned: boolean;
    /**
     * Tags associated with this quest
     */
    tags?: Array<string>;
    /**
     * Last update timestamp
     */
    updated_at?: string;
    /**
     * Creator user ID
     */
    user_id: number;
};

/**
 * Pinned Entities Response
 * Response containing all pinned entities for a game
 */
export type PinnedEntitiesResponse = {
    data?: PinnedEntitiesData;
};

/**
 * Note Create Parameters
 * Parameters for creating a new note
 */
export type NoteCreateParams = {
    /**
     * Note content
     */
    content: string;
    /**
     * Note content as plain text
     */
    content_plain_text?: string;
    /**
     * Note name
     */
    name: string;
    /**
     * Parent ID (note or other entity)
     */
    parent_id?: string;
    /**
     * Type of parent entity (character, quest, location, faction)
     */
    parent_type?: 'character' | 'quest' | 'location' | 'faction';
    /**
     * Tags for this note
     */
    tags?: Array<string>;
};

/**
 * Location Tree Node
 * A node in the location hierarchy tree
 */
export type LocationTreeNode = {
    /**
     * Child locations
     */
    children?: Array<LocationTreeNode>;
    /**
     * Location content
     */
    content?: string;
    /**
     * Entity type for URL building
     */
    entity_type: 'location';
    /**
     * Location ID
     */
    id: string;
    /**
     * Location name
     */
    name: string;
    /**
     * Parent location ID
     */
    parent_id?: string;
    /**
     * Tags associated with this location
     */
    tags?: Array<string>;
    /**
     * Location type
     */
    type: 'continent' | 'nation' | 'region' | 'city' | 'settlement' | 'building' | 'complex';
};

/**
 * Game Response
 * Response containing a single game
 */
export type GameResponse = {
    data?: Game;
};

/**
 * Character Create Parameters
 * Parameters for creating a new character
 */
export type CharacterCreateParams = {
    /**
     * Character class
     */
    class: string;
    /**
     * Character content
     */
    content?: string;
    /**
     * Character content as plain text
     */
    content_plain_text?: string;
    /**
     * Role within the faction
     */
    faction_role?: string;
    /**
     * Character image URL
     */
    image_url?: string;
    /**
     * Character level
     */
    level: number;
    /**
     * ID of faction this character belongs to
     */
    member_of_faction_id?: string;
    /**
     * Character name
     */
    name: string;
    /**
     * Tags for this character
     */
    tags?: Array<string>;
};

/**
 * Entity Faction
 * Faction entity in game entities list
 */
export type EntityFaction = {
    /**
     * Faction content
     */
    content: string;
    /**
     * Faction content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Faction ID
     */
    id: string;
    /**
     * Faction name
     */
    name: string;
    /**
     * Tags associated with this faction
     */
    tags?: Array<string>;
    /**
     * Last update timestamp
     */
    updated_at?: string;
};

/**
 * Entity Location
 * Location entity in game entities list
 */
export type EntityLocation = {
    /**
     * Location content
     */
    content?: string;
    /**
     * Location content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Whether this location has a parent location
     */
    has_parent: boolean;
    /**
     * Location ID
     */
    id: string;
    /**
     * Location name
     */
    name: string;
    /**
     * Tags associated with this location
     */
    tags?: Array<string>;
    /**
     * Location type
     */
    type: 'continent' | 'nation' | 'region' | 'city' | 'settlement' | 'building' | 'complex';
    /**
     * Last update timestamp
     */
    updated_at?: string;
};

/**
 * Character Links Data
 * Links associated with a character
 */
export type CharacterLinksData = {
    /**
     * Character ID
     */
    character_id: string;
    /**
     * Character name
     */
    character_name: string;
    links?: CharacterLinks;
};

/**
 * Quests Response
 * Response containing a list of quests
 */
export type QuestsResponse = {
    /**
     * Response data
     */
    data?: Array<Quest>;
};

/**
 * Quest Update Parameters
 * Parameters for updating an existing quest (partial updates supported)
 */
export type QuestUpdateParams = {
    /**
     * Quest content
     */
    content?: string;
    /**
     * Quest content as plain text
     */
    content_plain_text?: string;
    /**
     * Quest name
     */
    name?: string;
    /**
     * Parent quest ID for hierarchical structure
     */
    parent_id?: string;
    /**
     * Whether this quest is pinned
     */
    pinned?: boolean;
    /**
     * Tags for this quest
     */
    tags?: Array<string>;
};

/**
 * Linked Location
 * A location with relationship metadata
 */
export type LinkedLocation = {
    /**
     * Location content
     */
    content: string;
    /**
     * Location content as plain text
     */
    content_plain_text?: string;
    /**
     * Description of the relationship
     */
    description_meta?: string;
    /**
     * Location ID
     */
    id: string;
    /**
     * Whether the relationship is active
     */
    is_active?: boolean;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Location name
     */
    name: string;
    /**
     * Type of relationship
     */
    relationship_type?: string;
    /**
     * Relationship strength (1-10)
     */
    strength?: number;
    /**
     * Location tags
     */
    tags?: Array<unknown>;
};

/**
 * Game Create Parameters
 * Parameters for creating a new game
 */
export type GameCreateParams = {
    /**
     * Game content
     */
    content?: string;
    /**
     * Game content as plain text
     */
    content_plain_text?: string;
    /**
     * Game name
     */
    name: string;
    /**
     * Game setting
     */
    setting?: string;
};

/**
 * Note Links Data
 * Links associated with a note
 */
export type NoteLinksData = {
    links?: NoteLinks;
    /**
     * Note ID
     */
    note_id: string;
    /**
     * Note name
     */
    note_name: string;
};

/**
 * Note Response
 * Response containing a single note
 */
export type NoteResponse = {
    data?: Note;
};

/**
 * Error
 * Error response
 */
export type _Error = {
    errors?: ErrorDetails;
};

/**
 * Locations Response
 * Response containing a list of locations
 */
export type LocationsResponse = {
    /**
     * Response data
     */
    data?: Array<Location>;
};

/**
 * Game
 * A game instance
 */
export type Game = {
    /**
     * Game content
     */
    content?: string;
    /**
     * Game content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Game ID
     */
    id: string;
    /**
     * Game name
     */
    name: string;
    /**
     * Owner user ID
     */
    owner_id: number;
    /**
     * Game setting
     */
    setting?: string;
    /**
     * Last update timestamp
     */
    updated_at?: string;
};

/**
 * Game Update Parameters
 * Parameters for updating an existing game (partial updates supported)
 */
export type GameUpdateParams = {
    /**
     * Game content
     */
    content?: string;
    /**
     * Game content as plain text
     */
    content_plain_text?: string;
    /**
     * Game name
     */
    name?: string;
    /**
     * Game setting
     */
    setting?: string;
};

/**
 * Quest Tree Response
 * Response containing hierarchical quest tree
 */
export type QuestTreeResponse = {
    /**
     * Response data
     */
    data?: Array<QuestTreeNode>;
};

/**
 * Login Response
 * Successful login response
 */
export type LoginResponse = {
    /**
     * Session token (Base64 encoded)
     */
    token: string;
    user: User;
};

/**
 * Character
 * A game character
 */
export type Character = {
    /**
     * Character class
     */
    class: string;
    /**
     * Character content
     */
    content?: string;
    /**
     * Character content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Role within the faction
     */
    faction_role?: string;
    /**
     * Associated game ID
     */
    game_id: string;
    /**
     * Character ID
     */
    id: string;
    /**
     * Character image URL
     */
    image_url?: string;
    /**
     * Character level
     */
    level: number;
    /**
     * ID of faction this character belongs to
     */
    member_of_faction_id?: string;
    /**
     * Character name
     */
    name: string;
    /**
     * Whether this character is pinned
     */
    pinned: boolean;
    /**
     * Tags associated with this character
     */
    tags?: Array<string>;
    /**
     * Last update timestamp
     */
    updated_at?: string;
    /**
     * Creator user ID
     */
    user_id: number;
};

/**
 * Quest Create Parameters
 * Parameters for creating a new quest
 */
export type QuestCreateParams = {
    /**
     * Quest content
     */
    content: string;
    /**
     * Quest content as plain text
     */
    content_plain_text?: string;
    /**
     * Quest name
     */
    name: string;
    /**
     * Parent quest ID for hierarchical structure
     */
    parent_id?: string;
    /**
     * Tags for this quest
     */
    tags?: Array<string>;
};

/**
 * Note
 * A game note
 */
export type Note = {
    /**
     * Note content
     */
    content: string;
    /**
     * Note content as plain text
     */
    content_plain_text?: string;
    /**
     * Creation timestamp
     */
    created_at?: string;
    /**
     * Associated game ID
     */
    game_id: string;
    /**
     * Note ID
     */
    id: string;
    /**
     * Note name
     */
    name: string;
    /**
     * Parent ID (note or other entity)
     */
    parent_id?: string;
    /**
     * Type of parent entity (character, quest, location, faction)
     */
    parent_type?: 'character' | 'quest' | 'location' | 'faction';
    /**
     * Whether this note is pinned
     */
    pinned: boolean;
    /**
     * Tags associated with this note
     */
    tags?: Array<string>;
    /**
     * Last update timestamp
     */
    updated_at?: string;
    /**
     * Author user ID
     */
    user_id: number;
};

/**
 * Game Update Request
 * Game update parameters
 */
export type GameUpdateRequest = {
    game: GameUpdateParams;
};

/**
 * Faction Create Request
 * Faction creation parameters
 */
export type FactionCreateRequest = {
    faction: FactionCreateParams;
};

/**
 * Character Update Parameters
 * Parameters for updating an existing character (partial updates supported)
 */
export type CharacterUpdateParams = {
    /**
     * Character class
     */
    class?: string;
    /**
     * Character content
     */
    content?: string;
    /**
     * Character content as plain text
     */
    content_plain_text?: string;
    /**
     * Role within the faction
     */
    faction_role?: string;
    /**
     * Character image URL
     */
    image_url?: string;
    /**
     * Character level
     */
    level?: number;
    /**
     * ID of faction this character belongs to
     */
    member_of_faction_id?: string;
    /**
     * Character name
     */
    name?: string;
    /**
     * Whether this character is pinned
     */
    pinned?: boolean;
    /**
     * Tags for this character
     */
    tags?: Array<string>;
};

/**
 * Pinned Entities
 * Collection of pinned entities grouped by type
 */
export type PinnedEntities = {
    /**
     * Pinned characters
     */
    characters?: Array<Character>;
    /**
     * Pinned factions
     */
    factions?: Array<Faction>;
    /**
     * Pinned locations
     */
    locations?: Array<Location>;
    /**
     * Pinned notes
     */
    notes?: Array<Note>;
    /**
     * Pinned quests
     */
    quests?: Array<Quest>;
};

/**
 * Character Notes Tree Response
 * Response containing character notes tree
 */
export type CharacterNotesTreeResponse = {
    data?: CharacterNotesTreeData;
};

/**
 * Quest Create Request
 * Quest creation parameters
 */
export type QuestCreateRequest = {
    quest: QuestCreateParams;
};

/**
 * Note Update Parameters
 * Parameters for updating an existing note (partial updates supported)
 */
export type NoteUpdateParams = {
    /**
     * Note content
     */
    content?: string;
    /**
     * Note content as plain text
     */
    content_plain_text?: string;
    /**
     * Note name
     */
    name?: string;
    /**
     * Parent ID (note or other entity)
     */
    parent_id?: string | null;
    /**
     * Type of parent entity (character, quest, location, faction)
     */
    parent_type?: 'character' | 'quest' | 'location' | 'faction';
    /**
     * Whether this note is pinned
     */
    pinned?: boolean;
    /**
     * Tags for this note
     */
    tags?: Array<string>;
};

/**
 * Faction Links Data
 * Links associated with a faction
 */
export type FactionLinksData = {
    /**
     * Faction ID
     */
    faction_id: string;
    /**
     * Faction name
     */
    faction_name: string;
    links?: FactionLinks;
};

/**
 * Quest Links
 * Collections of entities linked to a quest
 */
export type QuestLinks = {
    /**
     * Linked characters with metadata
     */
    characters?: Array<LinkedCharacter>;
    /**
     * Linked factions with metadata
     */
    factions?: Array<LinkedFaction>;
    /**
     * Linked locations with metadata
     */
    locations?: Array<LinkedLocation>;
    /**
     * Linked notes with metadata
     */
    notes?: Array<LinkedNote>;
    /**
     * Linked quests with metadata
     */
    quests?: Array<LinkedQuest>;
};

export type GetFactionLinksData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Faction ID
         */
        faction_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions/{faction_id}/links';
};

export type GetFactionLinksErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetFactionLinksError = GetFactionLinksErrors[keyof GetFactionLinksErrors];

export type GetFactionLinksResponses = {
    /**
     * Success
     */
    200: FactionLinksResponse;
};

export type GetFactionLinksResponse = GetFactionLinksResponses[keyof GetFactionLinksResponses];

export type CreateFactionLinkData = {
    /**
     * Link creation data
     */
    body: LinkRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Faction ID
         */
        faction_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions/{faction_id}/links';
};

export type CreateFactionLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateFactionLinkError = CreateFactionLinkErrors[keyof CreateFactionLinkErrors];

export type CreateFactionLinkResponses = {
    /**
     * Created
     */
    201: unknown;
};

export type ListLocationsData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations';
};

export type ListLocationsErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type ListLocationsError = ListLocationsErrors[keyof ListLocationsErrors];

export type ListLocationsResponses = {
    /**
     * Success
     */
    200: LocationsResponse;
};

export type ListLocationsResponse = ListLocationsResponses[keyof ListLocationsResponses];

export type CreateLocationData = {
    /**
     * Location to create
     */
    body: LocationCreateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations';
};

export type CreateLocationErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateLocationError = CreateLocationErrors[keyof CreateLocationErrors];

export type CreateLocationResponses = {
    /**
     * Created
     */
    201: LocationResponse;
};

export type CreateLocationResponse = CreateLocationResponses[keyof CreateLocationResponses];

export type LogoutUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/logout';
};

export type LogoutUserErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
};

export type LogoutUserError = LogoutUserErrors[keyof LogoutUserErrors];

export type LogoutUserResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type LoginUserData = {
    /**
     * Login credentials
     */
    body: LoginRequest;
    path?: never;
    query?: never;
    url: '/api/auth/login';
};

export type LoginUserErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
};

export type LoginUserError = LoginUserErrors[keyof LoginUserErrors];

export type LoginUserResponses = {
    /**
     * Success
     */
    200: LoginResponse;
};

export type LoginUserResponse = LoginUserResponses[keyof LoginUserResponses];

export type DeleteLocationLinkData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Location ID
         */
        location_id: string;
        /**
         * Entity type
         */
        entity_type: 'character' | 'faction' | 'location' | 'quest' | 'note';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations/{location_id}/links/{entity_type}/{entity_id}';
};

export type DeleteLocationLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteLocationLinkError = DeleteLocationLinkErrors[keyof DeleteLocationLinkErrors];

export type DeleteLocationLinkResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type UpdateLocationLinkData = {
    /**
     * Link update data
     */
    body: LinkUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Location ID
         */
        location_id: string;
        /**
         * Entity type
         */
        entity_type: 'note' | 'character' | 'faction' | 'quest' | 'location';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations/{location_id}/links/{entity_type}/{entity_id}';
};

export type UpdateLocationLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateLocationLinkError = UpdateLocationLinkErrors[keyof UpdateLocationLinkErrors];

export type UpdateLocationLinkResponses = {
    /**
     * Success
     */
    200: {
        entity_id?: string;
        entity_type?: string;
        location_id?: string;
        message?: string;
        updated_at?: string;
    };
};

export type UpdateLocationLinkResponse = UpdateLocationLinkResponses[keyof UpdateLocationLinkResponses];

export type ListGameMembersData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/members';
};

export type ListGameMembersErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type ListGameMembersError = ListGameMembersErrors[keyof ListGameMembersErrors];

export type ListGameMembersResponses = {
    /**
     * Success
     */
    200: MembersResponse;
};

export type ListGameMembersResponse = ListGameMembersResponses[keyof ListGameMembersResponses];

export type AddGameMemberData = {
    body: {
        /**
         * User ID to add
         */
        user_id: number;
        /**
         * Member role (default: 'member')
         */
        role?: string;
    };
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/members';
};

export type AddGameMemberErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type AddGameMemberError = AddGameMemberErrors[keyof AddGameMemberErrors];

export type AddGameMemberResponses = {
    /**
     * Created
     */
    201: unknown;
};

export type GetCharacterNotesTreeData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{id}/notes/tree';
};

export type GetCharacterNotesTreeErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetCharacterNotesTreeError = GetCharacterNotesTreeErrors[keyof GetCharacterNotesTreeErrors];

export type GetCharacterNotesTreeResponses = {
    /**
     * Success
     */
    200: CharacterNotesTreeResponse;
};

export type GetCharacterNotesTreeResponse = GetCharacterNotesTreeResponses[keyof GetCharacterNotesTreeResponses];

export type DeleteLocationData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Location ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations/{id}';
};

export type DeleteLocationErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteLocationError = DeleteLocationErrors[keyof DeleteLocationErrors];

export type DeleteLocationResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type GetLocationData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Location ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations/{id}';
};

export type GetLocationErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetLocationError = GetLocationErrors[keyof GetLocationErrors];

export type GetLocationResponses = {
    /**
     * Success
     */
    200: LocationResponse;
};

export type GetLocationResponse = GetLocationResponses[keyof GetLocationResponses];

export type UpdateLocationData = {
    /**
     * Location updates
     */
    body: LocationUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Location ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations/{id}';
};

export type UpdateLocationErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateLocationError = UpdateLocationErrors[keyof UpdateLocationErrors];

export type UpdateLocationResponses = {
    /**
     * Success
     */
    200: LocationResponse;
};

export type UpdateLocationResponse = UpdateLocationResponses[keyof UpdateLocationResponses];

export type ListFactionsData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions';
};

export type ListFactionsErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type ListFactionsError = ListFactionsErrors[keyof ListFactionsErrors];

export type ListFactionsResponses = {
    /**
     * Success
     */
    200: FactionsResponse;
};

export type ListFactionsResponse = ListFactionsResponses[keyof ListFactionsResponses];

export type CreateFactionData = {
    /**
     * Faction to create
     */
    body: FactionCreateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions';
};

export type CreateFactionErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateFactionError = CreateFactionErrors[keyof CreateFactionErrors];

export type CreateFactionResponses = {
    /**
     * Created
     */
    201: FactionResponse;
};

export type CreateFactionResponse = CreateFactionResponses[keyof CreateFactionResponses];

export type DeleteCharacterLinkData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        character_id: string;
        /**
         * Entity type
         */
        entity_type: 'note' | 'faction' | 'location' | 'quest' | 'character';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{character_id}/links/{entity_type}/{entity_id}';
};

export type DeleteCharacterLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteCharacterLinkError = DeleteCharacterLinkErrors[keyof DeleteCharacterLinkErrors];

export type DeleteCharacterLinkResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type UpdateCharacterLinkData = {
    /**
     * Link update data
     */
    body: LinkUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        character_id: string;
        /**
         * Entity type
         */
        entity_type: 'note' | 'faction' | 'location' | 'quest' | 'character';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{character_id}/links/{entity_type}/{entity_id}';
};

export type UpdateCharacterLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateCharacterLinkError = UpdateCharacterLinkErrors[keyof UpdateCharacterLinkErrors];

export type UpdateCharacterLinkResponses = {
    /**
     * Success
     */
    200: {
        character_id?: string;
        entity_id?: string;
        entity_type?: string;
        message?: string;
        updated_at?: string;
    };
};

export type UpdateCharacterLinkResponse = UpdateCharacterLinkResponses[keyof UpdateCharacterLinkResponses];

export type ListGameEntitiesData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/links';
};

export type ListGameEntitiesErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type ListGameEntitiesError = ListGameEntitiesErrors[keyof ListGameEntitiesErrors];

export type ListGameEntitiesResponses = {
    /**
     * Success
     */
    200: EntitiesResponse;
};

export type ListGameEntitiesResponse = ListGameEntitiesResponses[keyof ListGameEntitiesResponses];

export type GetNoteLinksData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Note ID
         */
        note_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/notes/{note_id}/links';
};

export type GetNoteLinksErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetNoteLinksError = GetNoteLinksErrors[keyof GetNoteLinksErrors];

export type GetNoteLinksResponses = {
    /**
     * Success
     */
    200: NoteLinksResponse;
};

export type GetNoteLinksResponse = GetNoteLinksResponses[keyof GetNoteLinksResponses];

export type CreateNoteLinkData = {
    /**
     * Link creation data
     */
    body: LinkRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Note ID
         */
        note_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/notes/{note_id}/links';
};

export type CreateNoteLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateNoteLinkError = CreateNoteLinkErrors[keyof CreateNoteLinkErrors];

export type CreateNoteLinkResponses = {
    /**
     * Created
     */
    201: {
        entity_id?: string;
        entity_type?: string;
        message?: string;
        note_id?: string;
    };
};

export type CreateNoteLinkResponse = CreateNoteLinkResponses[keyof CreateNoteLinkResponses];

export type GetLocationTreeData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations/tree';
};

export type GetLocationTreeErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetLocationTreeError = GetLocationTreeErrors[keyof GetLocationTreeErrors];

export type GetLocationTreeResponses = {
    /**
     * Success
     */
    200: LocationTreeResponse;
};

export type GetLocationTreeResponse = GetLocationTreeResponses[keyof GetLocationTreeResponses];

export type RemoveCharacterPrimaryFactionData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        character_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{character_id}/primary-faction';
};

export type RemoveCharacterPrimaryFactionErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type RemoveCharacterPrimaryFactionError = RemoveCharacterPrimaryFactionErrors[keyof RemoveCharacterPrimaryFactionErrors];

export type RemoveCharacterPrimaryFactionResponses = {
    /**
     * Success
     */
    200: CharacterResponse;
};

export type RemoveCharacterPrimaryFactionResponse = RemoveCharacterPrimaryFactionResponses[keyof RemoveCharacterPrimaryFactionResponses];

export type GetCharacterPrimaryFactionData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        character_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{character_id}/primary-faction';
};

export type GetCharacterPrimaryFactionErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetCharacterPrimaryFactionError = GetCharacterPrimaryFactionErrors[keyof GetCharacterPrimaryFactionErrors];

export type GetCharacterPrimaryFactionResponses = {
    /**
     * Success
     */
    200: CharacterPrimaryFactionResponse;
};

export type GetCharacterPrimaryFactionResponse = GetCharacterPrimaryFactionResponses[keyof GetCharacterPrimaryFactionResponses];

export type SetCharacterPrimaryFactionData = {
    /**
     * Primary faction data
     */
    body: SetPrimaryFactionRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        character_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{character_id}/primary-faction';
};

export type SetCharacterPrimaryFactionErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type SetCharacterPrimaryFactionError = SetCharacterPrimaryFactionErrors[keyof SetCharacterPrimaryFactionErrors];

export type SetCharacterPrimaryFactionResponses = {
    /**
     * Success
     */
    200: CharacterResponse;
};

export type SetCharacterPrimaryFactionResponse = SetCharacterPrimaryFactionResponses[keyof SetCharacterPrimaryFactionResponses];

export type PinCharacterData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        character_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{character_id}/pin';
};

export type PinCharacterErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type PinCharacterError = PinCharacterErrors[keyof PinCharacterErrors];

export type PinCharacterResponses = {
    /**
     * Success
     */
    200: CharacterResponse;
};

export type PinCharacterResponse = PinCharacterResponses[keyof PinCharacterResponses];

export type GetFactionMembersData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Faction ID
         */
        faction_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions/{faction_id}/members';
};

export type GetFactionMembersErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetFactionMembersError = GetFactionMembersErrors[keyof GetFactionMembersErrors];

export type GetFactionMembersResponses = {
    /**
     * Success
     */
    200: FactionMembersResponse;
};

export type GetFactionMembersResponse = GetFactionMembersResponses[keyof GetFactionMembersResponses];

export type ListQuestsData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests';
};

export type ListQuestsErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type ListQuestsError = ListQuestsErrors[keyof ListQuestsErrors];

export type ListQuestsResponses = {
    /**
     * Success
     */
    200: QuestsResponse;
};

export type ListQuestsResponse = ListQuestsResponses[keyof ListQuestsResponses];

export type CreateQuestData = {
    /**
     * Quest to create
     */
    body: QuestCreateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests';
};

export type CreateQuestErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateQuestError = CreateQuestErrors[keyof CreateQuestErrors];

export type CreateQuestResponses = {
    /**
     * Created
     */
    201: QuestResponse;
};

export type CreateQuestResponse = CreateQuestResponses[keyof CreateQuestResponses];

export type DeleteNoteData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Note ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/notes/{id}';
};

export type DeleteNoteErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteNoteError = DeleteNoteErrors[keyof DeleteNoteErrors];

export type DeleteNoteResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type GetNoteData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Note ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/notes/{id}';
};

export type GetNoteErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetNoteError = GetNoteErrors[keyof GetNoteErrors];

export type GetNoteResponses = {
    /**
     * Success
     */
    200: NoteResponse;
};

export type GetNoteResponse = GetNoteResponses[keyof GetNoteResponses];

export type UpdateNoteData = {
    /**
     * Note parameters
     */
    body: NoteUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Note ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/notes/{id}';
};

export type UpdateNoteErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateNoteError = UpdateNoteErrors[keyof UpdateNoteErrors];

export type UpdateNoteResponses = {
    /**
     * Success
     */
    200: NoteResponse;
};

export type UpdateNoteResponse = UpdateNoteResponses[keyof UpdateNoteResponses];

export type GetCharacterLinksData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        character_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{character_id}/links';
};

export type GetCharacterLinksErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetCharacterLinksError = GetCharacterLinksErrors[keyof GetCharacterLinksErrors];

export type GetCharacterLinksResponses = {
    /**
     * Success
     */
    200: CharacterLinksResponse;
};

export type GetCharacterLinksResponse = GetCharacterLinksResponses[keyof GetCharacterLinksResponses];

export type CreateCharacterLinkData = {
    /**
     * Link creation data
     */
    body: LinkRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        character_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{character_id}/links';
};

export type CreateCharacterLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateCharacterLinkError = CreateCharacterLinkErrors[keyof CreateCharacterLinkErrors];

export type CreateCharacterLinkResponses = {
    /**
     * Created
     */
    201: unknown;
};

export type ListCharactersData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters';
};

export type ListCharactersErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type ListCharactersError = ListCharactersErrors[keyof ListCharactersErrors];

export type ListCharactersResponses = {
    /**
     * Success
     */
    200: CharactersResponse;
};

export type ListCharactersResponse = ListCharactersResponses[keyof ListCharactersResponses];

export type CreateCharacterData = {
    /**
     * Character to create
     */
    body: CharacterCreateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters';
};

export type CreateCharacterErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateCharacterError = CreateCharacterErrors[keyof CreateCharacterErrors];

export type CreateCharacterResponses = {
    /**
     * Created
     */
    201: CharacterResponse;
};

export type CreateCharacterResponse = CreateCharacterResponses[keyof CreateCharacterResponses];

export type DeleteGameData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{id}';
};

export type DeleteGameErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteGameError = DeleteGameErrors[keyof DeleteGameErrors];

export type DeleteGameResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type GetGameData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{id}';
};

export type GetGameErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetGameError = GetGameErrors[keyof GetGameErrors];

export type GetGameResponses = {
    /**
     * Success
     */
    200: GameResponse;
};

export type GetGameResponse = GetGameResponses[keyof GetGameResponses];

export type UpdateGameData = {
    /**
     * Game parameters
     */
    body: GameUpdateRequest;
    path: {
        /**
         * Game ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{id}';
};

export type UpdateGameErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateGameError = UpdateGameErrors[keyof UpdateGameErrors];

export type UpdateGameResponses = {
    /**
     * Success
     */
    200: GameResponse;
};

export type UpdateGameResponse = UpdateGameResponses[keyof UpdateGameResponses];

export type GetGameEntityTreeData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: {
        /**
         * Maximum depth to traverse (default: 3, max: 10)
         */
        depth?: number;
        /**
         * Entity type to start from (character, faction, location, quest, note)
         */
        start_entity_type?: string;
        /**
         * Entity ID to start from (requires start_entity_type)
         */
        start_entity_id?: string;
    };
    url: '/api/games/{game_id}/tree';
};

export type GetGameEntityTreeErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetGameEntityTreeError = GetGameEntityTreeErrors[keyof GetGameEntityTreeErrors];

export type GetGameEntityTreeResponses = {
    /**
     * Success
     */
    200: EntityTreeResponse;
};

export type GetGameEntityTreeResponse = GetGameEntityTreeResponses[keyof GetGameEntityTreeResponses];

export type UnpinCharacterData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        character_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{character_id}/unpin';
};

export type UnpinCharacterErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type UnpinCharacterError = UnpinCharacterErrors[keyof UnpinCharacterErrors];

export type UnpinCharacterResponses = {
    /**
     * Success
     */
    200: CharacterResponse;
};

export type UnpinCharacterResponse = UnpinCharacterResponses[keyof UnpinCharacterResponses];

export type SignupUserData = {
    /**
     * Signup credentials
     */
    body: SignupRequest;
    path?: never;
    query?: never;
    url: '/api/auth/signup';
};

export type SignupUserErrors = {
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type SignupUserError = SignupUserErrors[keyof SignupUserErrors];

export type SignupUserResponses = {
    /**
     * Created
     */
    201: LoginResponse;
};

export type SignupUserResponse = SignupUserResponses[keyof SignupUserResponses];

export type GetAuthStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/status';
};

export type GetAuthStatusErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
};

export type GetAuthStatusError = GetAuthStatusErrors[keyof GetAuthStatusErrors];

export type GetAuthStatusResponses = {
    /**
     * Success
     */
    200: AuthStatusResponse;
};

export type GetAuthStatusResponse = GetAuthStatusResponses[keyof GetAuthStatusResponses];

export type DeleteQuestData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Quest ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests/{id}';
};

export type DeleteQuestErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteQuestError = DeleteQuestErrors[keyof DeleteQuestErrors];

export type DeleteQuestResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type GetQuestData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Quest ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests/{id}';
};

export type GetQuestErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetQuestError = GetQuestErrors[keyof GetQuestErrors];

export type GetQuestResponses = {
    /**
     * Success
     */
    200: QuestResponse;
};

export type GetQuestResponse = GetQuestResponses[keyof GetQuestResponses];

export type UpdateQuestData = {
    /**
     * Quest updates
     */
    body: QuestUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Quest ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests/{id}';
};

export type UpdateQuestErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateQuestError = UpdateQuestErrors[keyof UpdateQuestErrors];

export type UpdateQuestResponses = {
    /**
     * Success
     */
    200: QuestResponse;
};

export type UpdateQuestResponse = UpdateQuestResponses[keyof UpdateQuestResponses];

export type GetLocationLinksData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Location ID
         */
        location_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations/{location_id}/links';
};

export type GetLocationLinksErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetLocationLinksError = GetLocationLinksErrors[keyof GetLocationLinksErrors];

export type GetLocationLinksResponses = {
    /**
     * Success
     */
    200: LocationLinksResponse;
};

export type GetLocationLinksResponse = GetLocationLinksResponses[keyof GetLocationLinksResponses];

export type CreateLocationLinkData = {
    /**
     * Link creation data
     */
    body: LinkRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Location ID
         */
        location_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/locations/{location_id}/links';
};

export type CreateLocationLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateLocationLinkError = CreateLocationLinkErrors[keyof CreateLocationLinkErrors];

export type CreateLocationLinkResponses = {
    /**
     * Created
     */
    201: unknown;
};

export type DeleteNoteLinkData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Note ID
         */
        note_id: string;
        /**
         * Entity type
         */
        entity_type: 'character' | 'faction' | 'location' | 'quest' | 'note';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/notes/{note_id}/links/{entity_type}/{entity_id}';
};

export type DeleteNoteLinkErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type DeleteNoteLinkError = DeleteNoteLinkErrors[keyof DeleteNoteLinkErrors];

export type DeleteNoteLinkResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type UpdateNoteLinkData = {
    /**
     * Link update data
     */
    body: LinkUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Note ID
         */
        note_id: string;
        /**
         * Entity type
         */
        entity_type: 'character' | 'faction' | 'location' | 'quest' | 'note';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/notes/{note_id}/links/{entity_type}/{entity_id}';
};

export type UpdateNoteLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateNoteLinkError = UpdateNoteLinkErrors[keyof UpdateNoteLinkErrors];

export type UpdateNoteLinkResponses = {
    /**
     * Success
     */
    200: {
        entity_id?: string;
        entity_type?: string;
        message?: string;
        note_id?: string;
        updated_at?: string;
    };
};

export type UpdateNoteLinkResponse = UpdateNoteLinkResponses[keyof UpdateNoteLinkResponses];

export type DeleteCharacterData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{id}';
};

export type DeleteCharacterErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteCharacterError = DeleteCharacterErrors[keyof DeleteCharacterErrors];

export type DeleteCharacterResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type GetCharacterData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{id}';
};

export type GetCharacterErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetCharacterError = GetCharacterErrors[keyof GetCharacterErrors];

export type GetCharacterResponses = {
    /**
     * Success
     */
    200: CharacterResponse;
};

export type GetCharacterResponse = GetCharacterResponses[keyof GetCharacterResponses];

export type UpdateCharacterData = {
    /**
     * Character updates
     */
    body: CharacterUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Character ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/characters/{id}';
};

export type UpdateCharacterErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateCharacterError = UpdateCharacterErrors[keyof UpdateCharacterErrors];

export type UpdateCharacterResponses = {
    /**
     * Success
     */
    200: CharacterResponse;
};

export type UpdateCharacterResponse = UpdateCharacterResponses[keyof UpdateCharacterResponses];

export type GetQuestLinksData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Quest ID
         */
        quest_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests/{quest_id}/links';
};

export type GetQuestLinksErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetQuestLinksError = GetQuestLinksErrors[keyof GetQuestLinksErrors];

export type GetQuestLinksResponses = {
    /**
     * Success
     */
    200: QuestLinksResponse;
};

export type GetQuestLinksResponse = GetQuestLinksResponses[keyof GetQuestLinksResponses];

export type CreateQuestLinkData = {
    /**
     * Link creation data
     */
    body: LinkRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Quest ID
         */
        quest_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests/{quest_id}/links';
};

export type CreateQuestLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateQuestLinkError = CreateQuestLinkErrors[keyof CreateQuestLinkErrors];

export type CreateQuestLinkResponses = {
    /**
     * Created
     */
    201: unknown;
};

export type DeleteFactionData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Faction ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions/{id}';
};

export type DeleteFactionErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteFactionError = DeleteFactionErrors[keyof DeleteFactionErrors];

export type DeleteFactionResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type GetFactionData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Faction ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions/{id}';
};

export type GetFactionErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetFactionError = GetFactionErrors[keyof GetFactionErrors];

export type GetFactionResponses = {
    /**
     * Success
     */
    200: FactionResponse;
};

export type GetFactionResponse = GetFactionResponses[keyof GetFactionResponses];

export type UpdateFactionData = {
    /**
     * Faction updates
     */
    body: FactionUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Faction ID
         */
        id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions/{id}';
};

export type UpdateFactionErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateFactionError = UpdateFactionErrors[keyof UpdateFactionErrors];

export type UpdateFactionResponses = {
    /**
     * Success
     */
    200: FactionResponse;
};

export type UpdateFactionResponse = UpdateFactionResponses[keyof UpdateFactionResponses];

export type RemoveGameMemberData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * User ID to remove
         */
        user_id: number;
    };
    query?: never;
    url: '/api/games/{game_id}/members/{user_id}';
};

export type RemoveGameMemberErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type RemoveGameMemberError = RemoveGameMemberErrors[keyof RemoveGameMemberErrors];

export type RemoveGameMemberResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type DeleteFactionLinkData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Faction ID
         */
        faction_id: string;
        /**
         * Entity type
         */
        entity_type: 'character' | 'location' | 'quest' | 'note' | 'faction';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions/{faction_id}/links/{entity_type}/{entity_id}';
};

export type DeleteFactionLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteFactionLinkError = DeleteFactionLinkErrors[keyof DeleteFactionLinkErrors];

export type DeleteFactionLinkResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type UpdateFactionLinkData = {
    /**
     * Link update data
     */
    body: LinkUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Faction ID
         */
        faction_id: string;
        /**
         * Entity type
         */
        entity_type: 'note' | 'character' | 'location' | 'quest' | 'faction';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/factions/{faction_id}/links/{entity_type}/{entity_id}';
};

export type UpdateFactionLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateFactionLinkError = UpdateFactionLinkErrors[keyof UpdateFactionLinkErrors];

export type UpdateFactionLinkResponses = {
    /**
     * Success
     */
    200: {
        entity_id?: string;
        entity_type?: string;
        faction_id?: string;
        message?: string;
        updated_at?: string;
    };
};

export type UpdateFactionLinkResponse = UpdateFactionLinkResponses[keyof UpdateFactionLinkResponses];

export type ListNotesData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/notes';
};

export type ListNotesErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type ListNotesError = ListNotesErrors[keyof ListNotesErrors];

export type ListNotesResponses = {
    /**
     * Success
     */
    200: NotesResponse;
};

export type ListNotesResponse = ListNotesResponses[keyof ListNotesResponses];

export type CreateNoteData = {
    /**
     * Note parameters
     */
    body: NoteCreateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/notes';
};

export type CreateNoteErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateNoteError = CreateNoteErrors[keyof CreateNoteErrors];

export type CreateNoteResponses = {
    /**
     * Created
     */
    201: NoteResponse;
};

export type CreateNoteResponse = CreateNoteResponses[keyof CreateNoteResponses];

export type ListPinnedEntitiesData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/pinned';
};

export type ListPinnedEntitiesErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type ListPinnedEntitiesError = ListPinnedEntitiesErrors[keyof ListPinnedEntitiesErrors];

export type ListPinnedEntitiesResponses = {
    /**
     * Success
     */
    200: PinnedEntitiesResponse;
};

export type ListPinnedEntitiesResponse = ListPinnedEntitiesResponses[keyof ListPinnedEntitiesResponses];

export type ListGamesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/games';
};

export type ListGamesErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
};

export type ListGamesError = ListGamesErrors[keyof ListGamesErrors];

export type ListGamesResponses = {
    /**
     * Success
     */
    200: GamesResponse;
};

export type ListGamesResponse = ListGamesResponses[keyof ListGamesResponses];

export type CreateGameData = {
    /**
     * Game parameters
     */
    body: GameCreateRequest;
    path?: never;
    query?: never;
    url: '/api/games';
};

export type CreateGameErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type CreateGameError = CreateGameErrors[keyof CreateGameErrors];

export type CreateGameResponses = {
    /**
     * Created
     */
    201: GameResponse;
};

export type CreateGameResponse = CreateGameResponses[keyof CreateGameResponses];

export type DeleteQuestLinkData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Quest ID
         */
        quest_id: string;
        /**
         * Entity type
         */
        entity_type: 'character' | 'faction' | 'location' | 'note' | 'quest';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests/{quest_id}/links/{entity_type}/{entity_id}';
};

export type DeleteQuestLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type DeleteQuestLinkError = DeleteQuestLinkErrors[keyof DeleteQuestLinkErrors];

export type DeleteQuestLinkResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type UpdateQuestLinkData = {
    /**
     * Link update data
     */
    body: LinkUpdateRequest;
    path: {
        /**
         * Game ID
         */
        game_id: string;
        /**
         * Quest ID
         */
        quest_id: string;
        /**
         * Entity type
         */
        entity_type: 'note' | 'character' | 'faction' | 'location' | 'quest';
        /**
         * Entity ID
         */
        entity_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests/{quest_id}/links/{entity_type}/{entity_id}';
};

export type UpdateQuestLinkErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
    /**
     * Unprocessable Entity
     */
    422: _Error;
};

export type UpdateQuestLinkError = UpdateQuestLinkErrors[keyof UpdateQuestLinkErrors];

export type UpdateQuestLinkResponses = {
    /**
     * Success
     */
    200: {
        entity_id?: string;
        entity_type?: string;
        message?: string;
        quest_id?: string;
        updated_at?: string;
    };
};

export type UpdateQuestLinkResponse = UpdateQuestLinkResponses[keyof UpdateQuestLinkResponses];

export type GetQuestTreeData = {
    body?: never;
    path: {
        /**
         * Game ID
         */
        game_id: string;
    };
    query?: never;
    url: '/api/games/{game_id}/quests/tree';
};

export type GetQuestTreeErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Forbidden
     */
    403: _Error;
    /**
     * Not Found
     */
    404: _Error;
};

export type GetQuestTreeError = GetQuestTreeErrors[keyof GetQuestTreeErrors];

export type GetQuestTreeResponses = {
    /**
     * Success
     */
    200: QuestTreeResponse;
};

export type GetQuestTreeResponse = GetQuestTreeResponses[keyof GetQuestTreeResponses];

export type ClientOptions = {
    baseUrl: 'https://gamemastercore-production.up.railway.app' | (string & {});
};
</file>

<file path="src/routes/__root.tsx">
import type { QueryClient } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { createRootRouteWithContext, HeadContent, Scripts } from "@tanstack/react-router";
import { TanStackRouterDevtools } from "@tanstack/react-router-devtools";
import { createServerFn } from "@tanstack/react-start";
import { Toaster } from "sonner";
import { ThemeProvider } from "~/components/theme-provider";
import { getAppSession } from "~/utils/session";
import appCss from "../styles.css?url";

interface MyRouterContext {
	queryClient: QueryClient;
}

// NOTE: This function accesses the session from the cookie session. It runs on the server.
const fetchSession = createServerFn({ method: "GET" }).handler(async () => {
	const session = await getAppSession();

	if (!session.data.token) {
		return null;
	}

	return {
		user: session.data.user,
		token: session.data.token,
	};
});

export const Route = createRootRouteWithContext<MyRouterContext>()({
	beforeLoad: async () => {
		const session = await fetchSession();

		return {
			...session,
		};
	},
	head: () => ({
		meta: [
			{
				charSet: "utf-8",
			},
			{
				name: "viewport",
				content: "width=device-width, initial-scale=1",
			},
			{
				title: "Game Master - The DM Notebook",
			},
		],
		links: [
			{
				rel: "stylesheet",
				href: appCss,
			},
		],
	}),

	shellComponent: RootDocument,
});

function RootDocument({ children }: { children: React.ReactNode }) {
	return (
		<html lang="en" suppressHydrationWarning>
			<head>
				<HeadContent />
			</head>
			<body>
				<ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
					{children}
					<TanStackRouterDevtools />
					<ReactQueryDevtools />
					<Scripts />
					<Toaster position="top-center" theme={"dark"} />
				</ThemeProvider>
			</body>
		</html>
	);
}
</file>

<file path="src/routeTree.gen.ts">
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Route as rootRouteImport } from './routes/__root'
import { Route as SignupRouteImport } from './routes/signup'
import { Route as LogoutRouteImport } from './routes/logout'
import { Route as LoginRouteImport } from './routes/login'
import { Route as AuthRouteImport } from './routes/_auth'
import { Route as IndexRouteImport } from './routes/index'
import { Route as AuthGamesIndexRouteImport } from './routes/_auth/games/index'
import { Route as AuthGamesNewRouteImport } from './routes/_auth/games/new'
import { Route as AuthGamesGameIdRouteRouteImport } from './routes/_auth/games/$gameId/route'
import { Route as AuthGamesGameIdIndexRouteImport } from './routes/_auth/games/$gameId/index'
import { Route as AuthGamesGameIdTreeRouteImport } from './routes/_auth/games/$gameId/tree'
import { Route as AuthGamesGameIdEditRouteImport } from './routes/_auth/games/$gameId/edit'
import { Route as AuthGamesGameIdAllRouteImport } from './routes/_auth/games/$gameId/all'
import { Route as AuthGamesGameIdQuestsIndexRouteImport } from './routes/_auth/games/$gameId/quests/index'
import { Route as AuthGamesGameIdNotesIndexRouteImport } from './routes/_auth/games/$gameId/notes/index'
import { Route as AuthGamesGameIdLocationsIndexRouteImport } from './routes/_auth/games/$gameId/locations/index'
import { Route as AuthGamesGameIdFactionsIndexRouteImport } from './routes/_auth/games/$gameId/factions/index'
import { Route as AuthGamesGameIdCharactersIndexRouteImport } from './routes/_auth/games/$gameId/characters/index'
import { Route as AuthGamesGameIdQuestsNewRouteImport } from './routes/_auth/games/$gameId/quests/new'
import { Route as AuthGamesGameIdNotesNewRouteImport } from './routes/_auth/games/$gameId/notes/new'
import { Route as AuthGamesGameIdLocationsNewRouteImport } from './routes/_auth/games/$gameId/locations/new'
import { Route as AuthGamesGameIdFactionsNewRouteImport } from './routes/_auth/games/$gameId/factions/new'
import { Route as AuthGamesGameIdCharactersNewRouteImport } from './routes/_auth/games/$gameId/characters/new'
import { Route as AuthGamesGameIdQuestsIdRouteRouteImport } from './routes/_auth/games/$gameId/quests/$id/route'
import { Route as AuthGamesGameIdNotesIdRouteRouteImport } from './routes/_auth/games/$gameId/notes/$id/route'
import { Route as AuthGamesGameIdLocationsIdRouteRouteImport } from './routes/_auth/games/$gameId/locations/$id/route'
import { Route as AuthGamesGameIdFactionsIdRouteRouteImport } from './routes/_auth/games/$gameId/factions/$id/route'
import { Route as AuthGamesGameIdCharactersIdRouteRouteImport } from './routes/_auth/games/$gameId/characters/$id/route'
import { Route as AuthGamesGameIdQuestsIdIndexRouteImport } from './routes/_auth/games/$gameId/quests/$id/index'
import { Route as AuthGamesGameIdNotesIdIndexRouteImport } from './routes/_auth/games/$gameId/notes/$id/index'
import { Route as AuthGamesGameIdLocationsIdIndexRouteImport } from './routes/_auth/games/$gameId/locations/$id/index'
import { Route as AuthGamesGameIdFactionsIdIndexRouteImport } from './routes/_auth/games/$gameId/factions/$id/index'
import { Route as AuthGamesGameIdCharactersIdIndexRouteImport } from './routes/_auth/games/$gameId/characters/$id/index'
import { Route as AuthGamesGameIdQuestsIdEditRouteImport } from './routes/_auth/games/$gameId/quests/$id/edit'
import { Route as AuthGamesGameIdNotesIdEditRouteImport } from './routes/_auth/games/$gameId/notes/$id/edit'
import { Route as AuthGamesGameIdLocationsIdEditRouteImport } from './routes/_auth/games/$gameId/locations/$id/edit'
import { Route as AuthGamesGameIdFactionsIdEditRouteImport } from './routes/_auth/games/$gameId/factions/$id/edit'
import { Route as AuthGamesGameIdCharactersIdEditRouteImport } from './routes/_auth/games/$gameId/characters/$id/edit'

const SignupRoute = SignupRouteImport.update({
  id: '/signup',
  path: '/signup',
  getParentRoute: () => rootRouteImport,
} as any)
const LogoutRoute = LogoutRouteImport.update({
  id: '/logout',
  path: '/logout',
  getParentRoute: () => rootRouteImport,
} as any)
const LoginRoute = LoginRouteImport.update({
  id: '/login',
  path: '/login',
  getParentRoute: () => rootRouteImport,
} as any)
const AuthRoute = AuthRouteImport.update({
  id: '/_auth',
  getParentRoute: () => rootRouteImport,
} as any)
const IndexRoute = IndexRouteImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => rootRouteImport,
} as any)
const AuthGamesIndexRoute = AuthGamesIndexRouteImport.update({
  id: '/games/',
  path: '/games/',
  getParentRoute: () => AuthRoute,
} as any)
const AuthGamesNewRoute = AuthGamesNewRouteImport.update({
  id: '/games/new',
  path: '/games/new',
  getParentRoute: () => AuthRoute,
} as any)
const AuthGamesGameIdRouteRoute = AuthGamesGameIdRouteRouteImport.update({
  id: '/games/$gameId',
  path: '/games/$gameId',
  getParentRoute: () => AuthRoute,
} as any)
const AuthGamesGameIdIndexRoute = AuthGamesGameIdIndexRouteImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => AuthGamesGameIdRouteRoute,
} as any)
const AuthGamesGameIdTreeRoute = AuthGamesGameIdTreeRouteImport.update({
  id: '/tree',
  path: '/tree',
  getParentRoute: () => AuthGamesGameIdRouteRoute,
} as any)
const AuthGamesGameIdEditRoute = AuthGamesGameIdEditRouteImport.update({
  id: '/edit',
  path: '/edit',
  getParentRoute: () => AuthGamesGameIdRouteRoute,
} as any)
const AuthGamesGameIdAllRoute = AuthGamesGameIdAllRouteImport.update({
  id: '/all',
  path: '/all',
  getParentRoute: () => AuthGamesGameIdRouteRoute,
} as any)
const AuthGamesGameIdQuestsIndexRoute =
  AuthGamesGameIdQuestsIndexRouteImport.update({
    id: '/quests/',
    path: '/quests/',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdNotesIndexRoute =
  AuthGamesGameIdNotesIndexRouteImport.update({
    id: '/notes/',
    path: '/notes/',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdLocationsIndexRoute =
  AuthGamesGameIdLocationsIndexRouteImport.update({
    id: '/locations/',
    path: '/locations/',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdFactionsIndexRoute =
  AuthGamesGameIdFactionsIndexRouteImport.update({
    id: '/factions/',
    path: '/factions/',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdCharactersIndexRoute =
  AuthGamesGameIdCharactersIndexRouteImport.update({
    id: '/characters/',
    path: '/characters/',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdQuestsNewRoute =
  AuthGamesGameIdQuestsNewRouteImport.update({
    id: '/quests/new',
    path: '/quests/new',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdNotesNewRoute = AuthGamesGameIdNotesNewRouteImport.update({
  id: '/notes/new',
  path: '/notes/new',
  getParentRoute: () => AuthGamesGameIdRouteRoute,
} as any)
const AuthGamesGameIdLocationsNewRoute =
  AuthGamesGameIdLocationsNewRouteImport.update({
    id: '/locations/new',
    path: '/locations/new',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdFactionsNewRoute =
  AuthGamesGameIdFactionsNewRouteImport.update({
    id: '/factions/new',
    path: '/factions/new',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdCharactersNewRoute =
  AuthGamesGameIdCharactersNewRouteImport.update({
    id: '/characters/new',
    path: '/characters/new',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdQuestsIdRouteRoute =
  AuthGamesGameIdQuestsIdRouteRouteImport.update({
    id: '/quests/$id',
    path: '/quests/$id',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdNotesIdRouteRoute =
  AuthGamesGameIdNotesIdRouteRouteImport.update({
    id: '/notes/$id',
    path: '/notes/$id',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdLocationsIdRouteRoute =
  AuthGamesGameIdLocationsIdRouteRouteImport.update({
    id: '/locations/$id',
    path: '/locations/$id',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdFactionsIdRouteRoute =
  AuthGamesGameIdFactionsIdRouteRouteImport.update({
    id: '/factions/$id',
    path: '/factions/$id',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdCharactersIdRouteRoute =
  AuthGamesGameIdCharactersIdRouteRouteImport.update({
    id: '/characters/$id',
    path: '/characters/$id',
    getParentRoute: () => AuthGamesGameIdRouteRoute,
  } as any)
const AuthGamesGameIdQuestsIdIndexRoute =
  AuthGamesGameIdQuestsIdIndexRouteImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => AuthGamesGameIdQuestsIdRouteRoute,
  } as any)
const AuthGamesGameIdNotesIdIndexRoute =
  AuthGamesGameIdNotesIdIndexRouteImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => AuthGamesGameIdNotesIdRouteRoute,
  } as any)
const AuthGamesGameIdLocationsIdIndexRoute =
  AuthGamesGameIdLocationsIdIndexRouteImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => AuthGamesGameIdLocationsIdRouteRoute,
  } as any)
const AuthGamesGameIdFactionsIdIndexRoute =
  AuthGamesGameIdFactionsIdIndexRouteImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => AuthGamesGameIdFactionsIdRouteRoute,
  } as any)
const AuthGamesGameIdCharactersIdIndexRoute =
  AuthGamesGameIdCharactersIdIndexRouteImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => AuthGamesGameIdCharactersIdRouteRoute,
  } as any)
const AuthGamesGameIdQuestsIdEditRoute =
  AuthGamesGameIdQuestsIdEditRouteImport.update({
    id: '/edit',
    path: '/edit',
    getParentRoute: () => AuthGamesGameIdQuestsIdRouteRoute,
  } as any)
const AuthGamesGameIdNotesIdEditRoute =
  AuthGamesGameIdNotesIdEditRouteImport.update({
    id: '/edit',
    path: '/edit',
    getParentRoute: () => AuthGamesGameIdNotesIdRouteRoute,
  } as any)
const AuthGamesGameIdLocationsIdEditRoute =
  AuthGamesGameIdLocationsIdEditRouteImport.update({
    id: '/edit',
    path: '/edit',
    getParentRoute: () => AuthGamesGameIdLocationsIdRouteRoute,
  } as any)
const AuthGamesGameIdFactionsIdEditRoute =
  AuthGamesGameIdFactionsIdEditRouteImport.update({
    id: '/edit',
    path: '/edit',
    getParentRoute: () => AuthGamesGameIdFactionsIdRouteRoute,
  } as any)
const AuthGamesGameIdCharactersIdEditRoute =
  AuthGamesGameIdCharactersIdEditRouteImport.update({
    id: '/edit',
    path: '/edit',
    getParentRoute: () => AuthGamesGameIdCharactersIdRouteRoute,
  } as any)

export interface FileRoutesByFullPath {
  '/': typeof IndexRoute
  '/login': typeof LoginRoute
  '/logout': typeof LogoutRoute
  '/signup': typeof SignupRoute
  '/games/$gameId': typeof AuthGamesGameIdRouteRouteWithChildren
  '/games/new': typeof AuthGamesNewRoute
  '/games': typeof AuthGamesIndexRoute
  '/games/$gameId/all': typeof AuthGamesGameIdAllRoute
  '/games/$gameId/edit': typeof AuthGamesGameIdEditRoute
  '/games/$gameId/tree': typeof AuthGamesGameIdTreeRoute
  '/games/$gameId/': typeof AuthGamesGameIdIndexRoute
  '/games/$gameId/characters/$id': typeof AuthGamesGameIdCharactersIdRouteRouteWithChildren
  '/games/$gameId/factions/$id': typeof AuthGamesGameIdFactionsIdRouteRouteWithChildren
  '/games/$gameId/locations/$id': typeof AuthGamesGameIdLocationsIdRouteRouteWithChildren
  '/games/$gameId/notes/$id': typeof AuthGamesGameIdNotesIdRouteRouteWithChildren
  '/games/$gameId/quests/$id': typeof AuthGamesGameIdQuestsIdRouteRouteWithChildren
  '/games/$gameId/characters/new': typeof AuthGamesGameIdCharactersNewRoute
  '/games/$gameId/factions/new': typeof AuthGamesGameIdFactionsNewRoute
  '/games/$gameId/locations/new': typeof AuthGamesGameIdLocationsNewRoute
  '/games/$gameId/notes/new': typeof AuthGamesGameIdNotesNewRoute
  '/games/$gameId/quests/new': typeof AuthGamesGameIdQuestsNewRoute
  '/games/$gameId/characters': typeof AuthGamesGameIdCharactersIndexRoute
  '/games/$gameId/factions': typeof AuthGamesGameIdFactionsIndexRoute
  '/games/$gameId/locations': typeof AuthGamesGameIdLocationsIndexRoute
  '/games/$gameId/notes': typeof AuthGamesGameIdNotesIndexRoute
  '/games/$gameId/quests': typeof AuthGamesGameIdQuestsIndexRoute
  '/games/$gameId/characters/$id/edit': typeof AuthGamesGameIdCharactersIdEditRoute
  '/games/$gameId/factions/$id/edit': typeof AuthGamesGameIdFactionsIdEditRoute
  '/games/$gameId/locations/$id/edit': typeof AuthGamesGameIdLocationsIdEditRoute
  '/games/$gameId/notes/$id/edit': typeof AuthGamesGameIdNotesIdEditRoute
  '/games/$gameId/quests/$id/edit': typeof AuthGamesGameIdQuestsIdEditRoute
  '/games/$gameId/characters/$id/': typeof AuthGamesGameIdCharactersIdIndexRoute
  '/games/$gameId/factions/$id/': typeof AuthGamesGameIdFactionsIdIndexRoute
  '/games/$gameId/locations/$id/': typeof AuthGamesGameIdLocationsIdIndexRoute
  '/games/$gameId/notes/$id/': typeof AuthGamesGameIdNotesIdIndexRoute
  '/games/$gameId/quests/$id/': typeof AuthGamesGameIdQuestsIdIndexRoute
}
export interface FileRoutesByTo {
  '/': typeof IndexRoute
  '/login': typeof LoginRoute
  '/logout': typeof LogoutRoute
  '/signup': typeof SignupRoute
  '/games/new': typeof AuthGamesNewRoute
  '/games': typeof AuthGamesIndexRoute
  '/games/$gameId/all': typeof AuthGamesGameIdAllRoute
  '/games/$gameId/edit': typeof AuthGamesGameIdEditRoute
  '/games/$gameId/tree': typeof AuthGamesGameIdTreeRoute
  '/games/$gameId': typeof AuthGamesGameIdIndexRoute
  '/games/$gameId/characters/new': typeof AuthGamesGameIdCharactersNewRoute
  '/games/$gameId/factions/new': typeof AuthGamesGameIdFactionsNewRoute
  '/games/$gameId/locations/new': typeof AuthGamesGameIdLocationsNewRoute
  '/games/$gameId/notes/new': typeof AuthGamesGameIdNotesNewRoute
  '/games/$gameId/quests/new': typeof AuthGamesGameIdQuestsNewRoute
  '/games/$gameId/characters': typeof AuthGamesGameIdCharactersIndexRoute
  '/games/$gameId/factions': typeof AuthGamesGameIdFactionsIndexRoute
  '/games/$gameId/locations': typeof AuthGamesGameIdLocationsIndexRoute
  '/games/$gameId/notes': typeof AuthGamesGameIdNotesIndexRoute
  '/games/$gameId/quests': typeof AuthGamesGameIdQuestsIndexRoute
  '/games/$gameId/characters/$id/edit': typeof AuthGamesGameIdCharactersIdEditRoute
  '/games/$gameId/factions/$id/edit': typeof AuthGamesGameIdFactionsIdEditRoute
  '/games/$gameId/locations/$id/edit': typeof AuthGamesGameIdLocationsIdEditRoute
  '/games/$gameId/notes/$id/edit': typeof AuthGamesGameIdNotesIdEditRoute
  '/games/$gameId/quests/$id/edit': typeof AuthGamesGameIdQuestsIdEditRoute
  '/games/$gameId/characters/$id': typeof AuthGamesGameIdCharactersIdIndexRoute
  '/games/$gameId/factions/$id': typeof AuthGamesGameIdFactionsIdIndexRoute
  '/games/$gameId/locations/$id': typeof AuthGamesGameIdLocationsIdIndexRoute
  '/games/$gameId/notes/$id': typeof AuthGamesGameIdNotesIdIndexRoute
  '/games/$gameId/quests/$id': typeof AuthGamesGameIdQuestsIdIndexRoute
}
export interface FileRoutesById {
  __root__: typeof rootRouteImport
  '/': typeof IndexRoute
  '/_auth': typeof AuthRouteWithChildren
  '/login': typeof LoginRoute
  '/logout': typeof LogoutRoute
  '/signup': typeof SignupRoute
  '/_auth/games/$gameId': typeof AuthGamesGameIdRouteRouteWithChildren
  '/_auth/games/new': typeof AuthGamesNewRoute
  '/_auth/games/': typeof AuthGamesIndexRoute
  '/_auth/games/$gameId/all': typeof AuthGamesGameIdAllRoute
  '/_auth/games/$gameId/edit': typeof AuthGamesGameIdEditRoute
  '/_auth/games/$gameId/tree': typeof AuthGamesGameIdTreeRoute
  '/_auth/games/$gameId/': typeof AuthGamesGameIdIndexRoute
  '/_auth/games/$gameId/characters/$id': typeof AuthGamesGameIdCharactersIdRouteRouteWithChildren
  '/_auth/games/$gameId/factions/$id': typeof AuthGamesGameIdFactionsIdRouteRouteWithChildren
  '/_auth/games/$gameId/locations/$id': typeof AuthGamesGameIdLocationsIdRouteRouteWithChildren
  '/_auth/games/$gameId/notes/$id': typeof AuthGamesGameIdNotesIdRouteRouteWithChildren
  '/_auth/games/$gameId/quests/$id': typeof AuthGamesGameIdQuestsIdRouteRouteWithChildren
  '/_auth/games/$gameId/characters/new': typeof AuthGamesGameIdCharactersNewRoute
  '/_auth/games/$gameId/factions/new': typeof AuthGamesGameIdFactionsNewRoute
  '/_auth/games/$gameId/locations/new': typeof AuthGamesGameIdLocationsNewRoute
  '/_auth/games/$gameId/notes/new': typeof AuthGamesGameIdNotesNewRoute
  '/_auth/games/$gameId/quests/new': typeof AuthGamesGameIdQuestsNewRoute
  '/_auth/games/$gameId/characters/': typeof AuthGamesGameIdCharactersIndexRoute
  '/_auth/games/$gameId/factions/': typeof AuthGamesGameIdFactionsIndexRoute
  '/_auth/games/$gameId/locations/': typeof AuthGamesGameIdLocationsIndexRoute
  '/_auth/games/$gameId/notes/': typeof AuthGamesGameIdNotesIndexRoute
  '/_auth/games/$gameId/quests/': typeof AuthGamesGameIdQuestsIndexRoute
  '/_auth/games/$gameId/characters/$id/edit': typeof AuthGamesGameIdCharactersIdEditRoute
  '/_auth/games/$gameId/factions/$id/edit': typeof AuthGamesGameIdFactionsIdEditRoute
  '/_auth/games/$gameId/locations/$id/edit': typeof AuthGamesGameIdLocationsIdEditRoute
  '/_auth/games/$gameId/notes/$id/edit': typeof AuthGamesGameIdNotesIdEditRoute
  '/_auth/games/$gameId/quests/$id/edit': typeof AuthGamesGameIdQuestsIdEditRoute
  '/_auth/games/$gameId/characters/$id/': typeof AuthGamesGameIdCharactersIdIndexRoute
  '/_auth/games/$gameId/factions/$id/': typeof AuthGamesGameIdFactionsIdIndexRoute
  '/_auth/games/$gameId/locations/$id/': typeof AuthGamesGameIdLocationsIdIndexRoute
  '/_auth/games/$gameId/notes/$id/': typeof AuthGamesGameIdNotesIdIndexRoute
  '/_auth/games/$gameId/quests/$id/': typeof AuthGamesGameIdQuestsIdIndexRoute
}
export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths:
    | '/'
    | '/login'
    | '/logout'
    | '/signup'
    | '/games/$gameId'
    | '/games/new'
    | '/games'
    | '/games/$gameId/all'
    | '/games/$gameId/edit'
    | '/games/$gameId/tree'
    | '/games/$gameId/'
    | '/games/$gameId/characters/$id'
    | '/games/$gameId/factions/$id'
    | '/games/$gameId/locations/$id'
    | '/games/$gameId/notes/$id'
    | '/games/$gameId/quests/$id'
    | '/games/$gameId/characters/new'
    | '/games/$gameId/factions/new'
    | '/games/$gameId/locations/new'
    | '/games/$gameId/notes/new'
    | '/games/$gameId/quests/new'
    | '/games/$gameId/characters'
    | '/games/$gameId/factions'
    | '/games/$gameId/locations'
    | '/games/$gameId/notes'
    | '/games/$gameId/quests'
    | '/games/$gameId/characters/$id/edit'
    | '/games/$gameId/factions/$id/edit'
    | '/games/$gameId/locations/$id/edit'
    | '/games/$gameId/notes/$id/edit'
    | '/games/$gameId/quests/$id/edit'
    | '/games/$gameId/characters/$id/'
    | '/games/$gameId/factions/$id/'
    | '/games/$gameId/locations/$id/'
    | '/games/$gameId/notes/$id/'
    | '/games/$gameId/quests/$id/'
  fileRoutesByTo: FileRoutesByTo
  to:
    | '/'
    | '/login'
    | '/logout'
    | '/signup'
    | '/games/new'
    | '/games'
    | '/games/$gameId/all'
    | '/games/$gameId/edit'
    | '/games/$gameId/tree'
    | '/games/$gameId'
    | '/games/$gameId/characters/new'
    | '/games/$gameId/factions/new'
    | '/games/$gameId/locations/new'
    | '/games/$gameId/notes/new'
    | '/games/$gameId/quests/new'
    | '/games/$gameId/characters'
    | '/games/$gameId/factions'
    | '/games/$gameId/locations'
    | '/games/$gameId/notes'
    | '/games/$gameId/quests'
    | '/games/$gameId/characters/$id/edit'
    | '/games/$gameId/factions/$id/edit'
    | '/games/$gameId/locations/$id/edit'
    | '/games/$gameId/notes/$id/edit'
    | '/games/$gameId/quests/$id/edit'
    | '/games/$gameId/characters/$id'
    | '/games/$gameId/factions/$id'
    | '/games/$gameId/locations/$id'
    | '/games/$gameId/notes/$id'
    | '/games/$gameId/quests/$id'
  id:
    | '__root__'
    | '/'
    | '/_auth'
    | '/login'
    | '/logout'
    | '/signup'
    | '/_auth/games/$gameId'
    | '/_auth/games/new'
    | '/_auth/games/'
    | '/_auth/games/$gameId/all'
    | '/_auth/games/$gameId/edit'
    | '/_auth/games/$gameId/tree'
    | '/_auth/games/$gameId/'
    | '/_auth/games/$gameId/characters/$id'
    | '/_auth/games/$gameId/factions/$id'
    | '/_auth/games/$gameId/locations/$id'
    | '/_auth/games/$gameId/notes/$id'
    | '/_auth/games/$gameId/quests/$id'
    | '/_auth/games/$gameId/characters/new'
    | '/_auth/games/$gameId/factions/new'
    | '/_auth/games/$gameId/locations/new'
    | '/_auth/games/$gameId/notes/new'
    | '/_auth/games/$gameId/quests/new'
    | '/_auth/games/$gameId/characters/'
    | '/_auth/games/$gameId/factions/'
    | '/_auth/games/$gameId/locations/'
    | '/_auth/games/$gameId/notes/'
    | '/_auth/games/$gameId/quests/'
    | '/_auth/games/$gameId/characters/$id/edit'
    | '/_auth/games/$gameId/factions/$id/edit'
    | '/_auth/games/$gameId/locations/$id/edit'
    | '/_auth/games/$gameId/notes/$id/edit'
    | '/_auth/games/$gameId/quests/$id/edit'
    | '/_auth/games/$gameId/characters/$id/'
    | '/_auth/games/$gameId/factions/$id/'
    | '/_auth/games/$gameId/locations/$id/'
    | '/_auth/games/$gameId/notes/$id/'
    | '/_auth/games/$gameId/quests/$id/'
  fileRoutesById: FileRoutesById
}
export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute
  AuthRoute: typeof AuthRouteWithChildren
  LoginRoute: typeof LoginRoute
  LogoutRoute: typeof LogoutRoute
  SignupRoute: typeof SignupRoute
}

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/signup': {
      id: '/signup'
      path: '/signup'
      fullPath: '/signup'
      preLoaderRoute: typeof SignupRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/logout': {
      id: '/logout'
      path: '/logout'
      fullPath: '/logout'
      preLoaderRoute: typeof LogoutRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/login': {
      id: '/login'
      path: '/login'
      fullPath: '/login'
      preLoaderRoute: typeof LoginRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/_auth': {
      id: '/_auth'
      path: ''
      fullPath: ''
      preLoaderRoute: typeof AuthRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/': {
      id: '/'
      path: '/'
      fullPath: '/'
      preLoaderRoute: typeof IndexRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/_auth/games/': {
      id: '/_auth/games/'
      path: '/games'
      fullPath: '/games'
      preLoaderRoute: typeof AuthGamesIndexRouteImport
      parentRoute: typeof AuthRoute
    }
    '/_auth/games/new': {
      id: '/_auth/games/new'
      path: '/games/new'
      fullPath: '/games/new'
      preLoaderRoute: typeof AuthGamesNewRouteImport
      parentRoute: typeof AuthRoute
    }
    '/_auth/games/$gameId': {
      id: '/_auth/games/$gameId'
      path: '/games/$gameId'
      fullPath: '/games/$gameId'
      preLoaderRoute: typeof AuthGamesGameIdRouteRouteImport
      parentRoute: typeof AuthRoute
    }
    '/_auth/games/$gameId/': {
      id: '/_auth/games/$gameId/'
      path: '/'
      fullPath: '/games/$gameId/'
      preLoaderRoute: typeof AuthGamesGameIdIndexRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/tree': {
      id: '/_auth/games/$gameId/tree'
      path: '/tree'
      fullPath: '/games/$gameId/tree'
      preLoaderRoute: typeof AuthGamesGameIdTreeRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/edit': {
      id: '/_auth/games/$gameId/edit'
      path: '/edit'
      fullPath: '/games/$gameId/edit'
      preLoaderRoute: typeof AuthGamesGameIdEditRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/all': {
      id: '/_auth/games/$gameId/all'
      path: '/all'
      fullPath: '/games/$gameId/all'
      preLoaderRoute: typeof AuthGamesGameIdAllRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/quests/': {
      id: '/_auth/games/$gameId/quests/'
      path: '/quests'
      fullPath: '/games/$gameId/quests'
      preLoaderRoute: typeof AuthGamesGameIdQuestsIndexRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/notes/': {
      id: '/_auth/games/$gameId/notes/'
      path: '/notes'
      fullPath: '/games/$gameId/notes'
      preLoaderRoute: typeof AuthGamesGameIdNotesIndexRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/locations/': {
      id: '/_auth/games/$gameId/locations/'
      path: '/locations'
      fullPath: '/games/$gameId/locations'
      preLoaderRoute: typeof AuthGamesGameIdLocationsIndexRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/factions/': {
      id: '/_auth/games/$gameId/factions/'
      path: '/factions'
      fullPath: '/games/$gameId/factions'
      preLoaderRoute: typeof AuthGamesGameIdFactionsIndexRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/characters/': {
      id: '/_auth/games/$gameId/characters/'
      path: '/characters'
      fullPath: '/games/$gameId/characters'
      preLoaderRoute: typeof AuthGamesGameIdCharactersIndexRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/quests/new': {
      id: '/_auth/games/$gameId/quests/new'
      path: '/quests/new'
      fullPath: '/games/$gameId/quests/new'
      preLoaderRoute: typeof AuthGamesGameIdQuestsNewRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/notes/new': {
      id: '/_auth/games/$gameId/notes/new'
      path: '/notes/new'
      fullPath: '/games/$gameId/notes/new'
      preLoaderRoute: typeof AuthGamesGameIdNotesNewRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/locations/new': {
      id: '/_auth/games/$gameId/locations/new'
      path: '/locations/new'
      fullPath: '/games/$gameId/locations/new'
      preLoaderRoute: typeof AuthGamesGameIdLocationsNewRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/factions/new': {
      id: '/_auth/games/$gameId/factions/new'
      path: '/factions/new'
      fullPath: '/games/$gameId/factions/new'
      preLoaderRoute: typeof AuthGamesGameIdFactionsNewRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/characters/new': {
      id: '/_auth/games/$gameId/characters/new'
      path: '/characters/new'
      fullPath: '/games/$gameId/characters/new'
      preLoaderRoute: typeof AuthGamesGameIdCharactersNewRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/quests/$id': {
      id: '/_auth/games/$gameId/quests/$id'
      path: '/quests/$id'
      fullPath: '/games/$gameId/quests/$id'
      preLoaderRoute: typeof AuthGamesGameIdQuestsIdRouteRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/notes/$id': {
      id: '/_auth/games/$gameId/notes/$id'
      path: '/notes/$id'
      fullPath: '/games/$gameId/notes/$id'
      preLoaderRoute: typeof AuthGamesGameIdNotesIdRouteRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/locations/$id': {
      id: '/_auth/games/$gameId/locations/$id'
      path: '/locations/$id'
      fullPath: '/games/$gameId/locations/$id'
      preLoaderRoute: typeof AuthGamesGameIdLocationsIdRouteRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/factions/$id': {
      id: '/_auth/games/$gameId/factions/$id'
      path: '/factions/$id'
      fullPath: '/games/$gameId/factions/$id'
      preLoaderRoute: typeof AuthGamesGameIdFactionsIdRouteRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/characters/$id': {
      id: '/_auth/games/$gameId/characters/$id'
      path: '/characters/$id'
      fullPath: '/games/$gameId/characters/$id'
      preLoaderRoute: typeof AuthGamesGameIdCharactersIdRouteRouteImport
      parentRoute: typeof AuthGamesGameIdRouteRoute
    }
    '/_auth/games/$gameId/quests/$id/': {
      id: '/_auth/games/$gameId/quests/$id/'
      path: '/'
      fullPath: '/games/$gameId/quests/$id/'
      preLoaderRoute: typeof AuthGamesGameIdQuestsIdIndexRouteImport
      parentRoute: typeof AuthGamesGameIdQuestsIdRouteRoute
    }
    '/_auth/games/$gameId/notes/$id/': {
      id: '/_auth/games/$gameId/notes/$id/'
      path: '/'
      fullPath: '/games/$gameId/notes/$id/'
      preLoaderRoute: typeof AuthGamesGameIdNotesIdIndexRouteImport
      parentRoute: typeof AuthGamesGameIdNotesIdRouteRoute
    }
    '/_auth/games/$gameId/locations/$id/': {
      id: '/_auth/games/$gameId/locations/$id/'
      path: '/'
      fullPath: '/games/$gameId/locations/$id/'
      preLoaderRoute: typeof AuthGamesGameIdLocationsIdIndexRouteImport
      parentRoute: typeof AuthGamesGameIdLocationsIdRouteRoute
    }
    '/_auth/games/$gameId/factions/$id/': {
      id: '/_auth/games/$gameId/factions/$id/'
      path: '/'
      fullPath: '/games/$gameId/factions/$id/'
      preLoaderRoute: typeof AuthGamesGameIdFactionsIdIndexRouteImport
      parentRoute: typeof AuthGamesGameIdFactionsIdRouteRoute
    }
    '/_auth/games/$gameId/characters/$id/': {
      id: '/_auth/games/$gameId/characters/$id/'
      path: '/'
      fullPath: '/games/$gameId/characters/$id/'
      preLoaderRoute: typeof AuthGamesGameIdCharactersIdIndexRouteImport
      parentRoute: typeof AuthGamesGameIdCharactersIdRouteRoute
    }
    '/_auth/games/$gameId/quests/$id/edit': {
      id: '/_auth/games/$gameId/quests/$id/edit'
      path: '/edit'
      fullPath: '/games/$gameId/quests/$id/edit'
      preLoaderRoute: typeof AuthGamesGameIdQuestsIdEditRouteImport
      parentRoute: typeof AuthGamesGameIdQuestsIdRouteRoute
    }
    '/_auth/games/$gameId/notes/$id/edit': {
      id: '/_auth/games/$gameId/notes/$id/edit'
      path: '/edit'
      fullPath: '/games/$gameId/notes/$id/edit'
      preLoaderRoute: typeof AuthGamesGameIdNotesIdEditRouteImport
      parentRoute: typeof AuthGamesGameIdNotesIdRouteRoute
    }
    '/_auth/games/$gameId/locations/$id/edit': {
      id: '/_auth/games/$gameId/locations/$id/edit'
      path: '/edit'
      fullPath: '/games/$gameId/locations/$id/edit'
      preLoaderRoute: typeof AuthGamesGameIdLocationsIdEditRouteImport
      parentRoute: typeof AuthGamesGameIdLocationsIdRouteRoute
    }
    '/_auth/games/$gameId/factions/$id/edit': {
      id: '/_auth/games/$gameId/factions/$id/edit'
      path: '/edit'
      fullPath: '/games/$gameId/factions/$id/edit'
      preLoaderRoute: typeof AuthGamesGameIdFactionsIdEditRouteImport
      parentRoute: typeof AuthGamesGameIdFactionsIdRouteRoute
    }
    '/_auth/games/$gameId/characters/$id/edit': {
      id: '/_auth/games/$gameId/characters/$id/edit'
      path: '/edit'
      fullPath: '/games/$gameId/characters/$id/edit'
      preLoaderRoute: typeof AuthGamesGameIdCharactersIdEditRouteImport
      parentRoute: typeof AuthGamesGameIdCharactersIdRouteRoute
    }
  }
}

interface AuthGamesGameIdCharactersIdRouteRouteChildren {
  AuthGamesGameIdCharactersIdEditRoute: typeof AuthGamesGameIdCharactersIdEditRoute
  AuthGamesGameIdCharactersIdIndexRoute: typeof AuthGamesGameIdCharactersIdIndexRoute
}

const AuthGamesGameIdCharactersIdRouteRouteChildren: AuthGamesGameIdCharactersIdRouteRouteChildren =
  {
    AuthGamesGameIdCharactersIdEditRoute: AuthGamesGameIdCharactersIdEditRoute,
    AuthGamesGameIdCharactersIdIndexRoute:
      AuthGamesGameIdCharactersIdIndexRoute,
  }

const AuthGamesGameIdCharactersIdRouteRouteWithChildren =
  AuthGamesGameIdCharactersIdRouteRoute._addFileChildren(
    AuthGamesGameIdCharactersIdRouteRouteChildren,
  )

interface AuthGamesGameIdFactionsIdRouteRouteChildren {
  AuthGamesGameIdFactionsIdEditRoute: typeof AuthGamesGameIdFactionsIdEditRoute
  AuthGamesGameIdFactionsIdIndexRoute: typeof AuthGamesGameIdFactionsIdIndexRoute
}

const AuthGamesGameIdFactionsIdRouteRouteChildren: AuthGamesGameIdFactionsIdRouteRouteChildren =
  {
    AuthGamesGameIdFactionsIdEditRoute: AuthGamesGameIdFactionsIdEditRoute,
    AuthGamesGameIdFactionsIdIndexRoute: AuthGamesGameIdFactionsIdIndexRoute,
  }

const AuthGamesGameIdFactionsIdRouteRouteWithChildren =
  AuthGamesGameIdFactionsIdRouteRoute._addFileChildren(
    AuthGamesGameIdFactionsIdRouteRouteChildren,
  )

interface AuthGamesGameIdLocationsIdRouteRouteChildren {
  AuthGamesGameIdLocationsIdEditRoute: typeof AuthGamesGameIdLocationsIdEditRoute
  AuthGamesGameIdLocationsIdIndexRoute: typeof AuthGamesGameIdLocationsIdIndexRoute
}

const AuthGamesGameIdLocationsIdRouteRouteChildren: AuthGamesGameIdLocationsIdRouteRouteChildren =
  {
    AuthGamesGameIdLocationsIdEditRoute: AuthGamesGameIdLocationsIdEditRoute,
    AuthGamesGameIdLocationsIdIndexRoute: AuthGamesGameIdLocationsIdIndexRoute,
  }

const AuthGamesGameIdLocationsIdRouteRouteWithChildren =
  AuthGamesGameIdLocationsIdRouteRoute._addFileChildren(
    AuthGamesGameIdLocationsIdRouteRouteChildren,
  )

interface AuthGamesGameIdNotesIdRouteRouteChildren {
  AuthGamesGameIdNotesIdEditRoute: typeof AuthGamesGameIdNotesIdEditRoute
  AuthGamesGameIdNotesIdIndexRoute: typeof AuthGamesGameIdNotesIdIndexRoute
}

const AuthGamesGameIdNotesIdRouteRouteChildren: AuthGamesGameIdNotesIdRouteRouteChildren =
  {
    AuthGamesGameIdNotesIdEditRoute: AuthGamesGameIdNotesIdEditRoute,
    AuthGamesGameIdNotesIdIndexRoute: AuthGamesGameIdNotesIdIndexRoute,
  }

const AuthGamesGameIdNotesIdRouteRouteWithChildren =
  AuthGamesGameIdNotesIdRouteRoute._addFileChildren(
    AuthGamesGameIdNotesIdRouteRouteChildren,
  )

interface AuthGamesGameIdQuestsIdRouteRouteChildren {
  AuthGamesGameIdQuestsIdEditRoute: typeof AuthGamesGameIdQuestsIdEditRoute
  AuthGamesGameIdQuestsIdIndexRoute: typeof AuthGamesGameIdQuestsIdIndexRoute
}

const AuthGamesGameIdQuestsIdRouteRouteChildren: AuthGamesGameIdQuestsIdRouteRouteChildren =
  {
    AuthGamesGameIdQuestsIdEditRoute: AuthGamesGameIdQuestsIdEditRoute,
    AuthGamesGameIdQuestsIdIndexRoute: AuthGamesGameIdQuestsIdIndexRoute,
  }

const AuthGamesGameIdQuestsIdRouteRouteWithChildren =
  AuthGamesGameIdQuestsIdRouteRoute._addFileChildren(
    AuthGamesGameIdQuestsIdRouteRouteChildren,
  )

interface AuthGamesGameIdRouteRouteChildren {
  AuthGamesGameIdAllRoute: typeof AuthGamesGameIdAllRoute
  AuthGamesGameIdEditRoute: typeof AuthGamesGameIdEditRoute
  AuthGamesGameIdTreeRoute: typeof AuthGamesGameIdTreeRoute
  AuthGamesGameIdIndexRoute: typeof AuthGamesGameIdIndexRoute
  AuthGamesGameIdCharactersIdRouteRoute: typeof AuthGamesGameIdCharactersIdRouteRouteWithChildren
  AuthGamesGameIdFactionsIdRouteRoute: typeof AuthGamesGameIdFactionsIdRouteRouteWithChildren
  AuthGamesGameIdLocationsIdRouteRoute: typeof AuthGamesGameIdLocationsIdRouteRouteWithChildren
  AuthGamesGameIdNotesIdRouteRoute: typeof AuthGamesGameIdNotesIdRouteRouteWithChildren
  AuthGamesGameIdQuestsIdRouteRoute: typeof AuthGamesGameIdQuestsIdRouteRouteWithChildren
  AuthGamesGameIdCharactersNewRoute: typeof AuthGamesGameIdCharactersNewRoute
  AuthGamesGameIdFactionsNewRoute: typeof AuthGamesGameIdFactionsNewRoute
  AuthGamesGameIdLocationsNewRoute: typeof AuthGamesGameIdLocationsNewRoute
  AuthGamesGameIdNotesNewRoute: typeof AuthGamesGameIdNotesNewRoute
  AuthGamesGameIdQuestsNewRoute: typeof AuthGamesGameIdQuestsNewRoute
  AuthGamesGameIdCharactersIndexRoute: typeof AuthGamesGameIdCharactersIndexRoute
  AuthGamesGameIdFactionsIndexRoute: typeof AuthGamesGameIdFactionsIndexRoute
  AuthGamesGameIdLocationsIndexRoute: typeof AuthGamesGameIdLocationsIndexRoute
  AuthGamesGameIdNotesIndexRoute: typeof AuthGamesGameIdNotesIndexRoute
  AuthGamesGameIdQuestsIndexRoute: typeof AuthGamesGameIdQuestsIndexRoute
}

const AuthGamesGameIdRouteRouteChildren: AuthGamesGameIdRouteRouteChildren = {
  AuthGamesGameIdAllRoute: AuthGamesGameIdAllRoute,
  AuthGamesGameIdEditRoute: AuthGamesGameIdEditRoute,
  AuthGamesGameIdTreeRoute: AuthGamesGameIdTreeRoute,
  AuthGamesGameIdIndexRoute: AuthGamesGameIdIndexRoute,
  AuthGamesGameIdCharactersIdRouteRoute:
    AuthGamesGameIdCharactersIdRouteRouteWithChildren,
  AuthGamesGameIdFactionsIdRouteRoute:
    AuthGamesGameIdFactionsIdRouteRouteWithChildren,
  AuthGamesGameIdLocationsIdRouteRoute:
    AuthGamesGameIdLocationsIdRouteRouteWithChildren,
  AuthGamesGameIdNotesIdRouteRoute:
    AuthGamesGameIdNotesIdRouteRouteWithChildren,
  AuthGamesGameIdQuestsIdRouteRoute:
    AuthGamesGameIdQuestsIdRouteRouteWithChildren,
  AuthGamesGameIdCharactersNewRoute: AuthGamesGameIdCharactersNewRoute,
  AuthGamesGameIdFactionsNewRoute: AuthGamesGameIdFactionsNewRoute,
  AuthGamesGameIdLocationsNewRoute: AuthGamesGameIdLocationsNewRoute,
  AuthGamesGameIdNotesNewRoute: AuthGamesGameIdNotesNewRoute,
  AuthGamesGameIdQuestsNewRoute: AuthGamesGameIdQuestsNewRoute,
  AuthGamesGameIdCharactersIndexRoute: AuthGamesGameIdCharactersIndexRoute,
  AuthGamesGameIdFactionsIndexRoute: AuthGamesGameIdFactionsIndexRoute,
  AuthGamesGameIdLocationsIndexRoute: AuthGamesGameIdLocationsIndexRoute,
  AuthGamesGameIdNotesIndexRoute: AuthGamesGameIdNotesIndexRoute,
  AuthGamesGameIdQuestsIndexRoute: AuthGamesGameIdQuestsIndexRoute,
}

const AuthGamesGameIdRouteRouteWithChildren =
  AuthGamesGameIdRouteRoute._addFileChildren(AuthGamesGameIdRouteRouteChildren)

interface AuthRouteChildren {
  AuthGamesGameIdRouteRoute: typeof AuthGamesGameIdRouteRouteWithChildren
  AuthGamesNewRoute: typeof AuthGamesNewRoute
  AuthGamesIndexRoute: typeof AuthGamesIndexRoute
}

const AuthRouteChildren: AuthRouteChildren = {
  AuthGamesGameIdRouteRoute: AuthGamesGameIdRouteRouteWithChildren,
  AuthGamesNewRoute: AuthGamesNewRoute,
  AuthGamesIndexRoute: AuthGamesIndexRoute,
}

const AuthRouteWithChildren = AuthRoute._addFileChildren(AuthRouteChildren)

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  AuthRoute: AuthRouteWithChildren,
  LoginRoute: LoginRoute,
  LogoutRoute: LogoutRoute,
  SignupRoute: SignupRoute,
}
export const routeTree = rootRouteImport
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()

import type { getRouter } from './router.tsx'
import type { createStart } from '@tanstack/react-start'
declare module '@tanstack/react-start' {
  interface Register {
    ssr: true
    router: Awaited<ReturnType<typeof getRouter>>
  }
}
</file>

<file path="package.json">
{
	"name": "game-master-web",
	"private": true,
	"sideEffects": false,
	"type": "module",
	"scripts": {
		"dev": "vite dev --port 3000",
		"start": "node .output/server/index.mjs",
		"build": "vite build",
		"serve": "vite preview",
		"test": "vitest run",
		"format": "biome format",
		"lint": "biome lint",
		"check": "biome check",
		"typecheck": "tsc --noEmit",
		"codegen": "openapi-ts",
		"deploy": "wrangler deploy"
	},
	"dependencies": {
		"@base-ui-components/react": "1.0.0-beta.3",
		"@radix-ui/react-dialog": "^1.1.15",
		"@tailwindcss/vite": "^4.0.6",
		"@tanstack/match-sorter-utils": "^8.19.4",
		"@tanstack/react-form": "^1.19.3",
		"@tanstack/react-query": "^5.66.0",
		"@tanstack/react-router": "^1.132.19",
		"@tanstack/react-router-ssr-query": "^1.132.19",
		"@tanstack/react-start": "^1.132.19",
		"@tanstack/react-table": "^8.21.2",
		"@tiptap/core": "^3.6.0",
		"@tiptap/extension-blockquote": "^3.6.0",
		"@tiptap/extension-bold": "^3.6.0",
		"@tiptap/extension-bullet-list": "^3.6.0",
		"@tiptap/extension-code": "^3.6.0",
		"@tiptap/extension-code-block": "^3.6.0",
		"@tiptap/extension-document": "^3.6.0",
		"@tiptap/extension-dropcursor": "^3.6.0",
		"@tiptap/extension-gapcursor": "^3.6.0",
		"@tiptap/extension-hard-break": "^3.6.0",
		"@tiptap/extension-heading": "^3.6.0",
		"@tiptap/extension-history": "^3.6.0",
		"@tiptap/extension-horizontal-rule": "^3.6.0",
		"@tiptap/extension-italic": "^3.6.0",
		"@tiptap/extension-list-item": "^3.6.0",
		"@tiptap/extension-mention": "^3.6.0",
		"@tiptap/extension-ordered-list": "^3.6.0",
		"@tiptap/extension-paragraph": "^3.6.0",
		"@tiptap/extension-strike": "^3.6.0",
		"@tiptap/extension-text": "^3.6.0",
		"@tiptap/extension-underline": "^3.6.0",
		"@tiptap/pm": "^3.6.0",
		"@tiptap/react": "^3.6.0",
		"@tiptap/starter-kit": "^3.6.0",
		"@tiptap/suggestion": "^3.6.0",
		"class-variance-authority": "^0.7.1",
		"clsx": "^2.1.1",
		"cmdk": "^1.1.1",
		"lucide-react": "^0.542.0",
		"motion": "^12.23.13",
		"next-themes": "^0.4.6",
		"react": "^19.0.0",
		"react-dom": "^19.0.0",
		"sonner": "^2.0.7",
		"tailwind-merge": "^3.3.1",
		"tailwindcss": "^4.0.6",
		"tippy.js": "^6.3.7",
		"vaul": "^1.1.2",
		"vite-tsconfig-paths": "^5.1.4",
		"zod": "^4.1.5"
	},
	"devDependencies": {
		"@biomejs/biome": "2.2.3",
		"@cloudflare/vite-plugin": "^1.13.7",
		"@hey-api/openapi-ts": "0.82.5",
		"@tanstack/react-query-devtools": "^5.66.0",
		"@tanstack/react-router-devtools": "^1.132.19",
		"@testing-library/dom": "^10.4.0",
		"@testing-library/react": "^16.2.0",
		"@types/node": "^22.5.4",
		"@types/react": "^19.0.8",
		"@types/react-dom": "^19.0.3",
		"@vitejs/plugin-react": "^4.3.4",
		"jsdom": "^26.0.0",
		"tw-animate-css": "^1.3.8",
		"typescript": "^5.7.2",
		"vite": "^7.1.7",
		"vitest": "^3.0.5",
		"web-vitals": "^4.2.4",
		"wrangler": "^4.40.2"
	}
}
</file>

</files>
